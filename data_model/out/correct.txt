==================
NL:call the function _trans.get_language_bidi [ _trans . get_language_bidi ] , return the result .
Tgt:  return NAME . NAME ( )
Pred: return NAME . NAME ( )

Tgt:  return _trans . get_language_bidi ( )
Pred: return _trans . get_language_bidi ( )
==================
NL:if not ,
Tgt:  else :
Pred: else :

Tgt:  else :
Pred: else :
==================
NL:if not ,
Tgt:  else :
Pred: else :

Tgt:  else :
Pred: else :
==================
NL:return an empty list .
Tgt:  return [ ]
Pred: return [ ]

Tgt:  return [ ]
Pred: return [ ]
==================
NL:define the method __getinitargs__ with an argument self .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def __getinitargs__ ( self ) :
Pred: def __getinitargs__ ( self ) :
==================
NL:if s is an instance of SafeData .
Tgt:  if isinstance ( NAME , NAME ) :
Pred: if isinstance ( NAME , NAME ) :

Tgt:  if isinstance ( s , SafeData ) :
Pred: if isinstance ( s , SafeData ) :
==================
NL:define the method _new_instance with 4 arguments : ( cls , children set to None , connector set to None and negated set to boolean False .
Tgt:  def NAME ( NAME , NAME = None , NAME = None , NAME = False ) :
Pred: def NAME ( NAME , NAME = None , NAME = None , NAME = False ) :

Tgt:  def _new_instance ( cls , children = None , connector = None , negated = False ) :
Pred: def _new_instance ( cls , children = None , connector = None , negated = False ) :
==================
NL:if to_lower is true ,
Tgt:  if NAME :
Pred: if NAME :

Tgt:  if to_lower :
Pred: if to_lower :
==================
NL:substitute self.__class__ [ self . __class__ ] for obj.__class__ [ obj . __class__ ] .
Tgt:  NAME . NAME = NAME . NAME
Pred: NAME . NAME = NAME . NAME

Tgt:  obj . __class__ = self . __class__
Pred: obj . __class__ = self . __class__
==================
NL:increment s_len by integer 1 ,
Tgt:  NAME += NUMBER
Pred: NAME += NUMBER

Tgt:  s_len += 1
Pred: s_len += 1
==================
NL:DARK_PALETTE is a string _STR:0_ .
Tgt:  NAME = STRING
Pred: NAME = STRING

Tgt:  DARK_PALETTE = <[> _STR:0_ <]>
Pred: DARK_PALETTE = <[> _STR:0_ <]>
==================
NL:call the function allow_lazy with 2 arguments : javascript_quote and six.text_type [ six . text_type ] , substitute the result for javascript_quote .
Tgt:  NAME = NAME ( NAME , NAME . NAME )
Pred: NAME = NAME ( NAME , NAME . NAME )

Tgt:  javascript_quote = allow_lazy ( javascript_quote , six . text_type )
Pred: javascript_quote = allow_lazy ( javascript_quote , six . text_type )
==================
NL:return self.__language [ self . __language ] .
Tgt:  return NAME . NAME
Pred: return NAME . NAME

Tgt:  return self . __language
Pred: return self . __language
==================
NL:define the method _isdst with 2 arguments : self and dt .
Tgt:  def NAME ( NAME , NAME ) :
Pred: def NAME ( NAME , NAME ) :

Tgt:  def _isdst ( self , dt ) :
Pred: def _isdst ( self , dt ) :
==================
NL:trimmed is boolean False .
Tgt:  NAME = False
Pred: NAME = False

Tgt:  trimmed = False
Pred: trimmed = False
==================
NL:if connector is true , substitute it for self.connector [ self . connector ] , otherwise substitute self.default [ self . default ] for self.connector [ self . connector ] .
Tgt:  NAME . NAME = NAME or NAME . NAME
Pred: NAME . NAME = NAME or NAME . NAME

Tgt:  self . connector = connector or self . default
Pred: self . connector = connector or self . default
==================
NL:self.vals [ self . vals ] is an empty list .
Tgt:  NAME . NAME = [ ]
Pred: NAME . NAME = [ ]

Tgt:  self . vals = [ ]
Pred: self . vals = [ ]
==================
NL:from django.utils.deprecation [ django . utils . deprecation ] import RemovedInDjango19Warning into default name space .
Tgt:  from NAME . NAME . NAME import NAME
Pred: from NAME . NAME . NAME import NAME

Tgt:  from django . utils . deprecation import RemovedInDjango19Warning
Pred: from django . utils . deprecation import RemovedInDjango19Warning
==================
NL:call the method self._isdst [ self . _isdst ] with an argument dt , if it evaluates to true ,
Tgt:  if NAME . NAME ( NAME ) :
Pred: if NAME . NAME ( NAME ) :

Tgt:  if self . _isdst ( dt ) :
Pred: if self . _isdst ( dt ) :
==================
NL:call the method datetime.now [ datetime . now ] , return the result .
Tgt:  return NAME . NAME ( )
Pred: return NAME . NAME ( )

Tgt:  return datetime . now ( )
Pred: return datetime . now ( )
==================
NL:substitute name for new_mod .
Tgt:  NAME = NAME
Pred: NAME = NAME

Tgt:  new_mod = name
Pred: new_mod = name
==================
NL:call the method self.characters [ self . characters ] with an argument contents .
Tgt:  NAME . NAME ( NAME )
Pred: NAME . NAME ( NAME )

Tgt:  self . characters ( contents )
Pred: self . characters ( contents )
==================
NL:return message .
Tgt:  return NAME
Pred: return NAME

Tgt:  return message
Pred: return message
==================
NL:define the function pgettext with 2 arguments : context and message .
Tgt:  def NAME ( NAME , NAME ) :
Pred: def NAME ( NAME , NAME ) :

Tgt:  def pgettext ( context , message ) :
Pred: def pgettext ( context , message ) :
==================
NL:call the method ustring_re.sub [ ustring_re . sub ] with 2 arguments : fix and s , return the result .
Tgt:  return NAME . NAME ( NAME , NAME )
Pred: return NAME . NAME ( NAME , NAME )

Tgt:  return ustring_re . sub ( fix , s )
Pred: return ustring_re . sub ( fix , s )
==================
NL:call the function _trans.get_language [ _trans . get_language ] , return the result .
Tgt:  return NAME . NAME ( )
Pred: return NAME . NAME ( )

Tgt:  return _trans . get_language ( )
Pred: return _trans . get_language ( )
==================
NL:zbuf is an instance of BytesIO class .
Tgt:  NAME = NAME ( )
Pred: NAME = NAME ( )

Tgt:  zbuf = BytesIO ( )
Pred: zbuf = BytesIO ( )
==================
NL:call the function get_supported_language_variant with 2 arguments : lang_code and strict set to strict , return the result .
Tgt:  return NAME ( NAME , NAME = NAME )
Pred: return NAME ( NAME , NAME = NAME )

Tgt:  return get_supported_language_variant ( lang_code , strict = strict )
Pred: return get_supported_language_variant ( lang_code , strict = strict )
==================
NL:import io .
Tgt:  import NAME
Pred: import NAME

Tgt:  import io
Pred: import io
==================
NL:return self.__name [ self . __name ] .
Tgt:  return NAME . NAME
Pred: return NAME . NAME

Tgt:  return self . __name
Pred: return self . __name
==================
NL:derive the class Node from object base class .
Tgt:  class NAME ( object ) :
Pred: class NAME ( object ) :

Tgt:  class Node ( object ) :
Pred: class Node ( object ) :
==================
NL:if line is true ,
Tgt:  if NAME :
Pred: if NAME :

Tgt:  if line :
Pred: if line :
==================
NL:if first element of message_context equals to character _STR:0_ ,
Tgt:  if NAME [ NUMBER ] == STRING :
Pred: if NAME [ NUMBER ] == STRING :

Tgt:  if message_context [ 0 ] == <[> _STR:0_ <]> :
Pred: if message_context [ 0 ] == <[> _STR:0_ <]> :
==================
NL:substitute name for self.__name [ self . __name ] .
Tgt:  NAME . NAME = NAME
Pred: NAME . NAME = NAME

Tgt:  self . __name = name
Pred: self . __name = name
==================
NL:if not ,
Tgt:  else :
Pred: else :

Tgt:  else :
Pred: else :
==================
NL:return an instance of EscapeText , created with an argument s .
Tgt:  return NAME ( NAME )
Pred: return NAME ( NAME )

Tgt:  return EscapeText ( s )
Pred: return EscapeText ( s )
==================
NL:self.children [ self . children ] is an list with 2 elements : obj and data .
Tgt:  NAME . NAME = [ NAME , NAME ]
Pred: NAME . NAME = [ NAME , NAME ]

Tgt:  self . children = [ obj , data ]
Pred: self . children = [ obj , data ]
==================
NL:define the function get_language_bidi .
Tgt:  def NAME ( ) :
Pred: def NAME ( ) :

Tgt:  def get_language_bidi ( ) :
Pred: def get_language_bidi ( ) :
==================
NL:return nothing .
Tgt:  NAME
Pred: NAME

Tgt:  return
Pred: return
==================
NL:substitute bytes for binary_type .
Tgt:  NAME = NAME
Pred: NAME = NAME

Tgt:  binary_type = bytes
Pred: binary_type = bytes
==================
NL:if base_lang is contained in settings.LANGUAGES_BIDI [ settings . LANGUAGES_BIDI ] , return boolean True , if not , return boolean False .
Tgt:  return NAME in NAME . NAME
Pred: return NAME in NAME . NAME

Tgt:  return base_lang in settings . LANGUAGES_BIDI
Pred: return base_lang in settings . LANGUAGES_BIDI
==================
NL:define the method __dir__ with an argument self .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def __dir__ ( self ) :
Pred: def __dir__ ( self ) :
==================
NL:define the function activate with an argument language .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def activate ( language ) :
Pred: def activate ( language ) :
==================
NL:if t.token_type [ t . token_type ] is not equal to TOKEN_COMMENT ,
Tgt:  if NAME . NAME != NAME :
Pred: if NAME . NAME != NAME :

Tgt:  if t . token_type != TOKEN_COMMENT :
Pred: if t . token_type != TOKEN_COMMENT :
==================
NL:_STR:0_ . for every app_config in app_configs ,
Tgt:  for NAME in NAME :
Pred: for NAME in NAME :

Tgt:  for app_config in app_configs :
Pred: for app_config in app_configs :
==================
NL:_localtime is None .
Tgt:  NAME = None
Pred: NAME = None

Tgt:  _localtime = None
Pred: _localtime = None
==================
NL:from __future__ import unicode_literals into default name space .
Tgt:  from NAME import NAME
Pred: from NAME import NAME

Tgt:  from __future__ import unicode_literals
Pred: from __future__ import unicode_literals
==================
NL:use global variable _supported .
Tgt:  global NAME
Pred: global NAME

Tgt:  global _supported
Pred: global _supported
==================
NL:call the method zfile.close [ zfile . close ] .
Tgt:  NAME . NAME ( )
Pred: NAME . NAME ( )

Tgt:  zfile . close ( )
Pred: zfile . close ( )
==================
NL:decrement self.waiting_writers [ self . waiting_writers ] by integer 1 ,
Tgt:  NAME . NAME -= NUMBER
Pred: NAME . NAME -= NUMBER

Tgt:  self . waiting_writers -= 1
Pred: self . waiting_writers -= 1
==================
NL:import module time .
Tgt:  import NAME
Pred: import NAME

Tgt:  import time
Pred: import time
==================
NL:replace every occurrence of _STR:0_ in s with _STR:1_ .
Tgt:  NAME = NAME . NAME ( STRING , STRING )
Pred: NAME = NAME . NAME ( STRING , STRING )

Tgt:  s = s . replace ( <[> _STR:0_ <]> , <[> _STR:1_ <]> )
Pred: s = s . replace ( <[> _STR:0_ <]> , <[> _STR:1_ <]> )
==================
NL:substitute frame.f_globals [ frame . f_globals ] for _globs_ .
Tgt:  NAME = NAME . NAME
Pred: NAME = NAME . NAME

Tgt:  _globs_ = frame . f_globals
Pred: _globs_ = frame . f_globals
==================
NL:decrement self.waiting_writers [ self . waiting_writers ] by integer 1 ,
Tgt:  NAME . NAME -= NUMBER
Pred: NAME . NAME -= NUMBER

Tgt:  self . waiting_writers -= 1
Pred: self . waiting_writers -= 1
==================
NL:substitute operator.getitem [ operator . getitem ] for indexbytes .
Tgt:  NAME = NAME . NAME
Pred: NAME = NAME . NAME

Tgt:  indexbytes = operator . getitem
Pred: indexbytes = operator . getitem
==================
NL:call the method self._add_installed_apps_translations [ self . _add_installed_apps_translations ] .
Tgt:  NAME . NAME ( )
Pred: NAME . NAME ( )

Tgt:  self . _add_installed_apps_translations ( )
Pred: self . _add_installed_apps_translations ( )
==================
NL:if regex_match is false ,
Tgt:  if not NAME :
Pred: if not NAME :

Tgt:  if not regex_match :
Pred: if not regex_match :
==================
NL:import module time as _time .
Tgt:  import NAME as NAME
Pred: import NAME as NAME

Tgt:  import time as _time
Pred: import time as _time
==================
NL:call the function _trans.check_for_language [ _trans . check_for_language ] with an argument lang_code , return the result .
Tgt:  return NAME . NAME ( NAME )
Pred: return NAME . NAME ( NAME )

Tgt:  return _trans . check_for_language ( lang_code )
Pred: return _trans . check_for_language ( lang_code )
==================
NL:line is an empty string .
Tgt:  NAME = STRING
Pred: NAME = STRING

Tgt:  line = <[>  <]>
Pred: line = <[>  <]>
==================
NL:call the method self.writer_enters [ self . writer_enters ] .
Tgt:  NAME . NAME ( )
Pred: NAME . NAME ( )

Tgt:  self . writer_enters ( )
Pred: self . writer_enters ( )
==================
NL:_STR:0_ and RemovedInDjango19Warning . if offset is an instance of timedelta class ,
Tgt:  if isinstance ( NAME , NAME ) :
Pred: if isinstance ( NAME , NAME ) :

Tgt:  if isinstance ( offset , timedelta ) :
Pred: if isinstance ( offset , timedelta ) :
==================
NL:get the value under the _STR:0_ key of the request.META [ request . META ] dictionary , if it exists substitute it for accept ,
Tgt:  NAME = NAME . NAME . NAME ( STRING , STRING )
Pred: NAME = NAME . NAME . NAME ( STRING , STRING )

Tgt:  accept = request . META . get ( <[> _STR:0_ <]> , <[>  <]> )
Pred: accept = request . META . get ( <[> _STR:0_ <]> , <[>  <]> )
==================
NL:return settings.LANGUAGE_CODE [ settings . LANGUAGE_CODE ] .
Tgt:  return NAME . NAME
Pred: return NAME . NAME

Tgt:  return settings . LANGUAGE_CODE
Pred: return settings . LANGUAGE_CODE
==================
NL:inplural is boolean True .
Tgt:  NAME = True
Pred: NAME = True

Tgt:  inplural = True
Pred: inplural = True
==================
NL:definition is an empty dictionary ,
Tgt:  NAME = { }
Pred: NAME = { }

Tgt:  definition = { }
Pred: definition = { }
==================
NL:_localtime is an instance of LocalTimezone class .
Tgt:  NAME = NAME ( )
Pred: NAME = NAME ( )

Tgt:  _localtime = LocalTimezone ( )
Pred: _localtime = LocalTimezone ( )
==================
NL:if want_unicode is false ,
Tgt:  if not NAME :
Pred: if not NAME :

Tgt:  if not want_unicode :
Pred: if not want_unicode :
==================
NL:if lang_code is true ,
Tgt:  if NAME :
Pred: if NAME :

Tgt:  if lang_code :
Pred: if lang_code :
==================
NL:do nothing .
Tgt:  NAME
Pred: NAME

Tgt:  pass
Pred: pass
==================
NL:current_len is equal to integer 0 .
Tgt:  NAME = NUMBER
Pred: NAME = NUMBER

Tgt:  current_len = 0
Pred: current_len = 0
==================
NL:intrans is boolean False .
Tgt:  NAME = False
Pred: NAME = False

Tgt:  intrans = False
Pred: intrans = False
==================
NL:return an instance of SafeText , created with an argument data .
Tgt:  return NAME ( NAME )
Pred: return NAME ( NAME )

Tgt:  return SafeText ( data )
Pred: return SafeText ( data )
==================
NL:if LookupError exception is caught ,
Tgt:  except NAME :
Pred: except NAME :

Tgt:  except LookupError :
Pred: except LookupError :
==================
NL:delete attr .
Tgt:  del NAME
Pred: del NAME

Tgt:  del attr
Pred: del attr
==================
NL:return text .
Tgt:  return NAME
Pred: return NAME

Tgt:  return text
Pred: return text
==================
NL:otherwise if k equals a string _STR:0_ ,
Tgt:  elif NAME == STRING :
Pred: elif NAME == STRING :

Tgt:  elif k == <[> _STR:0_ <]> :
Pred: elif k == <[> _STR:0_ <]> :
==================
NL:try ,
Tgt:  try :
Pred: try :

Tgt:  try :
Pred: try :
==================
NL:if NameError exception is caught ,
Tgt:  except NAME :
Pred: except NAME :

Tgt:  except NameError :
Pred: except NameError :
==================
NL:if KeyError exception is caught ,
Tgt:  except NAME :
Pred: except NAME :

Tgt:  except KeyError :
Pred: except KeyError :
==================
NL:append contents to plural .
Tgt:  NAME . NAME ( NAME )
Pred: NAME . NAME ( NAME )

Tgt:  plural . append ( contents )
Pred: plural . append ( contents )
==================
NL:and trimmed and result of the function join_tokens called with 2 arguments : plural and trimmed , write the result to out . for every part in singular ,
Tgt:  for NAME in NAME :
Pred: for NAME in NAME :

Tgt:  for part in singular :
Pred: for part in singular :
==================
NL:if first element of sys.version_info [ sys . version_info ] equals integer 2 , PY2 is boolean True , otherwise it is boolean False .
Tgt:  NAME = NAME . NAME [ NUMBER ] == NUMBER
Pred: NAME = NAME . NAME [ NUMBER ] == NUMBER

Tgt:  PY2 = sys . version_info [ 0 ] == 2
Pred: PY2 = sys . version_info [ 0 ] == 2
==================
NL:new_args is an empty list .
Tgt:  NAME = [ ]
Pred: NAME = [ ]

Tgt:  new_args = [ ]
Pred: new_args = [ ]
==================
NL:raise an TypeError exception with an argument string _STR:0_ .
Tgt:  raise NAME ( STRING )
Pred: raise NAME ( STRING )

Tgt:  raise TypeError ( <[> _STR:0_ <]> )
Pred: raise TypeError ( <[> _STR:0_ <]> )
==================
NL:from django.core.exceptions [ django . core . exceptions ] import AppRegistryNotReady into default name space .
Tgt:  from NAME . NAME . NAME import NAME
Pred: from NAME . NAME . NAME import NAME

Tgt:  from django . core . exceptions import AppRegistryNotReady
Pred: from django . core . exceptions import AppRegistryNotReady
==================
NL:new_result is an empty list .
Tgt:  NAME = [ ]
Pred: NAME = [ ]

Tgt:  new_result = [ ]
Pred: new_result = [ ]
==================
NL:return an instance of SafeText , created with an argument s .
Tgt:  return NAME ( NAME )
Pred: return NAME ( NAME )

Tgt:  return SafeText ( s )
Pred: return SafeText ( s )
==================
NL:if fg is contained in color_names ,
Tgt:  if NAME in NAME :
Pred: if NAME in NAME :

Tgt:  if fg in color_names :
Pred: if fg in color_names :
==================
NL:call the function ungettext with 3 arguments : singular , plural and number , return the result .
Tgt:  return NAME ( NAME , NAME , NAME )
Pred: return NAME ( NAME , NAME , NAME )

Tgt:  return ungettext ( singular , plural , number )
Pred: return ungettext ( singular , plural , number )
==================
NL:return None .
Tgt:  return None
Pred: return None

Tgt:  return None
Pred: return None
==================
NL:join app_config.path [ app_config . path ] and string _STR:0_ into a file path , substitute it for localedir .
Tgt:  NAME = NAME . NAME . NAME ( NAME . NAME , STRING )
Pred: NAME = NAME . NAME . NAME ( NAME . NAME , STRING )

Tgt:  localedir = os . path . join ( app_config . path , <[> _STR:0_ <]> )
Pred: localedir = os . path . join ( app_config . path , <[> _STR:0_ <]> )
==================
NL:write data to fp .
Tgt:  NAME . NAME ( NAME )
Pred: NAME . NAME ( NAME )

Tgt:  fp . write ( data )
Pred: fp . write ( data )
==================
NL:try ,
Tgt:  try :
Pred: try :

Tgt:  try :
Pred: try :
==================
NL:to the function timedelta called with an argument seconds as negative time.altzone [ time . altzone ] , return the result . if not ,
Tgt:  else :
Pred: else :

Tgt:  else :
Pred: else :
==================
NL:decorator function lru_cache.lru_cache [ lru_cache . lru_cache ] with an argument maxsize set to integer 1000 .
Tgt:  @ NAME . NAME ( NAME = NUMBER )
Pred: @ NAME . NAME ( NAME = NUMBER )

Tgt:  @ lru_cache . lru_cache ( maxsize = 1000 )
Pred: @ lru_cache . lru_cache ( maxsize = 1000 )
==================
NL:if t is not None ,
Tgt:  if NAME is not None :
Pred: if NAME is not None :

Tgt:  if t is not None :
Pred: if t is not None :
==================
NL:import module warnings .
Tgt:  import NAME
Pred: import NAME

Tgt:  import warnings
Pred: import warnings
==================
NL:increment self.waiting_writers [ self . waiting_writers ] by integer 1 ,
Tgt:  NAME . NAME += NUMBER
Pred: NAME . NAME += NUMBER

Tgt:  self . waiting_writers += 1
Pred: self . waiting_writers += 1
==================
NL:if self.active_readers [ self . active_readers ] equals integer 0 and self.waiting_writers [ self . waiting_writers ] is not equal to integer 0 ,
Tgt:  if NAME . NAME == NUMBER and NAME . NAME != NUMBER :
Pred: if NAME . NAME == NUMBER and NAME . NAME != NUMBER :

Tgt:  if self . active_readers == 0 and self . waiting_writers != 0 :
Pred: if self . active_readers == 0 and self . waiting_writers != 0 :
==================
NL:define the method merge with 2 arguments self and other .
Tgt:  def NAME ( NAME , NAME ) :
Pred: def NAME ( NAME , NAME ) :

Tgt:  def merge ( self , other ) :
Pred: def merge ( self , other ) :
==================
NL:if not ,
Tgt:  else :
Pred: else :

Tgt:  else :
Pred: else :
==================
NL:return .
Tgt:  NAME
Pred: NAME

Tgt:  return
Pred: return
==================
NL:define the function get_valid_filename with an argument s .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def get_valid_filename ( s ) :
Pred: def get_valid_filename ( s ) :
==================
NL:call the function flatten_result with an argument item , assign the result to res and args , respectively .
Tgt:  NAME , NAME = NAME ( NAME )
Pred: NAME , NAME = NAME ( NAME )

Tgt:  res , args = flatten_result ( item )
Pred: res , args = flatten_result ( item )
==================
NL:return ret .
Tgt:  return NAME
Pred: return NAME

Tgt:  return ret
Pred: return ret
==================
NL:call the function warnings.warn [ warnings . warn ] with 3 arguments : string _STR:0_ ,
Tgt:  NAME . NAME ( STRING , NAME , NAME = NUMBER )
Pred: NAME . NAME ( STRING , NAME , NAME = NUMBER )

Tgt:  warnings . warn ( <[> _STR:0_ <]> , RemovedInDjango19Warning , stacklevel = 2 )
Pred: warnings . warn ( <[> _STR:0_ <]> , RemovedInDjango19Warning , stacklevel = 2 )
==================
NL:call the function deactivate_all .
Tgt:  NAME ( )
Pred: NAME ( )

Tgt:  deactivate_all ( )
Pred: deactivate_all ( )
==================
NL:and _STR:0_ for _STR:1_ . define the method colorize with 3 arguments : text set to an empty string , opts set to an empty tuple and unpacked dictionary kwargs .
Tgt:  def NAME ( NAME = STRING , NAME = ( ) , ** NAME ) :
Pred: def NAME ( NAME = STRING , NAME = ( ) , ** NAME ) :

Tgt:  def colorize ( text = <[>  <]> , opts = ( ) , ** kwargs ) :
Pred: def colorize ( text = <[>  <]> , opts = ( ) , ** kwargs ) :
==================
NL:call the method timezone.normalize [ timezone . normalize ] with an argument value , substitute the result for value .
Tgt:  NAME = NAME . NAME ( NAME )
Pred: NAME = NAME . NAME ( NAME )

Tgt:  value = timezone . normalize ( value )
Pred: value = timezone . normalize ( value )
==================
NL:return result .
Tgt:  return NAME
Pred: return NAME

Tgt:  return result
Pred: return result
==================
NL:return an instance of FixedOffset class , created with 2 arguments : offset and name .
Tgt:  return NAME ( NAME , NAME )
Pred: return NAME ( NAME , NAME )

Tgt:  return FixedOffset ( offset , name )
Pred: return FixedOffset ( offset , name )
==================
NL:if ValueError exception is caught ,
Tgt:  except NAME :
Pred: except NAME :

Tgt:  except ValueError :
Pred: except ValueError :
==================
NL:skip this loop iteration .
Tgt:  NAME
Pred: NAME

Tgt:  continue
Pred: continue
==================
NL:_func_globals is a string _STR:0_ .
Tgt:  NAME = STRING
Pred: NAME = STRING

Tgt:  _func_globals = <[> _STR:0_ <]>
Pred: _func_globals = <[> _STR:0_ <]>
==================
NL:if not ,
Tgt:  else :
Pred: else :

Tgt:  else :
Pred: else :
==================
NL:call the __add__ method with an arguments rhs from the base class of the class SafeText , substitute the result for t .
Tgt:  NAME = super ( NAME , NAME ) . NAME ( NAME )
Pred: NAME = super ( NAME , NAME ) . NAME ( NAME )

Tgt:  t = super ( SafeText , self ) . __add__ ( rhs )
Pred: t = super ( SafeText , self ) . __add__ ( rhs )
==================
NL:call the function all_locale_paths , for every path is the result ,
Tgt:  for NAME in NAME ( ) :
Pred: for NAME in NAME ( ) :

Tgt:  for path in all_locale_paths ( ) :
Pred: for path in all_locale_paths ( ) :
==================
NL:call the method re_newlines.sub [ re_newlines . sub ] with 2 arguments : _STR:0_ and text , return the result .
Tgt:  return NAME . NAME ( STRING , NAME )
Pred: return NAME . NAME ( STRING , NAME )

Tgt:  return re_newlines . sub ( <[> _STR:0_ <]> , text )
Pred: return re_newlines . sub ( <[> _STR:0_ <]> , text )
==================
NL:decorator classmethod ,
Tgt:  @ classmethod
Pred: @ classmethod

Tgt:  @ classmethod
Pred: @ classmethod
==================
NL:skip this loop iteration .
Tgt:  NAME
Pred: NAME

Tgt:  continue
Pred: continue
==================
NL:convert tagname to lowercase , substitute it for tagname .
Tgt:  NAME = NAME . NAME ( )
Pred: NAME = NAME . NAME ( )

Tgt:  tagname = tagname . lower ( )
Pred: tagname = tagname . lower ( )
==================
NL:_assertRaisesRegex is a strnig _STR:0_ .
Tgt:  NAME = STRING
Pred: NAME = STRING

Tgt:  _assertRaisesRegex = <[> _STR:0_ <]>
Pred: _assertRaisesRegex = <[> _STR:0_ <]>
==================
NL:substitute changeset for get_git_changeset.cache [ get_git_changeset . cache ] .
Tgt:  NAME . NAME = NAME
Pred: NAME . NAME = NAME

Tgt:  get_git_changeset . cache = changeset
Pred: get_git_changeset . cache = changeset
==================
NL:if language is not contained in _translations ,
Tgt:  if NAME not in NAME :
Pred: if NAME not in NAME :

Tgt:  if language not in _translations :
Pred: if language not in _translations :
==================
NL:define the method __repr__ with an argument self .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def __repr__ ( self ) :
Pred: def __repr__ ( self ) :
==================
NL:return value under the DEFAULT_PALETTE key of the PALETTES dictionary .
Tgt:  return NAME [ NAME ]
Pred: return NAME [ NAME ]

Tgt:  return PALETTES [ DEFAULT_PALETTE ]
Pred: return PALETTES [ DEFAULT_PALETTE ]
==================
NL:assign it to value under the string _STR:0_ appended to __name__ key of the sys.modules [ sys . modules ] dictionary , and to value under the string _STR:1_ appended to __name__ key of the sys.modules [ sys . modules ] dictionary . derive class Module_six_moves_urllib from the types.ModuleType [ types . ModuleType ] base class .
Tgt:  class NAME ( NAME . NAME ) :
Pred: class NAME ( NAME . NAME ) :

Tgt:  class Module_six_moves_urllib ( types . ModuleType ) :
Pred: class Module_six_moves_urllib ( types . ModuleType ) :
==================
NL:try ,
Tgt:  try :
Pred: try :

Tgt:  try :
Pred: try :
==================
NL:changeset is None .
Tgt:  NAME = None
Pred: NAME = None

Tgt:  changeset = None
Pred: changeset = None
==================
NL:if value under the _STR:0_ key of the kwargs dictionary is equal to string _STR:1_ or strnig _STR:2_ ,
Tgt:  if NAME [ STRING ] in ( STRING , STRING ) :
Pred: if NAME [ STRING ] in ( STRING , STRING ) :

Tgt:  if kwargs [ <[> _STR:0_ <]> ] in ( <[> _STR:1_ <]> , <[> _STR:2_ <]> ) :
Pred: if kwargs [ <[> _STR:0_ <]> ] in ( <[> _STR:1_ <]> , <[> _STR:2_ <]> ) :
==================
NL:define the method utcoffset with 2 arguments : self and dt .
Tgt:  def NAME ( NAME , NAME ) :
Pred: def NAME ( NAME , NAME ) :

Tgt:  def utcoffset ( self , dt ) :
Pred: def utcoffset ( self , dt ) :
==================
NL:called with 2 arguments : singular and trimmed , write the result to out . if not ,
Tgt:  else :
Pred: else :

Tgt:  else :
Pred: else :
==================
NL:if timezone is an instance of tzinfo ,
Tgt:  if isinstance ( NAME , NAME ) :
Pred: if isinstance ( NAME , NAME ) :

Tgt:  if isinstance ( timezone , tzinfo ) :
Pred: if isinstance ( timezone , tzinfo ) :
==================
NL:and re.VERBOSE [ re . VERBOSE ] , substitute the result for smart_split_re . define the function smart_split with an argument text .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def smart_split ( text ) :
Pred: def smart_split ( text ) :
==================
NL:call the method value.replace [ value . replace ] with an arugment tzinfo set to None , return the result .
Tgt:  return NAME . NAME ( NAME = None )
Pred: return NAME . NAME ( NAME = None )

Tgt:  return value . replace ( tzinfo = None )
Pred: return value . replace ( tzinfo = None )
==================
NL:if inplural is true ,
Tgt:  if NAME :
Pred: if NAME :

Tgt:  if inplural :
Pred: if inplural :
==================
NL:substitute self.old_timezone [ self . old_timezone ] for _active.value [ _active . value ] .
Tgt:  NAME . NAME = NAME . NAME
Pred: NAME . NAME = NAME . NAME

Tgt:  _active . value = self . old_timezone
Pred: _active . value = self . old_timezone
==================
NL:_func_code is a string _STR:0_ .
Tgt:  NAME = STRING
Pred: NAME = STRING

Tgt:  _func_code = <[> _STR:0_ <]>
Pred: _func_code = <[> _STR:0_ <]>
==================
NL:define the function to_language with an argument locale .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def to_language ( locale ) :
Pred: def to_language ( locale ) :
==================
NL:_trans is an instance of Trans class .
Tgt:  NAME = NAME ( )
Pred: NAME = NAME ( )

Tgt:  _trans = Trans ( )
Pred: _trans = Trans ( )
==================
NL:yield nothing .
Tgt:  NAME
Pred: NAME

Tgt:  yield
Pred: yield
==================
NL:define the function parse_accept_lang_header with an argument lang_string .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def parse_accept_lang_header ( lang_string ) :
Pred: def parse_accept_lang_header ( lang_string ) :
==================
NL:increment pos by one , substitute the result for last .
Tgt:  NAME = NAME + NUMBER
Pred: NAME = NAME + NUMBER

Tgt:  last = pos + 1
Pred: last = pos + 1
==================
NL:define the function activate with an argument timezone .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def activate ( timezone ) :
Pred: def activate ( timezone ) :
==================
NL:from django.conf [ django . conf ] import settings into default name space .
Tgt:  from NAME . NAME import NAME
Pred: from NAME . NAME import NAME

Tgt:  from django . conf import settings
Pred: from django . conf import settings
==================
NL:return value .
Tgt:  return NAME
Pred: return NAME

Tgt:  return value
Pred: return value
==================
NL:if timezone has an attribute _STR:0_ ,
Tgt:  if hasattr ( NAME , STRING ) :
Pred: if hasattr ( NAME , STRING ) :

Tgt:  if hasattr ( timezone , <[> _STR:0_ <]> ) :
Pred: if hasattr ( timezone , <[> _STR:0_ <]> ) :
==================
NL:substitute SafeText for SafeUnicode .
Tgt:  NAME = NAME
Pred: NAME = NAME

Tgt:  SafeUnicode = SafeText
Pred: SafeUnicode = SafeText
==================
NL:import module copy .
Tgt:  import NAME
Pred: import NAME

Tgt:  import copy
Pred: import copy
==================
NL:call the function _trans.get_language_from_path [ _trans . get_language_from_path ] with an argument path , return the result .
Tgt:  return NAME . NAME ( NAME )
Pred: return NAME . NAME ( NAME )

Tgt:  return _trans . get_language_from_path ( path )
Pred: return _trans . get_language_from_path ( path )
==================
NL:define the function get_language_from_path with an argument request .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def get_language_from_path ( request ) :
Pred: def get_language_from_path ( request ) :
==================
NL:call the function re.compile [ re . compile ] with an argument string _STR:0_ , substitute the result for ustring_re .
Tgt:  NAME = re . compile ( STRING )
Pred: NAME = re . compile ( STRING )

Tgt:  ustring_re = re . compile ( <[> _STR:0_ <]> )
Pred: ustring_re = re . compile ( <[> _STR:0_ <]> )
==================
NL:call the method constant_re.findall [ constant_re . findall ] with an argument t.contents [ t . contents ] , for every fmatch in the result ,
Tgt:  for NAME in NAME . NAME ( NAME . NAME ) :
Pred: for NAME in NAME . NAME ( NAME . NAME ) :

Tgt:  for fmatch in constant_re . findall ( t . contents ) :
Pred: for fmatch in constant_re . findall ( t . contents ) :
==================
NL:raise an AttributeError with an argument attr .
Tgt:  raise NAME ( NAME )
Pred: raise NAME ( NAME )

Tgt:  raise AttributeError ( attr )
Pred: raise AttributeError ( attr )
==================
NL:if self.old_timezone [ self . old_timezone ] is None ,
Tgt:  if NAME . NAME is None :
Pred: if NAME . NAME is None :

Tgt:  if self . old_timezone is None :
Pred: if self . old_timezone is None :
==================
NL:return it . if PY3 is true ,
Tgt:  if NAME :
Pred: if NAME :

Tgt:  if PY3 :
Pred: if PY3 :
==================
NL:if offset is not None ,
Tgt:  if NAME is not None :
Pred: if NAME is not None :

Tgt:  if offset is not None :
Pred: if offset is not None :
==================
NL:stderr set to subprocess.PIPE [ subprocess . PIPE ] , shell set to boolean True , cwd set to repo_dir and universal_newlines set to boolean True , as arguments , substitute the result for git_log . evaluate the method git_log.communicate [ git_log . communicate ] , substitute first element of the result for timestamp .
Tgt:  NAME = NAME . NAME ( ) [ NUMBER ]
Pred: NAME = NAME . NAME ( ) [ NUMBER ]

Tgt:  timestamp = git_log . communicate ( ) [ 0 ]
Pred: timestamp = git_log . communicate ( ) [ 0 ]
==================
NL:increment self.active_writers [ self . active_writers ] by integer 1 ,
Tgt:  NAME . NAME += NUMBER
Pred: NAME . NAME += NUMBER

Tgt:  self . active_writers += 1
Pred: self . active_writers += 1
==================
NL:self.active_writers [ self . active_writers ] is an integer 0 .
Tgt:  NAME . NAME = NUMBER
Pred: NAME . NAME = NUMBER

Tgt:  self . active_writers = 0
Pred: self . active_writers = 0
==================
NL:call the method six.unichr [ six . unichr ] with an argument c , return the result .
Tgt:  return NAME . unichr ( NAME )
Pred: return NAME . NAME ( NAME )

Tgt:  return six . unichr ( c )
Pred: return six . unichr ( c )
==================
NL:if ImportError exception is caught ,
Tgt:  except NAME :
Pred: except NAME :

Tgt:  except ImportError :
Pred: except ImportError :
==================
NL:call the method value.replace [ value . replace ] with an argument tzinfo as timezone , return the result .
Tgt:  return NAME . NAME ( NAME = NAME )
Pred: return NAME . NAME ( NAME = NAME )

Tgt:  return value . replace ( tzinfo = timezone )
Pred: return value . replace ( tzinfo = timezone )
==================
NL:if not ,
Tgt:  else :
Pred: else :

Tgt:  else :
Pred: else :
==================
NL:substitute it for localedir . use_null_fallback is boolean True .
Tgt:  NAME = True
Pred: NAME = True

Tgt:  use_null_fallback = True
Pred: use_null_fallback = True
==================
NL:import module warnings .
Tgt:  import NAME
Pred: import NAME

Tgt:  import warnings
Pred: import warnings
==================
NL:return lang_code .
Tgt:  return NAME
Pred: return NAME

Tgt:  return lang_code
Pred: return lang_code
==================
NL:define the function get_unbound_function with an argument unbound .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def get_unbound_function ( unbound ) :
Pred: def get_unbound_function ( unbound ) :
==================
NL:call the method timezone.normalize [ timezone . normalize ] with an argument value , substitute the result for value .
Tgt:  NAME = NAME . NAME ( NAME )
Pred: NAME = NAME . NAME ( NAME )

Tgt:  value = timezone . normalize ( value )
Pred: value = timezone . normalize ( value )
==================
NL:formated with t.contents [ t . contents ] , filemsg and t.lineno [ t . lineno ] . otherwise if t.token_type [ t . token_type ] equals TOKEN_VAR ,
Tgt:  elif NAME . NAME == NAME :
Pred: elif NAME . NAME == NAME :

Tgt:  elif t . token_type == TOKEN_VAR :
Pred: elif t . token_type == TOKEN_VAR :
==================
NL:define the function get_supported_language_variant with 2 arguments : lang_code and strict set to boolean False .
Tgt:  def NAME ( NAME , NAME = False ) :
Pred: def NAME ( NAME , NAME = False ) :

Tgt:  def get_supported_language_variant ( lang_code , strict = False ) :
Pred: def get_supported_language_variant ( lang_code , strict = False ) :
==================
NL:if comment_lineno_cache equals cur_lineno .
Tgt:  if NAME == NAME :
Pred: if NAME == NAME :

Tgt:  if comment_lineno_cache == cur_lineno :
Pred: if comment_lineno_cache == cur_lineno :
==================
NL:if check_path is true ,
Tgt:  if NAME :
Pred: if NAME :

Tgt:  if check_path :
Pred: if check_path :
==================
NL:call the method self.reader_enters [ self . reader_enters ] .
Tgt:  NAME . NAME ( )
Pred: NAME . NAME ( )

Tgt:  self . reader_enters ( )
Pred: self . reader_enters ( )
==================
NL:define the method __bool__ with an argument self .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def __bool__ ( self ) :
Pred: def __bool__ ( self ) :
==================
NL:plural is an empty list .
Tgt:  NAME = [ ]
Pred: NAME = [ ]

Tgt:  plural = [ ]
Pred: plural = [ ]
==================
NL:derive the class Trans from the object base class .
Tgt:  class NAME ( object ) :
Pred: class NAME ( object ) :

Tgt:  class Trans ( object ) :
Pred: class Trans ( object ) :
==================
NL:define the method write with 2 arguments : self and val .
Tgt:  def NAME ( NAME , NAME ) :
Pred: def NAME ( NAME , NAME ) :

Tgt:  def write ( self , val ) :
Pred: def write ( self , val ) :
==================
NL:call the method self.merge [ self . merge ] with an argument translation .
Tgt:  NAME . NAME ( NAME )
Pred: NAME . NAME ( NAME )

Tgt:  self . merge ( translation )
Pred: self . merge ( translation )
==================
NL:if param is true ,
Tgt:  if NAME :
Pred: if NAME :

Tgt:  if param :
Pred: if param :
==================
NL:_func_code is a string _STR:0_ .
Tgt:  NAME = STRING
Pred: NAME = STRING

Tgt:  _func_code = <[> _STR:0_ <]>
Pred: _func_code = <[> _STR:0_ <]>
==================
NL:define the function get_version with version set to None as argument .
Tgt:  def NAME ( NAME = None ) :
Pred: def NAME ( NAME = None ) :

Tgt:  def get_version ( version = None ) :
Pred: def get_version ( version = None ) :
==================
NL:zip elements of inner_result and inner_args into a list of tuples , for every i_item and i_args in the result ,
Tgt:  for NAME , NAME in zip ( NAME , NAME ) :
Pred: for NAME , NAME in zip ( NAME , NAME ) :

Tgt:  for i_item , i_args in zip ( inner_result , inner_args ) :
Pred: for i_item , i_args in zip ( inner_result , inner_args ) :
==================
NL:define the method writer_enters with an argument self .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def writer_enters ( self ) :
Pred: def writer_enters ( self ) :
==================
NL:call the method out.getvalue [ out . getvalue ] , return the result .
Tgt:  return NAME . NAME ( )
Pred: return NAME . NAME ( )

Tgt:  return out . getvalue ( )
Pred: return out . getvalue ( )
==================
NL:substitute ngettext for ngettext_lazy .
Tgt:  NAME = NAME
Pred: NAME = NAME

Tgt:  ngettext_lazy = ngettext
Pred: ngettext_lazy = ngettext
==================
NL:return version
Tgt:  return NAME
Pred: return NAME

Tgt:  return version
Pred: return version
==================
NL:elt is an list with an element elt .
Tgt:  NAME = [ NAME ]
Pred: NAME = [ NAME ]

Tgt:  elt = [ elt ]
Pred: elt = [ elt ]
==================
NL:substitute _urllib_response_moved_attributes for Module_six_moves_urllib_response._moved_attributes [ Module_six_moves_urllib_response . _moved_attributes ] .
Tgt:  NAME . NAME = NAME
Pred: NAME . NAME = NAME

Tgt:  Module_six_moves_urllib_response . _moved_attributes = _urllib_response_moved_attributes
Pred: Module_six_moves_urllib_response . _moved_attributes = _urllib_response_moved_attributes
==================
NL:from django.utils.safestring [ django . utils . safestring ] import mark_safe and SafeData into default name space .
Tgt:  from NAME . NAME . NAME import NAME , NAME
Pred: from NAME . NAME . NAME import NAME , NAME

Tgt:  from django . utils . safestring import mark_safe , SafeData
Pred: from django . utils . safestring import mark_safe , SafeData
==================
NL:if timezone has an attribute _STR:0_ ,
Tgt:  if hasattr ( NAME , STRING ) :
Pred: if hasattr ( NAME , STRING ) :

Tgt:  if hasattr ( timezone , <[> _STR:0_ <]> ) :
Pred: if hasattr ( timezone , <[> _STR:0_ <]> ) :
==================
NL:define the method __str__ with an argument self .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def __str__ ( self ) :
Pred: def __str__ ( self ) :
==================
NL:define the function u with an argument s .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def u ( s ) :
Pred: def u ( s ) :
==================
NL:use_null_fallback is boolean False .
Tgt:  NAME = False
Pred: NAME = False

Tgt:  use_null_fallback = False
Pred: use_null_fallback = False
==================
NL:return None .
Tgt:  return None
Pred: return None

Tgt:  return None
Pred: return None
==================
NL:define the function get_language .
Tgt:  def NAME ( ) :
Pred: def NAME ( ) :

Tgt:  def get_language ( ) :
Pred: def get_language ( ) :
==================
NL:if name is not None ,
Tgt:  if NAME is not None :
Pred: if NAME is not None :

Tgt:  if name is not None :
Pred: if name is not None :
==================
NL:define the function indexbytes with 2 arguments buf and i .
Tgt:  def NAME ( NAME , NAME ) :
Pred: def NAME ( NAME , NAME ) :

Tgt:  def indexbytes ( buf , i ) :
Pred: def indexbytes ( buf , i ) :
==================
NL:__author__ is a string _STR:0_ .
Tgt:  NAME = STRING
Pred: NAME = STRING

Tgt:  __author__ = <[> _STR:0_ <]>
Pred: __author__ = <[> _STR:0_ <]>
==================
NL:import module re .
Tgt:  import re
Pred: import re

Tgt:  import re
Pred: import re
==================
NL:use global variable _supported .
Tgt:  global NAME
Pred: global NAME

Tgt:  global _supported
Pred: global _supported
==================
NL:substitute self.waiting_readers [ self . waiting_readers ] for t .
Tgt:  NAME = NAME . NAME
Pred: NAME = NAME . NAME

Tgt:  t = self . waiting_readers
Pred: t = self . waiting_readers
==================
NL:call the method time.mktime [ time . mktime ] with an argument tt , substitute the result for stamp .
Tgt:  NAME = NAME . NAME ( NAME )
Pred: NAME = NAME . NAME ( NAME )

Tgt:  stamp = time . mktime ( tt )
Pred: stamp = time . mktime ( tt )
==================
NL:_meth_func is a string _STR:0_ .
Tgt:  NAME = STRING
Pred: NAME = STRING

Tgt:  _meth_func = <[> _STR:0_ <]>
Pred: _meth_func = <[> _STR:0_ <]>
==================
NL:from __future__ import unicode_literals into default name space .
Tgt:  from NAME import NAME
Pred: from NAME import NAME

Tgt:  from __future__ import unicode_literals
Pred: from __future__ import unicode_literals
==================
NL:call the method re.compile [ re . compile ] with an argument raw string _STR:0_ , substitute the result for _entity_re .
Tgt:  NAME = re . compile ( STRING )
Pred: NAME = re . compile ( STRING )

Tgt:  _entity_re = re . compile ( <[> _STR:0_ <]> )
Pred: _entity_re = re . compile ( <[> _STR:0_ <]> )
==================
NL:substitute old_attr for self.attr [ self . attr ] .
Tgt:  NAME . NAME = NAME
Pred: NAME . NAME = NAME

Tgt:  self . attr = old_attr
Pred: self . attr = old_attr
==================
NL:_iteritems is a string _STR:0_ .
Tgt:  NAME = STRING
Pred: NAME = STRING

Tgt:  _iteritems = <[> _STR:0_ <]>
Pred: _iteritems = <[> _STR:0_ <]>
==================
NL:raise an ValueError exception with an argument string _STR:0_ , where ' % s ' is replaced with value .
Tgt:  raise NAME ( STRING % NAME )
Pred: raise NAME ( STRING % NAME )

Tgt:  raise ValueError ( <[> _STR:0_ <]> % value )
Pred: raise ValueError ( <[> _STR:0_ <]> % value )
==================
NL:finally perform ,
Tgt:  finally :
Pred: finally :

Tgt:  finally :
Pred: finally :
==================
NL:define the method __repr__ with an argument self .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def __repr__ ( self ) :
Pred: def __repr__ ( self ) :
==================
NL:return supported_code .
Tgt:  return NAME
Pred: return NAME

Tgt:  return supported_code
Pred: return supported_code
==================
NL:try ,
Tgt:  try :
Pred: try :

Tgt:  try :
Pred: try :
==================
NL:if PY3 is true ,
Tgt:  if NAME :
Pred: if NAME :

Tgt:  if PY3 :
Pred: if PY3 :
==================
NL:return out .
Tgt:  return NAME
Pred: return NAME

Tgt:  return out
Pred: return out
==================
NL:try ,
Tgt:  try :
Pred: try :

Tgt:  try :
Pred: try :
==================
NL:import module warnings .
Tgt:  import NAME
Pred: import NAME

Tgt:  import warnings
Pred: import warnings
==================
NL:if not ,
Tgt:  else :
Pred: else :

Tgt:  else :
Pred: else :
==================
NL:if not ,
Tgt:  else :
Pred: else :

Tgt:  else :
Pred: else :
==================
NL:return result .
Tgt:  return NAME
Pred: return NAME

Tgt:  return result
Pred: return result
==================
NL:if not ,
Tgt:  else :
Pred: else :

Tgt:  else :
Pred: else :
==================
NL:call the function timedelta with an argument integer 0 , return the result .
Tgt:  return NAME ( NUMBER )
Pred: return NAME ( NUMBER )

Tgt:  return timedelta ( 0 )
Pred: return timedelta ( 0 )
==================
NL:call the method self.can_write.release [ self . can_write . release ] .
Tgt:  NAME . NAME . NAME ( )
Pred: NAME . NAME . NAME ( )

Tgt:  self . can_write . release ( )
Pred: self . can_write . release ( )
==================
NL:from datetime import timedelta and tzinfo into default name space .
Tgt:  from NAME import NAME , NAME
Pred: from NAME import NAME , NAME

Tgt:  from datetime import timedelta , tzinfo
Pred: from datetime import timedelta , tzinfo
==================
NL:substitute second element of elt for param .
Tgt:  NAME = NAME [ NUMBER ]
Pred: NAME = NAME [ NUMBER ]

Tgt:  param = elt [ 1 ]
Pred: param = elt [ 1 ]
==================
NL:define the method __init__ with 2 arguments : self and offset .
Tgt:  def NAME ( NAME , NAME ) :
Pred: def NAME ( NAME , NAME ) :

Tgt:  def __init__ ( self , offset ) :
Pred: def __init__ ( self , offset ) :
==================
NL:substitute the result for proxy . if not ,
Tgt:  else :
Pred: else :

Tgt:  else :
Pred: else :
==================
NL:if git_changeset is true ,
Tgt:  if NAME :
Pred: if NAME :

Tgt:  if git_changeset :
Pred: if git_changeset :
==================
NL:define the method _isdst with 2 arguments self and dt .
Tgt:  def NAME ( NAME , NAME ) :
Pred: def NAME ( NAME , NAME ) :

Tgt:  def _isdst ( self , dt ) :
Pred: def _isdst ( self , dt ) :
==================
NL:define the function localtime with 2 arguments : value and timezone set to None .
Tgt:  def NAME ( NAME , NAME = None ) :
Pred: def NAME ( NAME , NAME = None ) :

Tgt:  def localtime ( value , timezone = None ) :
Pred: def localtime ( value , timezone = None ) :
==================
NL:substitute _urllib_request_moved_attributes for Module_six_moves_urllib_request._moved_attributes [ Module_six_moves_urllib_request . _moved_attributes ] .
Tgt:  NAME . NAME = NAME
Pred: NAME . NAME = NAME

Tgt:  Module_six_moves_urllib_request . _moved_attributes = _urllib_request_moved_attributes
Pred: Module_six_moves_urllib_request . _moved_attributes = _urllib_request_moved_attributes
==================
NL:if _default is None
Tgt:  if NAME is None :
Pred: if NAME is None :

Tgt:  if _default is None :
Pred: if _default is None :
==================
NL:call the function six.iteritems [ six . iteritems ] with an argument kwargs , for every k and v in the result ,
Tgt:  for NAME , NAME in NAME . NAME ( NAME ) :
Pred: for NAME , NAME in NAME . NAME ( NAME ) :

Tgt:  for k , v in six . iteritems ( kwargs ) :
Pred: for k , v in six . iteritems ( kwargs ) :
==================
NL:if AppRegistryNotReady exception is caught ,
Tgt:  except NAME :
Pred: except NAME :

Tgt:  except AppRegistryNotReady :
Pred: except AppRegistryNotReady :
==================
NL:convert locale to lowercase and return it .
Tgt:  return NAME . NAME ( )
Pred: return NAME . NAME ( )

Tgt:  return locale . lower ( )
Pred: return locale . lower ( )
==================
NL:call the method self.can_read.release [ self . can_read . release ] .
Tgt:  NAME . NAME . NAME ( )
Pred: NAME . NAME . NAME ( )

Tgt:  self . can_read . release ( )
Pred: self . can_read . release ( )
==================
NL:define the method _add_local_translations with an argument self .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def _add_local_translations ( self ) :
Pred: def _add_local_translations ( self ) :
==================
NL:import threading .
Tgt:  import NAME
Pred: import NAME

Tgt:  import threading
Pred: import threading
==================
NL:define the function deactivate_all .
Tgt:  def NAME ( ) :
Pred: def NAME ( ) :

Tgt:  def deactivate_all ( ) :
Pred: def deactivate_all ( ) :
==================
NL:define the method close with an argument self .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def close ( self ) :
Pred: def close ( self ) :
==================
NL:call the function _trans.deactivate [ _trans . deactivate ] , return the result .
Tgt:  return NAME . NAME ( )
Pred: return NAME . NAME ( )

Tgt:  return _trans . deactivate ( )
Pred: return _trans . deactivate ( )
==================
NL:return translation .
Tgt:  return NAME
Pred: return NAME

Tgt:  return translation
Pred: return translation
==================
NL:use global variable _default .
Tgt:  global NAME
Pred: global NAME

Tgt:  global _default
Pred: global _default
==================
NL:a dictionary with 18 pairs of dictionary value and string keys for DARK_PALETTE , and a dictionary with 18 pairs of dictionary value and string keys for LIGHT_PALETTE . substitute DARK_PALETTE for DEFAULT_PALETTE .
Tgt:  NAME = NAME
Pred: NAME = NAME

Tgt:  DEFAULT_PALETTE = DARK_PALETTE
Pred: DEFAULT_PALETTE = DARK_PALETTE
==================
NL:call the function __import__ with an argument name .
Tgt:  __import__ ( NAME )
Pred: NAME ( NAME )

Tgt:  __import__ ( name )
Pred: __import__ ( name )
==================
NL:delete entry under the name key of the moves.__dict__ [ moves . __dict__ ] dictionary .
Tgt:  del NAME . NAME [ NAME ]
Pred: del NAME . NAME [ NAME ]

Tgt:  del moves . __dict__ [ name ]
Pred: del moves . __dict__ [ name ]
==================
NL:call the function mark_safe with an argument result , return it .
Tgt:  return NAME ( NAME )
Pred: return NAME ( NAME )

Tgt:  return mark_safe ( result )
Pred: return mark_safe ( result )
==================
NL:join tokens elements into a string , substitute it for message .
Tgt:  NAME = STRING . NAME ( NAME )
Pred: NAME = STRING . NAME ( NAME )

Tgt:  message = <[>  <]> . join ( tokens )
Pred: message = <[>  <]> . join ( tokens )
==================
NL:and to value under the _STR:0_ appended to __name__ key of the sys.modules [ sys . modules ] dictionary . derive class Module_six_moves_urllib_parse from the _LazyModule base class .
Tgt:  class NAME ( NAME ) :
Pred: class NAME ( NAME ) :

Tgt:  class Module_six_moves_urllib_parse ( _LazyModule ) :
Pred: class Module_six_moves_urllib_parse ( _LazyModule ) :
==================
NL:define the function check_for_language with an argument lang_code .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def check_for_language ( lang_code ) :
Pred: def check_for_language ( lang_code ) :
==================
NL:if attrs is None ,
Tgt:  if NAME is None :
Pred: if NAME is None :

Tgt:  if attrs is None :
Pred: if attrs is None :
==================
NL:call the method one_percent_re.sub [ one_percent_re . sub ] with 2 arguments : string _STR:0_ and t.contents [ t . contents ] , substitute the result for contents .
Tgt:  NAME = NAME . NAME ( STRING , NAME . NAME )
Pred: NAME = NAME . NAME ( STRING , NAME . NAME )

Tgt:  contents = one_percent_re . sub ( <[> _STR:0_ <]> , t . contents )
Pred: contents = one_percent_re . sub ( <[> _STR:0_ <]> , t . contents )
==================
NL:substitute old_mod for self.mod [ self . mod ] .
Tgt:  NAME . NAME = NAME
Pred: NAME . NAME = NAME

Tgt:  self . mod = old_mod
Pred: self . mod = old_mod
==================
NL:call the method self.can_write.release [ self . can_write . release ] .
Tgt:  NAME . NAME . NAME ( )
Pred: NAME . NAME . NAME ( )

Tgt:  self . can_write . release ( )
Pred: self . can_write . release ( )
==================
NL:return nothing .
Tgt:  NAME
Pred: NAME

Tgt:  return
Pred: return
==================
NL:assign the result to the value under the string _STR:0_ appended to __name__ key of the sys.modules [ sys . modules ] dictionary , and to the value under the string _STR:1_ appended to __name__ key of the sys.modules [ sys . modules ] dictionary . derive class Module_six_moves_urllib_error from the _LazyModule base class .
Tgt:  class NAME ( NAME ) :
Pred: class NAME ( NAME ) :

Tgt:  class Module_six_moves_urllib_error ( _LazyModule ) :
Pred: class Module_six_moves_urllib_error ( _LazyModule ) :
==================
NL:call the function translation with an argument settings.LANGUAGE_CODE [ settings . LANGUAGE_CODE ] , substitute the result for _default .
Tgt:  NAME = NAME ( NAME . NAME )
Pred: NAME = NAME ( NAME . NAME )

Tgt:  _default = translation ( settings . LANGUAGE_CODE )
Pred: _default = translation ( settings . LANGUAGE_CODE )
==================
NL:get the type of the self object , on the result call the __bool__ method with an argument self , return the result .
Tgt:  return type ( NAME ) . NAME ( NAME )
Pred: return type ( NAME ) . NAME ( NAME )

Tgt:  return type ( self ) . __bool__ ( self )
Pred: return type ( self ) . __bool__ ( self )
==================
NL:if CONTEXT_SEPARATOR is contained in result ,
Tgt:  if NAME in NAME :
Pred: if NAME in NAME :

Tgt:  if CONTEXT_SEPARATOR in result :
Pred: if CONTEXT_SEPARATOR in result :
==================
NL:from django.utils.translation [ django . utils . translation ] import trans_null as trans .
Tgt:  from NAME . NAME . NAME import NAME as NAME
Pred: from NAME . NAME . NAME import NAME as NAME

Tgt:  from django . utils . translation import trans_null as trans
Pred: from django . utils . translation import trans_null as trans
==================
NL:for every attr in _urllib_request_moved_attributes ,
Tgt:  for NAME in NAME :
Pred: for NAME in NAME :

Tgt:  for attr in _urllib_request_moved_attributes :
Pred: for attr in _urllib_request_moved_attributes :
==================
NL:strip message_context of _STR:0_ characters from both ends , substitute the result for message_context .
Tgt:  NAME = NAME . NAME ( STRING )
Pred: NAME = NAME . NAME ( STRING )

Tgt:  message_context = message_context . strip ( <[> _STR:0_ <]> )
Pred: message_context = message_context . strip ( <[> _STR:0_ <]> )
==================
NL:call the method _entity_re.sub [ _entity_re . sub ] with 2 arguments : _replace_entity and text , return the result .
Tgt:  return NAME . NAME ( NAME , NAME )
Pred: return NAME . NAME ( NAME , NAME )

Tgt:  return _entity_re . sub ( _replace_entity , text )
Pred: return _entity_re . sub ( _replace_entity , text )
==================
NL:sum sign and hhmm , substitute the result for name .
Tgt:  NAME = NAME + NAME
Pred: NAME = NAME + NAME

Tgt:  name = sign + hhmm
Pred: name = sign + hhmm
==================
NL:if quote_double_quotes is true ,
Tgt:  if NAME :
Pred: if NAME :

Tgt:  if quote_double_quotes :
Pred: if quote_double_quotes :
==================
NL:define the method __len__ with an argument self .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def __len__ ( self ) :
Pred: def __len__ ( self ) :
==================
NL:define the function u with an argument s .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def u ( s ) :
Pred: def u ( s ) :
==================
NL:substitute io.BytesIO [ io . BytesIO ] for BytesIO .
Tgt:  NAME = NAME . NAME
Pred: NAME = NAME . NAME

Tgt:  BytesIO = io . BytesIO
Pred: BytesIO = io . BytesIO
==================
NL:otherwise if self.waiting_readers [ self . waiting_readers ] is not equal to integer 0 ,
Tgt:  elif NAME . NAME != NUMBER :
Pred: elif NAME . NAME != NUMBER :

Tgt:  elif self . waiting_readers != 0 :
Pred: elif self . waiting_readers != 0 :
==================
NL:call the method timezone.tzname [ timezone . tzname ] with an argument None , return the result .
Tgt:  return NAME . NAME ( None )
Pred: return NAME . NAME ( None )

Tgt:  return timezone . tzname ( None )
Pred: return timezone . tzname ( None )
==================
NL:define the function npgettext with 4 arguments : context , singular , plural and number .
Tgt:  def NAME ( NAME , NAME , NAME , NAME ) :
Pred: def NAME ( NAME , NAME , NAME , NAME ) :

Tgt:  def npgettext ( context , singular , plural , number ) :
Pred: def npgettext ( context , singular , plural , number ) :
==================
NL:call the function timedelta with an argument seconds set to negative _time.timezone [ _time . timezone ] , substitute the result for self.STDOFFSET [ self . STDOFFSET ] .
Tgt:  NAME . NAME = NAME ( NAME = - NAME . NAME )
Pred: NAME . NAME = NAME ( NAME = - NAME . NAME )

Tgt:  self . STDOFFSET = timedelta ( seconds = - _time . timezone )
Pred: self . STDOFFSET = timedelta ( seconds = - _time . timezone )
==================
NL:call the function write with an argument end .
Tgt:  NAME ( NAME )
Pred: NAME ( NAME )

Tgt:  write ( end )
Pred: write ( end )
==================
NL:from django.utils.encoding [ django . utils . encoding ] import force_text into default name space .
Tgt:  from NAME . NAME . NAME import NAME
Pred: from NAME . NAME . NAME import NAME

Tgt:  from django . utils . encoding import force_text
Pred: from django . utils . encoding import force_text
==================
NL:if not ,
Tgt:  else :
Pred: else :

Tgt:  else :
Pred: else :
==================
NL:define the method __contains__ with 2 arguments : self and other .
Tgt:  def NAME ( NAME , NAME ) :
Pred: def NAME ( NAME , NAME ) :

Tgt:  def __contains__ ( self , other ) :
Pred: def __contains__ ( self , other ) :
==================
NL:for every tag in open_tags ,
Tgt:  for NAME in NAME :
Pred: for NAME in NAME :

Tgt:  for tag in open_tags :
Pred: for tag in open_tags :
==================
NL:if old_attr is None ,
Tgt:  if NAME is None :
Pred: if NAME is None :

Tgt:  if old_attr is None :
Pred: if old_attr is None :
==================
NL:call the method self._prepare_data [ self . _prepare_data ] with an argument data , substitute the result for data .
Tgt:  NAME = NAME . NAME ( NAME )
Pred: NAME = NAME . NAME ( NAME )

Tgt:  data = self . _prepare_data ( data )
Pred: data = self . _prepare_data ( data )
==================
NL:substitute the result for block_re . call the function re.compile [ re . compile ] with an argument raw string _STR:0_ , substitute the result for endblock_re .
Tgt:  NAME = re . compile ( STRING )
Pred: NAME = re . compile ( STRING )

Tgt:  endblock_re = re . compile ( <[> _STR:0_ <]> )
Pred: endblock_re = re . compile ( <[> _STR:0_ <]> )
==================
NL:call the method types.MethodType [ types . MethodType ] with 3 arguments : func , obj and obj.__class__ [ obj . __class__ ] , return the result .
Tgt:  return NAME . NAME ( NAME , NAME , NAME . NAME )
Pred: return NAME . NAME ( NAME , NAME , NAME . NAME )

Tgt:  return types . MethodType ( func , obj , obj . __class__ )
Pred: return types . MethodType ( func , obj , obj . __class__ )
==================
NL:if print_ is None ,
Tgt:  if NAME is None :
Pred: if NAME is None :

Tgt:  if print_ is None :
Pred: if print_ is None :
==================
NL:strip message_context of _STR:0_ characters from both ends , substitute the result for message_context .
Tgt:  NAME = NAME . NAME ( STRING )
Pred: NAME = NAME . NAME ( STRING )

Tgt:  message_context = message_context . strip ( <[> _STR:0_ <]> )
Pred: message_context = message_context . strip ( <[> _STR:0_ <]> )
==================
NL:substitute new for self.mod [ self . mod ] .
Tgt:  NAME . NAME = NAME
Pred: NAME . NAME = NAME

Tgt:  self . mod = new
Pred: self . mod = new
==================
NL:do nothing .
Tgt:  NAME
Pred: NAME

Tgt:  pass
Pred: pass
==================
NL:increment self.active_readers [ self . active_readers ] by 1 .
Tgt:  NAME . NAME += NUMBER
Pred: NAME . NAME += NUMBER

Tgt:  self . active_readers += 1
Pred: self . active_readers += 1
==================
NL:if first element of message_context equals to character _STR:0_ ,
Tgt:  if NAME [ NUMBER ] == STRING :
Pred: if NAME [ NUMBER ] == STRING :

Tgt:  if message_context [ 0 ] == <[> _STR:0_ <]> :
Pred: if message_context [ 0 ] == <[> _STR:0_ <]> :
==================
NL:from django.utils.safestring [ django . utils . safestring ] import mark_safe and SafeData into default name space .
Tgt:  from NAME . NAME . NAME import NAME , NAME
Pred: from NAME . NAME . NAME import NAME , NAME

Tgt:  from django . utils . safestring import mark_safe , SafeData
Pred: from django . utils . safestring import mark_safe , SafeData
==================
NL:call the function allow_lazy with an argument chars , substitute the result for chars .
Tgt:  NAME = NAME ( NAME )
Pred: NAME = NAME ( NAME )

Tgt:  chars = allow_lazy ( chars )
Pred: chars = allow_lazy ( chars )
==================
NL:otherwise if pluralmatch is true ,
Tgt:  elif NAME :
Pred: elif NAME :

Tgt:  elif pluralmatch :
Pred: elif pluralmatch :
==================
NL:from unittest import import everything .
Tgt:  from NAME import *
Pred: from NAME import *

Tgt:  from unittest import *
Pred: from unittest import *
==================
NL:while t is greater than integer 0 ,
Tgt:  while NAME > NUMBER :
Pred: while NAME > NUMBER :

Tgt:  while t > 0 :
Pred: while t > 0 :
==================
NL:call the method self._add_fallback [ self . _add_fallback ] .
Tgt:  NAME . NAME ( )
Pred: NAME . NAME ( )

Tgt:  self . _add_fallback ( )
Pred: self . _add_fallback ( )
==================
NL:return attrs .
Tgt:  return NAME
Pred: return NAME

Tgt:  return attrs
Pred: return attrs
==================
NL:define the function deactivate .
Tgt:  def NAME ( ) :
Pred: def NAME ( ) :

Tgt:  def deactivate ( ) :
Pred: def deactivate ( ) :
==================
NL:if six.PY3 [ six . PY3 ] is true ,
Tgt:  if NAME . NAME :
Pred: if NAME . NAME :

Tgt:  if six . PY3 :
Pred: if six . PY3 :
==================
NL:import StringIO .
Tgt:  import NAME
Pred: import NAME

Tgt:  import StringIO
Pred: import StringIO
==================
NL:define the method read with an argument self .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def read ( self ) :
Pred: def read ( self ) :
==================
NL:substitute negated for self.negated [ self . negated ] .
Tgt:  NAME . NAME = NAME
Pred: NAME . NAME = NAME

Tgt:  self . negated = negated
Pred: self . negated = negated
==================
NL:called with 2 arguments : singular and trimmed and result of the function join_tokens called with 2 arguments : plural and trimmed , write the result to out . if not ,
Tgt:  else :
Pred: else :

Tgt:  else :
Pred: else :
==================
NL:define the method _proxy_method with 3 arguments self , unpacked list args and unpacked dictionary kwargs .
Tgt:  def NAME ( NAME , * NAME , ** NAME ) :
Pred: def NAME ( NAME , * NAME , ** NAME ) :

Tgt:  def _proxy_method ( self , * args , ** kwargs ) :
Pred: def _proxy_method ( self , * args , ** kwargs ) :
==================
NL:call the method regex_match.group [ regex_match . group ] with an argument integer 1 , substitute the result for lang_code .
Tgt:  NAME = NAME . NAME ( NUMBER )
Pred: NAME = NAME . NAME ( NUMBER )

Tgt:  lang_code = regex_match . group ( 1 )
Pred: lang_code = regex_match . group ( 1 )
==================
NL:_iteritems is a string _STR:0_ .
Tgt:  NAME = STRING
Pred: NAME = STRING

Tgt:  _iteritems = <[> _STR:0_ <]>
Pred: _iteritems = <[> _STR:0_ <]>
==================
NL:otherwise if timezone is an instance of six.string_types [ six . string_types ] and pytz is not None ,
Tgt:  elif isinstance ( NAME , NAME . NAME ) and NAME is not None :
Pred: elif isinstance ( NAME , NAME . NAME ) and NAME is not None :

Tgt:  elif isinstance ( timezone , six . string_types ) and pytz is not None :
Pred: elif isinstance ( timezone , six . string_types ) and pytz is not None :
==================
NL:if ImportError exception is caught ,
Tgt:  except NAME :
Pred: except NAME :

Tgt:  except ImportError :
Pred: except ImportError :
==================
NL:return it . define the function iterlists with 2 arguments : d and unpacked dictionary kw .
Tgt:  def NAME ( NAME , ** NAME ) :
Pred: def NAME ( NAME , ** NAME ) :

Tgt:  def iterlists ( d , ** kw ) :
Pred: def iterlists ( d , ** kw ) :
==================
NL:do nothing .
Tgt:  NAME
Pred: NAME

Tgt:  pass
Pred: pass
==================
NL:call the method self.can_write.acquire [ self . can_write . acquire ] .
Tgt:  NAME . NAME . NAME ( )
Pred: NAME . NAME . NAME ( )

Tgt:  self . can_write . acquire ( )
Pred: self . can_write . acquire ( )
==================
NL:return ZERO .
Tgt:  return NAME
Pred: return NAME

Tgt:  return ZERO
Pred: return ZERO
==================
NL:from __future__ import unicode_literals into default name space .
Tgt:  from NAME import NAME
Pred: from NAME import NAME

Tgt:  from __future__ import unicode_literals
Pred: from __future__ import unicode_literals
==================
NL:call the function endblock_re.match [ endblock_re . match ] with an argument t.contents [ t . contents ] , substitute the result for endbmatch .
Tgt:  NAME = NAME . NAME ( NAME . NAME )
Pred: NAME = NAME . NAME ( NAME . NAME )

Tgt:  endbmatch = endblock_re . match ( t . contents )
Pred: endbmatch = endblock_re . match ( t . contents )
==================
NL:define the function is_aware with an argument value .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def is_aware ( value ) :
Pred: def is_aware ( value ) :
==================
NL:substitute new_attr for self.attr [ self . attr ] .
Tgt:  NAME . NAME = NAME
Pred: NAME . NAME = NAME

Tgt:  self . attr = new_attr
Pred: self . attr = new_attr
==================
NL:want_unicode is boolean False .
Tgt:  NAME = False
Pred: NAME = False

Tgt:  want_unicode = False
Pred: want_unicode = False
==================
NL:integer 0 and integer 0. try ,
Tgt:  try :
Pred: try :

Tgt:  try :
Pred: try :
==================
NL:and trimmed , write the result to out . for every part in singular ,
Tgt:  for NAME in NAME :
Pred: for NAME in NAME :

Tgt:  for part in singular :
Pred: for part in singular :
==================
NL:for every x in sequence of integers from 0 to 7 . RESET is a string _STR:0_ .
Tgt:  NAME = STRING
Pred: NAME = STRING

Tgt:  RESET = <[> _STR:0_ <]>
Pred: RESET = <[> _STR:0_ <]>
==================
NL:if endbmatch is true ,
Tgt:  if NAME :
Pred: if NAME :

Tgt:  if endbmatch :
Pred: if endbmatch :
==================
NL:call the function type with an argument self , on the result call the method __next__ with an argument self , return the result .
Tgt:  return type ( NAME ) . NAME ( NAME )
Pred: return type ( NAME ) . NAME ( NAME )

Tgt:  return type ( self ) . __next__ ( self )
Pred: return type ( self ) . __next__ ( self )
==================
NL:define the function add_metaclass with an argument metaclass .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def add_metaclass ( metaclass ) :
Pred: def add_metaclass ( metaclass ) :
==================
NL:from django.conf.locale [ django . conf . locale ] import LANG_INFO .
Tgt:  from NAME . NAME . NAME import NAME
Pred: from NAME . NAME . NAME import NAME

Tgt:  from django . conf . locale import LANG_INFO
Pred: from django . conf . locale import LANG_INFO
==================
NL:raise an exception value .
Tgt:  raise NAME
Pred: raise NAME

Tgt:  raise value
Pred: raise value
==================
NL:define the function get_default_timezone_name .
Tgt:  def NAME ( ) :
Pred: def NAME ( ) :

Tgt:  def get_default_timezone_name ( ) :
Pred: def get_default_timezone_name ( ) :
==================
NL:extend list inner_result with res .
Tgt:  NAME . NAME ( NAME )
Pred: NAME . NAME ( NAME )

Tgt:  inner_result . extend ( res )
Pred: inner_result . extend ( res )
==================
NL:define the method language with an argument self .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def language ( self ) :
Pred: def language ( self ) :
==================
NL:if priority is false ,
Tgt:  if not NAME :
Pred: if not NAME :

Tgt:  if not priority :
Pred: if not priority :
==================
NL:define the function templatize with 2 arguments : src and origin set to None .
Tgt:  def NAME ( NAME , NAME = None ) :
Pred: def NAME ( NAME , NAME = None ) :

Tgt:  def templatize ( src , origin = None ) :
Pred: def templatize ( src , origin = None ) :
==================
NL:substitute timezone for _active.value [ _active . value ] .
Tgt:  NAME . NAME = NAME
Pred: NAME . NAME = NAME

Tgt:  _active . value = timezone
Pred: _active . value = timezone
==================
NL:get _assertCountEqual attribute of the self object , call the result with 2 arguments : unpacked list args ,
Tgt:  return getattr ( NAME , NAME ) ( * NAME , ** NAME )
Pred: return getattr ( NAME , NAME ) ( * NAME , ** NAME )

Tgt:  return getattr ( self , _assertCountEqual ) ( * args , ** kwargs )
Pred: return getattr ( self , _assertCountEqual ) ( * args , ** kwargs )
==================
NL:if o is contained in opt_dict ,
Tgt:  if NAME in NAME :
Pred: if NAME in NAME :

Tgt:  if o in opt_dict :
Pred: if o in opt_dict :
==================
NL:split instructions by _STR:0_ character , substitute the result for styles .
Tgt:  NAME = NAME . NAME ( STRING )
Pred: NAME = NAME . NAME ( STRING )

Tgt:  styles = instructions . split ( <[> _STR:0_ <]> )
Pred: styles = instructions . split ( <[> _STR:0_ <]> )
==================
NL:call the method tag.groups [ tag . groups ] , substitute the result for closing_tag , tagname and self_closing , respectively .
Tgt:  NAME , NAME , NAME = NAME . NAME ( )
Pred: NAME , NAME , NAME = NAME . NAME ( )

Tgt:  closing_tag , tagname , self_closing = tag . groups ( )
Pred: closing_tag , tagname , self_closing = tag . groups ( )
==================
NL:return an instance of EscapeBytes , created with an argument s .
Tgt:  return NAME ( NAME )
Pred: return NAME ( NAME )

Tgt:  return EscapeBytes ( s )
Pred: return EscapeBytes ( s )
==================
NL:if end_index is None and s_len is greater than truncate_len ,
Tgt:  if NAME is None and NAME > NAME :
Pred: if NAME is None and NAME > NAME :

Tgt:  if end_index is None and s_len > truncate_len :
Pred: if end_index is None and s_len > truncate_len :
==================
NL:set attr attribute of the self object to value .
Tgt:  setattr ( NAME , NAME , NAME )
Pred: setattr ( NAME , NAME , NAME )

Tgt:  setattr ( self , attr , value )
Pred: setattr ( self , attr , value )
==================
NL:return the result . define the function pgettext with 2 arguments : context and message .
Tgt:  def NAME ( NAME , NAME ) :
Pred: def NAME ( NAME , NAME ) :

Tgt:  def pgettext ( context , message ) :
Pred: def pgettext ( context , message ) :
==================
NL:if PY3 is true ,
Tgt:  if NAME :
Pred: if NAME :

Tgt:  if PY3 :
Pred: if PY3 :
==================
NL:try ,
Tgt:  try :
Pred: try :

Tgt:  try :
Pred: try :
==================
NL:inplural is boolean False .
Tgt:  NAME = False
Pred: NAME = False

Tgt:  inplural = False
Pred: inplural = False
==================
NL:for every part in parts ,
Tgt:  for NAME in NAME :
Pred: for NAME in NAME :

Tgt:  for part in parts :
Pred: for part in parts :
==================
NL:substitute _BROWSERS_DEPRECATED_LOCALES for _DJANGO_DEPRECATED_LOCALES .
Tgt:  NAME = NAME
Pred: NAME = NAME

Tgt:  _DJANGO_DEPRECATED_LOCALES = _BROWSERS_DEPRECATED_LOCALES
Pred: _DJANGO_DEPRECATED_LOCALES = _BROWSERS_DEPRECATED_LOCALES
==================
NL:derive the class FixedOffset from the tzinfo base class .
Tgt:  class NAME ( NAME ) :
Pred: class NAME ( NAME ) :

Tgt:  class FixedOffset ( tzinfo ) :
Pred: class FixedOffset ( tzinfo ) :
==================
NL:if KeyError exception is caught ,
Tgt:  except NAME :
Pred: except NAME :

Tgt:  except KeyError :
Pred: except KeyError :
==================
NL:if _time.daylight [ _time . daylight ] is true ,
Tgt:  if NAME . NAME :
Pred: if NAME . NAME :

Tgt:  if _time . daylight :
Pred: if _time . daylight :
==================
NL:_func_globals is a string _STR:0_ .
Tgt:  NAME = STRING
Pred: NAME = STRING

Tgt:  _func_globals = <[> _STR:0_ <]>
Pred: _func_globals = <[> _STR:0_ <]>
==================
NL:if _localtime is None ,
Tgt:  if NAME is None :
Pred: if NAME is None :

Tgt:  if _localtime is None :
Pred: if _localtime is None :
==================
NL:call the function trim_whitespace with an argument message , substitute the result for message .
Tgt:  NAME = NAME ( NAME )
Pred: NAME = NAME ( NAME )

Tgt:  message = trim_whitespace ( message )
Pred: message = trim_whitespace ( message )
==================
NL:from django.utils.encoding [ django . utils . encoding ] import force_str , force_text and DEFAULT_LOCALE_ENCODING into default name space .
Tgt:  from NAME . NAME . NAME import NAME , NAME , NAME
Pred: from NAME . NAME . NAME import NAME , NAME , NAME

Tgt:  from django . utils . encoding import force_str , force_text , DEFAULT_LOCALE_ENCODING
Pred: from django . utils . encoding import force_str , force_text , DEFAULT_LOCALE_ENCODING
==================
NL:buffer_types is a tuple with 3 elements : bytes , bytearray and memoryview .
Tgt:  NAME = ( NAME , bytearray , memoryview )
Pred: NAME = ( NAME , NAME , NAME )

Tgt:  buffer_types = ( bytes , bytearray , memoryview )
Pred: buffer_types = ( bytes , bytearray , memoryview )
==================
NL:if NameError exception is caught ,
Tgt:  except NAME :
Pred: except NAME :

Tgt:  except NameError :
Pred: except NameError :
==================
NL:get translation_function attribute of the object _default , call the result with an argument eol_message , substitute the result for result .
Tgt:  NAME = getattr ( NAME , NAME ) ( NAME )
Pred: NAME = getattr ( NAME , NAME ) ( NAME )

Tgt:  result = getattr ( _default , translation_function ) ( eol_message )
Pred: result = getattr ( _default , translation_function ) ( eol_message )
==================
NL:define the function to_locale with 2 arguments language and to_lower set to boolean False .
Tgt:  def NAME ( NAME , NAME = False ) :
Pred: def NAME ( NAME , NAME = False ) :

Tgt:  def to_locale ( language , to_lower = False ) :
Pred: def to_locale ( language , to_lower = False ) :
==================
NL:split lang_code by character _STR:0_ , substitute the first element of the result for generic_lang_code .
Tgt:  NAME = NAME . NAME ( STRING ) [ NUMBER ]
Pred: NAME = NAME . NAME ( STRING ) [ NUMBER ]

Tgt:  generic_lang_code = lang_code . split ( <[> _STR:0_ <]> ) [ 0 ]
Pred: generic_lang_code = lang_code . split ( <[> _STR:0_ <]> ) [ 0 ]
==================
NL:call the function constant_re.findall [ constant_re . findall ] with an argument t.contents [ t . contents ] , substitute the result for cmatches .
Tgt:  NAME = NAME . NAME ( NAME . NAME )
Pred: NAME = NAME . NAME ( NAME . NAME )

Tgt:  cmatches = constant_re . findall ( t . contents )
Pred: cmatches = constant_re . findall ( t . contents )
==================
NL:if comment_lineno_cache is not None ,
Tgt:  if NAME is not None :
Pred: if NAME is not None :

Tgt:  if comment_lineno_cache is not None :
Pred: if comment_lineno_cache is not None :
==================
NL:try
Tgt:  try :
Pred: try :

Tgt:  try :
Pred: try :
==================
NL:activate is a lambda function which returns None for any argument x .
Tgt:  NAME = lambda NAME : None
Pred: NAME = lambda NAME : None

Tgt:  activate = lambda x : None
Pred: activate = lambda x : None
==================
NL:if origin is true ,
Tgt:  if NAME :
Pred: if NAME :

Tgt:  if origin :
Pred: if origin :
==================
NL:_func_defaults is a string _STR:0_ .
Tgt:  NAME = STRING
Pred: NAME = STRING

Tgt:  _func_defaults = <[> _STR:0_ <]>
Pred: _func_defaults = <[> _STR:0_ <]>
==================
NL:if fp is None ,
Tgt:  if NAME is None :
Pred: if NAME is None :

Tgt:  if fp is None :
Pred: if fp is None :
==================
NL:from django.utils.functional [ django . utils . functional ] import curry and Promise into default name space .
Tgt:  from NAME . NAME . NAME import NAME , NAME
Pred: from NAME . NAME . NAME import NAME , NAME

Tgt:  from django . utils . functional import curry , Promise
Pred: from django . utils . functional import curry , Promise
==================
NL:derive class X from the object base class .
Tgt:  class NAME ( object ) :
Pred: class NAME ( object ) :

Tgt:  class X ( object ) :
Pred: class X ( object ) :
==================
NL:call the function timedelta with an argument integer 0 , return the result .
Tgt:  return NAME ( NUMBER )
Pred: return NAME ( NUMBER )

Tgt:  return timedelta ( 0 )
Pred: return timedelta ( 0 )
==================
NL:if i is true ,
Tgt:  if NAME :
Pred: if NAME :

Tgt:  if i :
Pred: if i :
==================
NL:return the result . if UnicodeDecodeError exception is caught ,
Tgt:  except NAME :
Pred: except NAME :

Tgt:  except UnicodeDecodeError :
Pred: except UnicodeDecodeError :
==================
NL:return it . define the function itervalues with 2 arguments : d and unpacked dictionary kw .
Tgt:  def NAME ( NAME , ** NAME ) :
Pred: def NAME ( NAME , ** NAME ) :

Tgt:  def itervalues ( d , ** kw ) :
Pred: def itervalues ( d , ** kw ) :
==================
NL:from django.utils [ django . utils ] import six into default name space .
Tgt:  from NAME . NAME import NAME
Pred: from NAME . NAME import NAME

Tgt:  from django . utils import six
Pred: from django . utils import six
==================
NL:from threading import local into default name space .
Tgt:  from NAME import NAME
Pred: from NAME import NAME

Tgt:  from threading import local
Pred: from threading import local
==================
NL:pos is equal to integer 0 .
Tgt:  NAME = NUMBER
Pred: NAME = NUMBER

Tgt:  pos = 0
Pred: pos = 0
==================
NL:_supported is None .
Tgt:  NAME = None
Pred: NAME = None

Tgt:  _supported = None
Pred: _supported = None
==================
NL:if last element of pieces is true ,
Tgt:  if NAME [ - NUMBER ] :
Pred: if NAME [ - NUMBER ] :

Tgt:  if pieces [ - 1 ] :
Pred: if pieces [ - 1 ] :
==================
NL:if PY3 is true ,
Tgt:  if NAME :
Pred: if NAME :

Tgt:  if PY3 :
Pred: if PY3 :
==================
NL:call the function do_translate with 2 arguments : message and string _STR:0_ , return the result .
Tgt:  return NAME ( NAME , STRING )
Pred: return NAME ( NAME , STRING )

Tgt:  return do_translate ( message , <[> _STR:0_ <]> )
Pred: return do_translate ( message , <[> _STR:0_ <]> )
==================
NL:if not ,
Tgt:  else :
Pred: else :

Tgt:  else :
Pred: else :
==================
NL:define the method __init__ with 2 arguments self and dt .
Tgt:  def NAME ( NAME , NAME ) :
Pred: def NAME ( NAME , NAME ) :

Tgt:  def __init__ ( self , dt ) :
Pred: def __init__ ( self , dt ) :
==================
NL:decorator function receiver with an argument setting_changed ,
Tgt:  @ NAME ( NAME )
Pred: @ NAME ( NAME )

Tgt:  @ receiver ( setting_changed )
Pred: @ receiver ( setting_changed )
==================
NL:if not ,
Tgt:  else :
Pred: else :

Tgt:  else :
Pred: else :
==================
NL:if new is None ,
Tgt:  if NAME is None :
Pred: if NAME is None :

Tgt:  if new is None :
Pred: if new is None :
==================
NL:import module warnings .
Tgt:  import NAME
Pred: import NAME

Tgt:  import warnings
Pred: import warnings
==================
NL:call the method self.can_write.release [ self . can_write . release ] .
Tgt:  NAME . NAME . NAME ( )
Pred: NAME . NAME . NAME ( )

Tgt:  self . can_write . release ( )
Pred: self . can_write . release ( )
==================
NL:otherwise if t.token_type [ t . token_type ] equals TOKEN_VAR ,
Tgt:  elif NAME . NAME == NAME :
Pred: elif NAME . NAME == NAME :

Tgt:  elif t . token_type == TOKEN_VAR :
Pred: elif t . token_type == TOKEN_VAR :
==================
NL:return message .
Tgt:  return NAME
Pred: return NAME

Tgt:  return message
Pred: return message
==================
NL:substitute _urllib_robotparser_moved_attributes for Module_six_moves_urllib_robotparser._moved_attributes [ Module_six_moves_urllib_robotparser . _moved_attributes ] .
Tgt:  NAME . NAME = NAME
Pred: NAME . NAME = NAME

Tgt:  Module_six_moves_urllib_robotparser . _moved_attributes = _urllib_robotparser_moved_attributes
Pred: Module_six_moves_urllib_robotparser . _moved_attributes = _urllib_robotparser_moved_attributes
==================
NL:if slots is an instance of str ,
Tgt:  if isinstance ( NAME , str ) :
Pred: if isinstance ( NAME , str ) :

Tgt:  if isinstance ( slots , str ) :
Pred: if isinstance ( slots , str ) :
==================
NL:call the method local , substitute the result for _active .
Tgt:  NAME = NAME ( )
Pred: NAME = NAME ( )

Tgt:  _active = local ( )
Pred: _active = local ( )
==================
NL:call the function self._new_gnu_trans [ self . _new_gnu_trans ] with an argument localedir , substitute the result for translation .
Tgt:  NAME = NAME . NAME ( NAME )
Pred: NAME = NAME . NAME ( NAME )

Tgt:  translation = self . _new_gnu_trans ( localedir )
Pred: translation = self . _new_gnu_trans ( localedir )
==================
NL:return data .
Tgt:  return NAME
Pred: return NAME

Tgt:  return data
Pred: return data
==================
NL:if incomment is true ,
Tgt:  if NAME :
Pred: if NAME :

Tgt:  if incomment :
Pred: if incomment :
==================
NL:CONTEXT_SEPARATOR is a string _STR:0_ .
Tgt:  NAME = STRING
Pred: NAME = STRING

Tgt:  CONTEXT_SEPARATOR = <[> _STR:0_ <]>
Pred: CONTEXT_SEPARATOR = <[> _STR:0_ <]>
==================
NL:return the result . if type of s equals bytes ,
Tgt:  if type ( NAME ) == NAME :
Pred: if type ( NAME ) == NAME :

Tgt:  if type ( s ) == bytes :
Pred: if type ( s ) == bytes :
==================
NL:increment self.active_writers [ self . active_writers ] by 1 .
Tgt:  NAME . NAME += NUMBER
Pred: NAME . NAME += NUMBER

Tgt:  self . active_writers += 1
Pred: self . active_writers += 1
==================
NL:return result .
Tgt:  return NAME
Pred: return NAME

Tgt:  return result
Pred: return result
==================
NL:delete Trans .
Tgt:  del NAME
Pred: del NAME

Tgt:  del Trans
Pred: del Trans
==================
NL:yield nothing .
Tgt:  NAME
Pred: NAME

Tgt:  yield
Pred: yield
==================
NL:code_list is an empty list .
Tgt:  NAME = [ ]
Pred: NAME = [ ]

Tgt:  code_list = [ ]
Pred: code_list = [ ]
==================
NL:if end is not None ,
Tgt:  if NAME is not None :
Pred: if NAME is not None :

Tgt:  if end is not None :
Pred: if end is not None :
==================
NL:return result .
Tgt:  return NAME
Pred: return NAME

Tgt:  return result
Pred: return result
==================
NL:define the method _prepare_data with 2 arguments : self and data .
Tgt:  def NAME ( NAME , NAME ) :
Pred: def NAME ( NAME , NAME ) :

Tgt:  def _prepare_data ( self , data ) :
Pred: def _prepare_data ( self , data ) :
==================
NL:if not an empty string , and truncate , return the result . return text .
Tgt:  return NAME
Pred: return NAME

Tgt:  return text
Pred: return text
==================
NL:call the function allow_lazy with an argument words , substitute the result for words .
Tgt:  NAME = NAME ( NAME )
Pred: NAME = NAME ( NAME )

Tgt:  words = allow_lazy ( words )
Pred: words = allow_lazy ( words )
==================
NL:define the method __exit__ with 4 arguments : self , exc_type , exc_value and traceback .
Tgt:  def NAME ( NAME , NAME , NAME , NAME ) :
Pred: def NAME ( NAME , NAME , NAME , NAME ) :

Tgt:  def __exit__ ( self , exc_type , exc_value , traceback ) :
Pred: def __exit__ ( self , exc_type , exc_value , traceback ) :
==================
NL:return self.__to_language [ self . __to_language ] .
Tgt:  return NAME . NAME
Pred: return NAME . NAME

Tgt:  return self . __to_language
Pred: return self . __to_language
==================
NL:substitute EscapeBytes for EscapeString .
Tgt:  NAME = NAME
Pred: NAME = NAME

Tgt:  EscapeString = EscapeBytes
Pred: EscapeString = EscapeBytes
==================
NL:derive the class SimplerXMLGenerator form the XMLGenerator base class .
Tgt:  class NAME ( NAME ) :
Pred: class NAME ( NAME ) :

Tgt:  class SimplerXMLGenerator ( XMLGenerator ) :
Pred: class SimplerXMLGenerator ( XMLGenerator ) :
==================
NL:if t.token_type [ t . token_type ] equals TOKEN_BLOCK ,
Tgt:  if NAME . NAME == NAME :
Pred: if NAME . NAME == NAME :

Tgt:  if t . token_type == TOKEN_BLOCK :
Pred: if t . token_type == TOKEN_BLOCK :
==================
NL:_supported is an instance of OrderedDict class , created with an argument settings.LANGUAGES [ settings . LANGUAGES ] .
Tgt:  NAME = NAME ( NAME . NAME )
Pred: NAME = NAME ( NAME . NAME )

Tgt:  _supported = OrderedDict ( settings . LANGUAGES )
Pred: _supported = OrderedDict ( settings . LANGUAGES )
==================
NL:import module os .
Tgt:  import NAME
Pred: import NAME

Tgt:  import os
Pred: import os
==================
NL:otherwise if _locs_ is None ,
Tgt:  elif NAME is None :
Pred: elif NAME is None :

Tgt:  elif _locs_ is None :
Pred: elif _locs_ is None :
==================
NL:call the method gettext_module.GNUTranslations.__init__ [ gettext_module . GNUTranslations . __init__ ] with an argument self .
Tgt:  NAME . NAME . NAME ( NAME )
Pred: NAME . NAME . NAME ( NAME )

Tgt:  gettext_module . GNUTranslations . __init__ ( self )
Pred: gettext_module . GNUTranslations . __init__ ( self )
==================
NL:define the method reader_leaves with an argument self .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def reader_leaves ( self ) :
Pred: def reader_leaves ( self ) :
==================
NL:import module re .
Tgt:  import re
Pred: import re

Tgt:  import re
Pred: import re
==================
NL:substitute SafeBytes for SafeString .
Tgt:  NAME = NAME
Pred: NAME = NAME

Tgt:  SafeString = SafeBytes
Pred: SafeString = SafeBytes
==================
NL:call the method smart_split_re.finditer [ smart_split_re . finditer ] with an argument text , for every bit in result ,
Tgt:  for NAME in NAME . NAME ( NAME ) :
Pred: for NAME in NAME . NAME ( NAME ) :

Tgt:  for bit in smart_split_re . finditer ( text ) :
Pred: for bit in smart_split_re . finditer ( text ) :
==================
NL:return translated .
Tgt:  return NAME
Pred: return NAME

Tgt:  return translated
Pred: return translated
==================
NL:and number set to number , return the result . define the function ungettext_lazy with 3 arguments : singular , plural and number set to None .
Tgt:  def NAME ( NAME , NAME , NAME = None ) :
Pred: def NAME ( NAME , NAME , NAME = None ) :

Tgt:  def ungettext_lazy ( singular , plural , number = None ) :
Pred: def ungettext_lazy ( singular , plural , number = None ) :
==================
NL:slots is a list with an element , slots .
Tgt:  NAME = [ NAME ]
Pred: NAME = [ NAME ]

Tgt:  slots = [ slots ]
Pred: slots = [ slots ]
==================
NL:replace every occurrence of _STR:0_ in s with _STR:1_ .
Tgt:  NAME = NAME . NAME ( STRING , STRING )
Pred: NAME = NAME . NAME ( STRING , STRING )

Tgt:  s = s . replace ( <[> _STR:0_ <]> , <[> _STR:1_ <]> )
Pred: s = s . replace ( <[> _STR:0_ <]> , <[> _STR:1_ <]> )
==================
NL:if sep is an instance of unicode ,
Tgt:  if isinstance ( NAME , unicode ) :
Pred: if isinstance ( NAME , NAME ) :

Tgt:  if isinstance ( sep , unicode ) :
Pred: if isinstance ( sep , unicode ) :
==================
NL:call the method text.splitlines [ text . splitlines ] with an argument boolean True , for every line in the result ,
Tgt:  for NAME in NAME . NAME ( True ) :
Pred: for NAME in NAME . NAME ( NAME ) :

Tgt:  for line in text . splitlines ( True ) :
Pred: for line in text . splitlines ( True ) :
==================
NL:if not ,
Tgt:  else :
Pred: else :

Tgt:  else :
Pred: else :
==================
NL:derive the class DjangoTranslation from gettext_module.GNUTranslations [ gettext_module . GNUTranslations ] base class .
Tgt:  class NAME ( NAME . NAME ) :
Pred: class NAME ( NAME . NAME ) :

Tgt:  class DjangoTranslation ( gettext_module . GNUTranslations ) :
Pred: class DjangoTranslation ( gettext_module . GNUTranslations ) :
==================
NL:increment i-th element of result by piece .
Tgt:  NAME [ NAME ] += NAME
Pred: NAME [ NAME ] += NAME

Tgt:  result [ i ] += piece
Pred: result [ i ] += piece
==================
NL:substitute old for self.mod [ self . mod ] .
Tgt:  NAME . NAME = NAME
Pred: NAME . NAME = NAME

Tgt:  self . mod = old
Pred: self . mod = old
==================
NL:for every arg in args ,
Tgt:  for NAME in NAME :
Pred: for NAME in NAME :

Tgt:  for arg in args :
Pred: for arg in args :
==================
NL:return s .
Tgt:  return NAME
Pred: return NAME

Tgt:  return s
Pred: return s
==================
NL:delete frame .
Tgt:  del NAME
Pred: del NAME

Tgt:  del frame
Pred: del frame
==================
NL:self.vals [ self . vals ] is an empty list .
Tgt:  NAME . NAME = [ ]
Pred: NAME . NAME = [ ]

Tgt:  self . vals = [ ]
Pred: self . vals = [ ]
==================
NL:define the function mark_safe with an argument s .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def mark_safe ( s ) :
Pred: def mark_safe ( s ) :
==================
NL:substitute fg for value under the _STR:0_ key of definition dictionary .
Tgt:  NAME [ STRING ] = NAME
Pred: NAME [ STRING ] = NAME

Tgt:  definition [ <[> _STR:0_ <]> ] = fg
Pred: definition [ <[> _STR:0_ <]> ] = fg
==================
NL:skip this loop iteration .
Tgt:  NAME
Pred: NAME

Tgt:  continue
Pred: continue
==================
NL:define the function get_language_from_path with 2 arguments : path and strict set to boolean False .
Tgt:  def NAME ( NAME , NAME = False ) :
Pred: def NAME ( NAME , NAME = False ) :

Tgt:  def get_language_from_path ( path , strict = False ) :
Pred: def get_language_from_path ( path , strict = False ) :
==================
NL:ingeter 0 and integer 0. call the method _time.mktime [ _time . mktime ] with an argument tt , substitute the result for stamp .
Tgt:  NAME = NAME . NAME ( NAME )
Pred: NAME = NAME . NAME ( NAME )

Tgt:  stamp = _time . mktime ( tt )
Pred: stamp = _time . mktime ( tt )
==================
NL:if sys.platform [ sys . platform ] starts with a string _STR:0_ ,
Tgt:  if NAME . NAME . NAME ( STRING ) :
Pred: if NAME . NAME . NAME ( STRING ) :

Tgt:  if sys . platform . startswith ( <[> _STR:0_ <]> ) :
Pred: if sys . platform . startswith ( <[> _STR:0_ <]> ) :
==================
NL:return self.DSTOFFSET [ self . DSTOFFSET ] .
Tgt:  return NAME . NAME
Pred: return NAME . NAME

Tgt:  return self . DSTOFFSET
Pred: return self . DSTOFFSET
==================
NL:_BROWSERS_DEPRECATED_LOCALES is an dictionary with 2 initial entries : _STR:0_ for _STR:1_ and _STR:2_ for _STR:3_ .
Tgt:  NAME = { STRING : STRING , STRING : STRING , }
Pred: NAME = { STRING : STRING , STRING : STRING , }

Tgt:  _BROWSERS_DEPRECATED_LOCALES = { <[> _STR:1_ <]> : <[> _STR:0_ <]> , <[> _STR:3_ <]> : <[> _STR:2_ <]> , }
Pred: _BROWSERS_DEPRECATED_LOCALES = { <[> _STR:1_ <]> : <[> _STR:0_ <]> , <[> _STR:3_ <]> : <[> _STR:2_ <]> , }
==================
NL:break from the loop execution .
Tgt:  NAME
Pred: NAME

Tgt:  break
Pred: break
==================
NL:define the function assertCountEqual with 3 arguments : self , unpacked list args and unpacked dictionary kwargs .
Tgt:  def NAME ( NAME , * NAME , ** NAME ) :
Pred: def NAME ( NAME , * NAME , ** NAME ) :

Tgt:  def assertCountEqual ( self , * args , ** kwargs ) :
Pred: def assertCountEqual ( self , * args , ** kwargs ) :
==================
NL:return value under the name key of the sys.modules [ sys . modules ] dictionary .
Tgt:  return NAME . NAME [ NAME ]
Pred: return NAME . NAME [ NAME ]

Tgt:  return sys . modules [ name ]
Pred: return sys . modules [ name ]
==================
NL:intrans is boolean True .
Tgt:  NAME = True
Pred: NAME = True

Tgt:  intrans = True
Pred: intrans = True
==================
NL:convert slice of language string from ( p+1 ) -th index to the end to uppercase , append it to the previous result , return the resulting string . if not ,
Tgt:  else :
Pred: else :

Tgt:  else :
Pred: else :
==================
NL:call the function get_supported_language_variant with an argument lang_code , return the result .
Tgt:  return NAME ( NAME )
Pred: return NAME ( NAME )

Tgt:  return get_supported_language_variant ( lang_code )
Pred: return get_supported_language_variant ( lang_code )
==================
NL:from django.utils.translation [ django . utils . translation ] import ugettext_lazy , ugettext as _ and pgettext into default name space .
Tgt:  from NAME . NAME . NAME import NAME , NAME as NAME , NAME
Pred: from NAME . NAME . NAME import NAME , NAME as NAME , NAME

Tgt:  from django . utils . translation import ugettext_lazy , ugettext as _ , pgettext
Pred: from django . utils . translation import ugettext_lazy , ugettext as _ , pgettext
==================
NL:call the method self.add_fallback [ self . add_fallback ] with an argument default_translation .
Tgt:  NAME . NAME ( NAME )
Pred: NAME . NAME ( NAME )

Tgt:  self . add_fallback ( default_translation )
Pred: self . add_fallback ( default_translation )
==================
NL:if self.connector [ self . connector ] equals conn_type ,
Tgt:  if NAME . NAME == NAME :
Pred: if NAME . NAME == NAME :

Tgt:  if self . connector == conn_type :
Pred: if self . connector == conn_type :
==================
NL:if not ,
Tgt:  else :
Pred: else :

Tgt:  else :
Pred: else :
==================
NL:call the function allow_lazy with 2 arguments : unescape_entities and six.text_type [ six . text_type ] , substitute the result for unescape_entities .
Tgt:  NAME = NAME ( NAME , NAME . NAME )
Pred: NAME = NAME ( NAME , NAME . NAME )

Tgt:  unescape_entities = allow_lazy ( unescape_entities , six . text_type )
Pred: unescape_entities = allow_lazy ( unescape_entities , six . text_type )
==================
NL:raise an AttributeError with an argument attr .
Tgt:  raise NAME ( NAME )
Pred: raise NAME ( NAME )

Tgt:  raise AttributeError ( attr )
Pred: raise AttributeError ( attr )
==================
NL:call the method match.group [ match . group ] with an argument integer 0 , return the result .
Tgt:  return NAME . NAME ( NUMBER )
Pred: return NAME . NAME ( NUMBER )

Tgt:  return match . group ( 0 )
Pred: return match . group ( 0 )
==================
NL:substitute it for value under the string _STR:0_ appended to __name__ key of the sys.modules [ sys . modules ] dictionary . define the function add_move with an argument move .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def add_move ( move ) :
Pred: def add_move ( move ) :
==================
NL:try ,
Tgt:  try :
Pred: try :

Tgt:  try :
Pred: try :
==================
NL:if self.timezone [ self . timezone ] is None ,
Tgt:  if NAME . NAME is None :
Pred: if NAME . NAME is None :

Tgt:  if self . timezone is None :
Pred: if self . timezone is None :
==================
NL:if not ,
Tgt:  else :
Pred: else :

Tgt:  else :
Pred: else :
==================
NL:param is None .
Tgt:  NAME = None
Pred: NAME = None

Tgt:  param = None
Pred: param = None
==================
NL:if LookupError exception is caught ,
Tgt:  except NAME :
Pred: except NAME :

Tgt:  except LookupError :
Pred: except LookupError :
==================
NL:define the function byte2int with an argument bs .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def byte2int ( bs ) :
Pred: def byte2int ( bs ) :
==================
NL:derive the class NumberAwareString from the resultclass base class .
Tgt:  class NAME ( NAME ) :
Pred: class NAME ( NAME ) :

Tgt:  class NumberAwareString ( resultclass ) :
Pred: class NumberAwareString ( resultclass ) :
==================
NL:define the function join_tokens with 2 arguments : tokens and trim set to boolean False .
Tgt:  def NAME ( NAME , NAME = False ) :
Pred: def NAME ( NAME , NAME = False ) :

Tgt:  def join_tokens ( tokens , trim = False ) :
Pred: def join_tokens ( tokens , trim = False ) :
==================
NL:if colors is true and last element of colors is contained in color_names ,
Tgt:  if NAME and NAME [ - NUMBER ] in NAME :
Pred: if NAME and NAME [ - NUMBER ] in NAME :

Tgt:  if colors and colors [ - 1 ] in color_names :
Pred: if colors and colors [ - 1 ] in color_names :
==================
NL:define the function trim_whitespace with an argument s .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def trim_whitespace ( s ) :
Pred: def trim_whitespace ( s ) :
==================
NL:define the method next with an argument self .
Tgt:  def next ( NAME ) :
Pred: def next ( NAME ) :

Tgt:  def next ( self ) :
Pred: def next ( self ) :
==================
NL:if sep is None ,
Tgt:  if NAME is None :
Pred: if NAME is None :

Tgt:  if sep is None :
Pred: if sep is None :
==================
NL:_STR:0_ , _STR:1_ , _STR:2_ . for every attr in _urllib_robotparser_moved_attributes ,
Tgt:  for NAME in NAME :
Pred: for NAME in NAME :

Tgt:  for attr in _urllib_robotparser_moved_attributes :
Pred: for attr in _urllib_robotparser_moved_attributes :
==================
NL:singular is an empty list .
Tgt:  NAME = [ ]
Pred: NAME = [ ]

Tgt:  singular = [ ]
Pred: singular = [ ]
==================
NL:if first element of text equals _STR:0_ ,
Tgt:  if NAME [ NUMBER ] == STRING :
Pred: if NAME [ NUMBER ] == STRING :

Tgt:  if text [ 0 ] == <[> _STR:0_ <]> :
Pred: if text [ 0 ] == <[> _STR:0_ <]> :
==================
NL:substitute str for binary_type .
Tgt:  NAME = str
Pred: NAME = str

Tgt:  binary_type = str
Pred: binary_type = str
==================
NL:plural is an empty list .
Tgt:  NAME = [ ]
Pred: NAME = [ ]

Tgt:  plural = [ ]
Pred: plural = [ ]
==================
NL:for every pos and elt in enumerated iterable source ,
Tgt:  for NAME , NAME in enumerate ( NAME ) :
Pred: for NAME , NAME in enumerate ( NAME ) :

Tgt:  for pos , elt in enumerate ( source ) :
Pred: for pos , elt in enumerate ( source ) :
==================
NL:define the function deactivate_all .
Tgt:  def NAME ( ) :
Pred: def NAME ( ) :

Tgt:  def deactivate_all ( ) :
Pred: def deactivate_all ( ) :
==================
NL:if sep is not None ,
Tgt:  if NAME is not None :
Pred: if NAME is not None :

Tgt:  if sep is not None :
Pred: if sep is not None :
==================
NL:if opts is true ,
Tgt:  if NAME :
Pred: if NAME :

Tgt:  if opts :
Pred: if opts :
==================
NL:if AttributeError exception is caught ,
Tgt:  except NAME :
Pred: except NAME :

Tgt:  except AttributeError :
Pred: except AttributeError :
==================
NL:return an instance of SafeBytes , created with an argument data .
Tgt:  return NAME ( NAME )
Pred: return NAME ( NAME )

Tgt:  return SafeBytes ( data )
Pred: return SafeBytes ( data )
==================
NL:substitute opts for value under the _STR:0_ key of definition dictionary .
Tgt:  NAME [ STRING ] = NAME
Pred: NAME [ STRING ] = NAME

Tgt:  definition [ <[> _STR:0_ <]> ] = opts
Pred: definition [ <[> _STR:0_ <]> ] = opts
==================
NL:call the method match.group [ match . group ] with an argument integer 0 , return the result .
Tgt:  return NAME . NAME ( NUMBER )
Pred: return NAME . NAME ( NUMBER )

Tgt:  return match . group ( 0 )
Pred: return match . group ( 0 )
==================
NL:return s .
Tgt:  return NAME
Pred: return NAME

Tgt:  return s
Pred: return s
==================
NL:from __future__ import unicode_literals into default name space .
Tgt:  from NAME import NAME
Pred: from NAME import NAME

Tgt:  from __future__ import unicode_literals
Pred: from __future__ import unicode_literals
==================
NL:define the function iterkeys with 2 arguments : d and unpacked dictionary kw .
Tgt:  def NAME ( NAME , ** NAME ) :
Pred: def NAME ( NAME , ** NAME ) :

Tgt:  def iterkeys ( d , ** kw ) :
Pred: def iterkeys ( d , ** kw ) :
==================
NL:substitute number_value for kwargs dictionary value under the _STR:0_ key .
Tgt:  NAME [ STRING ] = NAME
Pred: NAME [ STRING ] = NAME

Tgt:  kwargs [ <[> _STR:0_ <]> ] = number_value
Pred: kwargs [ <[> _STR:0_ <]> ] = number_value
==================
NL:raise an LookupError with an argument lang_code .
Tgt:  raise NAME ( NAME )
Pred: raise NAME ( NAME )

Tgt:  raise LookupError ( lang_code )
Pred: raise LookupError ( lang_code )
==================
NL:if PY3 is true ,
Tgt:  if NAME :
Pred: if NAME :

Tgt:  if PY3 :
Pred: if PY3 :
==================
NL:define the method tzname with 2 arguments self and dt .
Tgt:  def NAME ( NAME , NAME ) :
Pred: def NAME ( NAME , NAME ) :

Tgt:  def tzname ( self , dt ) :
Pred: def tzname ( self , dt ) :
==================
NL:finally perform ,
Tgt:  finally :
Pred: finally :

Tgt:  finally :
Pred: finally :
==================
NL:if not ,
Tgt:  else :
Pred: else :

Tgt:  else :
Pred: else :
==================
NL:call the function timedelta with an argument seconds set to negative _time.altzone [ _time . altzone ] , substitute the result for self.DSTOFFSET [ self . DSTOFFSET ] .
Tgt:  NAME . NAME = NAME ( NAME = - NAME . NAME )
Pred: NAME . NAME = NAME ( NAME = - NAME . NAME )

Tgt:  self . DSTOFFSET = timedelta ( seconds = - _time . altzone )
Pred: self . DSTOFFSET = timedelta ( seconds = - _time . altzone )
==================
NL:call the method time.mktime [ time . mktime ] with an argument tt , substitute the result for stamp .
Tgt:  NAME = NAME . NAME ( NAME )
Pred: NAME = NAME . NAME ( NAME )

Tgt:  stamp = time . mktime ( tt )
Pred: stamp = time . mktime ( tt )
==================
NL:from collections import OrderedDict into default name space .
Tgt:  from NAME import NAME
Pred: from NAME import NAME

Tgt:  from collections import OrderedDict
Pred: from collections import OrderedDict
==================
NL:from io import BytesIO into default name space .
Tgt:  from NAME import NAME
Pred: from NAME import NAME

Tgt:  from io import BytesIO
Pred: from io import BytesIO
==================
NL:call the method deactivate .
Tgt:  NAME ( )
Pred: NAME ( )

Tgt:  deactivate ( )
Pred: deactivate ( )
==================
NL:if PY3 is true ,
Tgt:  if NAME :
Pred: if NAME :

Tgt:  if PY3 :
Pred: if PY3 :
==================
NL:call the method language_code_re.search [ language_code_re . search ] with an argument lang_code , if it evaluates to false ,
Tgt:  if not NAME . NAME ( NAME ) :
Pred: if not NAME . NAME ( NAME ) :

Tgt:  if not language_code_re . search ( lang_code ) :
Pred: if not language_code_re . search ( lang_code ) :
==================
NL:end_index is None .
Tgt:  NAME = None
Pred: NAME = None

Tgt:  end_index = None
Pred: end_index = None
==================
NL:substitute language for self.language [ self . language ] .
Tgt:  NAME . NAME = NAME
Pred: NAME . NAME = NAME

Tgt:  self . language = language
Pred: self . language = language
==================
NL:if this_bases is None ,
Tgt:  if NAME is None :
Pred: if NAME is None :

Tgt:  if this_bases is None :
Pred: if this_bases is None :
==================
NL:from django.utils.translation [ django . utils . translation ] import ugettext and ungettext_lazy into default name space .
Tgt:  from NAME . NAME . NAME import NAME , NAME
Pred: from NAME . NAME . NAME import NAME , NAME

Tgt:  from django . utils . translation import ugettext , ungettext_lazy
Pred: from django . utils . translation import ugettext , ungettext_lazy
==================
NL:call the function get_language_from_path with an argument request.path_info [ request . path_info ] , substitute it for lang_code .
Tgt:  NAME = NAME ( NAME . NAME )
Pred: NAME = NAME ( NAME . NAME )

Tgt:  lang_code = get_language_from_path ( request . path_info )
Pred: lang_code = get_language_from_path ( request . path_info )
==================
NL:skip this loop iteration .
Tgt:  NAME
Pred: NAME

Tgt:  continue
Pred: continue
==================
NL:do nothing .
Tgt:  NAME
Pred: NAME

Tgt:  pass
Pred: pass
==================
NL:try ,
Tgt:  try :
Pred: try :

Tgt:  try :
Pred: try :
==================
NL:substitute t.lineno [ t . lineno ] for comment_lineno_cache .
Tgt:  NAME = NAME . NAME
Pred: NAME = NAME . NAME

Tgt:  comment_lineno_cache = t . lineno
Pred: comment_lineno_cache = t . lineno
==================
NL:call the method s.decode [ s . decode ] with an argument string _STR:0_ , substitute the result for s .
Tgt:  NAME = NAME . NAME ( STRING )
Pred: NAME = NAME . NAME ( STRING )

Tgt:  s = s . decode ( <[> _STR:0_ <]> )
Pred: s = s . decode ( <[> _STR:0_ <]> )
==================
NL:substitute conn_type for self.connector [ self . connector ] .
Tgt:  NAME . NAME = NAME
Pred: NAME . NAME = NAME

Tgt:  self . connector = conn_type
Pred: self . connector = conn_type
==================
NL:define the method __getinitargs__ with an argument self .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def __getinitargs__ ( self ) :
Pred: def __getinitargs__ ( self ) :
==================
NL:return _default .
Tgt:  return NAME
Pred: return NAME

Tgt:  return _default
Pred: return _default
==================
NL:call the function curry with 2 arguments : _proxy_method and method set to bytes.decode [ bytes . decode ] , substitute the result for decode .
Tgt:  NAME = NAME ( NAME , NAME = NAME . NAME )
Pred: NAME = NAME ( NAME , NAME = NAME . NAME )

Tgt:  decode = curry ( _proxy_method , method = bytes . decode )
Pred: decode = curry ( _proxy_method , method = bytes . decode )
==================
NL:call the function get_current_timezone , substitute the result for timezone .
Tgt:  NAME = NAME ( )
Pred: NAME = NAME ( )

Tgt:  timezone = get_current_timezone ( )
Pred: timezone = get_current_timezone ( )
==================
NL:substitute self.STDOFFSET [ self . STDOFFSET ] for self.DSTOFFSET [ self . DSTOFFSET ] .
Tgt:  NAME . NAME = NAME . NAME
Pred: NAME . NAME = NAME . NAME

Tgt:  self . DSTOFFSET = self . STDOFFSET
Pred: self . DSTOFFSET = self . STDOFFSET
==================
NL:call the function force_text with an argument text , substitute the result for text .
Tgt:  NAME = NAME ( NAME )
Pred: NAME = NAME ( NAME )

Tgt:  text = force_text ( text )
Pred: text = force_text ( text )
==================
NL:call the function translation with an argument settings.LANGUAGE_CODE [ settings . LANGUAGE_CODE ] , substitute the result for _default .
Tgt:  NAME = NAME ( NAME . NAME )
Pred: NAME = NAME ( NAME . NAME )

Tgt:  _default = translation ( settings . LANGUAGE_CODE )
Pred: _default = translation ( settings . LANGUAGE_CODE )
==================
NL:define the function get_unbound_function with an argument unbound .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def get_unbound_function ( unbound ) :
Pred: def get_unbound_function ( unbound ) :
==================
NL:define the function print_ with 2 arguments : unpacked list args and unpacked dictionary kwargs .
Tgt:  def NAME ( * NAME , ** NAME ) :
Pred: def NAME ( * NAME , ** NAME ) :

Tgt:  def print_ ( * args , ** kwargs ) :
Pred: def print_ ( * args , ** kwargs ) :
==================
NL:formated with c , filemsg and comment_lineno_cache . call the function warnings.warn [ warnings . warn ] with 2 arguments : warn_msg and TranslatorCommentWarning .
Tgt:  NAME . NAME ( NAME , NAME )
Pred: NAME . NAME ( NAME , NAME )

Tgt:  warnings . warn ( warn_msg , TranslatorCommentWarning )
Pred: warnings . warn ( warn_msg , TranslatorCommentWarning )
==================
NL:return self.DSTDIFF [ self . DSTDIFF ] .
Tgt:  return NAME . NAME
Pred: return NAME . NAME

Tgt:  return self . DSTDIFF
Pred: return self . DSTDIFF
==================
NL:if data is an instance of bytes ,
Tgt:  if isinstance ( NAME , NAME ) :
Pred: if isinstance ( NAME , NAME ) :

Tgt:  if isinstance ( data , bytes ) :
Pred: if isinstance ( data , bytes ) :
==================
NL:derive the class LocalTimezone from the tzinfo base class .
Tgt:  class NAME ( NAME ) :
Pred: class NAME ( NAME ) :

Tgt:  class LocalTimezone ( tzinfo ) :
Pred: class LocalTimezone ( tzinfo ) :
==================
NL:call the __add__ method with an arguments rhs from the base class of the class SafeBytes , substitute the result for t .
Tgt:  NAME = super ( NAME , NAME ) . NAME ( NAME )
Pred: NAME = super ( NAME , NAME ) . NAME ( NAME )

Tgt:  t = super ( SafeBytes , self ) . __add__ ( rhs )
Pred: t = super ( SafeBytes , self ) . __add__ ( rhs )
==================
NL:if not ,
Tgt:  else :
Pred: else :

Tgt:  else :
Pred: else :
==================
NL:import module sys .
Tgt:  import NAME
Pred: import NAME

Tgt:  import sys
Pred: import sys
==================
NL:_meth_self is a string _STR:0_ .
Tgt:  NAME = STRING
Pred: NAME = STRING

Tgt:  _meth_self = <[> _STR:0_ <]>
Pred: _meth_self = <[> _STR:0_ <]>
==================
NL:call the method deactivate .
Tgt:  NAME ( )
Pred: NAME ( )

Tgt:  deactivate ( )
Pred: deactivate ( )
==================
NL:import module re .
Tgt:  import re
Pred: import re

Tgt:  import re
Pred: import re
==================
NL:try ,
Tgt:  try :
Pred: try :

Tgt:  try :
Pred: try :
==================
NL:if not ,
Tgt:  else :
Pred: else :

Tgt:  else :
Pred: else :
==================
NL:if _supported is None ,
Tgt:  if NAME is None :
Pred: if NAME is None :

Tgt:  if _supported is None :
Pred: if _supported is None :
==================
NL:from django.utils [ django . utils ] import six into default name space .
Tgt:  from NAME . NAME import NAME
Pred: from NAME . NAME import NAME

Tgt:  from django . utils import six
Pred: from django . utils import six
==================
NL:self.waiting_writers [ self . waiting_writers ] is an integer 0 .
Tgt:  NAME . NAME = NUMBER
Pred: NAME . NAME = NUMBER

Tgt:  self . waiting_writers = 0
Pred: self . waiting_writers = 0
==================
NL:define the method __deepcopy__ with 2 arguments : self and memodict .
Tgt:  def NAME ( NAME , NAME ) :
Pred: def NAME ( NAME , NAME ) :

Tgt:  def __deepcopy__ ( self , memodict ) :
Pred: def __deepcopy__ ( self , memodict ) :
==================
NL:if rhs is an instance of SafeText ,
Tgt:  if isinstance ( NAME , NAME ) :
Pred: if isinstance ( NAME , NAME ) :

Tgt:  if isinstance ( rhs , SafeText ) :
Pred: if isinstance ( rhs , SafeText ) :
==================
NL:define the method __init__ with 2 arguments : self and language .
Tgt:  def NAME ( NAME , NAME ) :
Pred: def NAME ( NAME , NAME ) :

Tgt:  def __init__ ( self , language ) :
Pred: def __init__ ( self , language ) :
==================
NL:substitute i for end_index .
Tgt:  NAME = NAME
Pred: NAME = NAME

Tgt:  end_index = i
Pred: end_index = i
==================
NL:define the function get_major_version with an argument version defaulting to None .
Tgt:  def NAME ( NAME = None ) :
Pred: def NAME ( NAME = None ) :

Tgt:  def get_major_version ( version = None ) :
Pred: def get_major_version ( version = None ) :
==================
NL:raise an TypeError with an argument s .
Tgt:  raise NAME ( NAME )
Pred: raise NAME ( NAME )

Tgt:  raise TypeError ( s )
Pred: raise TypeError ( s )
==================
NL:out is an instance of StringIO class , created with an empty string as an argument .
Tgt:  NAME = NAME ( STRING )
Pred: NAME = NAME ( STRING )

Tgt:  out = StringIO ( <[>  <]> )
Pred: out = StringIO ( <[>  <]> )
==================
NL:from django.utils.functional [ django . utils . functional ] import lazy into default name space .
Tgt:  from NAME . NAME . NAME import NAME
Pred: from NAME . NAME . NAME import NAME

Tgt:  from django . utils . functional import lazy
Pred: from django . utils . functional import lazy
==================
NL:obj is an instance of Node class , created with 3 arguments : children , connector and negated .
Tgt:  NAME = NAME ( NAME , NAME , NAME )
Pred: NAME = NAME ( NAME , NAME , NAME )

Tgt:  obj = Node ( children , connector , negated )
Pred: obj = Node ( children , connector , negated )
==================
NL:return ZERO .
Tgt:  return NAME
Pred: return NAME

Tgt:  return ZERO
Pred: return ZERO
==================
NL:comment is an empty list .
Tgt:  NAME = [ ]
Pred: NAME = [ ]

Tgt:  comment = [ ]
Pred: comment = [ ]
==================
NL:return an instance of SafeText , created with an argument t .
Tgt:  return NAME ( NAME )
Pred: return NAME ( NAME )

Tgt:  return SafeText ( t )
Pred: return SafeText ( t )
==================
NL:define the method tzname with 2 arguments : self and dt .
Tgt:  def NAME ( NAME , NAME ) :
Pred: def NAME ( NAME , NAME ) :

Tgt:  def tzname ( self , dt ) :
Pred: def tzname ( self , dt ) :
==================
NL:join comment elements into a string , substitute it for content .
Tgt:  NAME = STRING . NAME ( NAME )
Pred: NAME = STRING . NAME ( NAME )

Tgt:  content = <[>  <]> . join ( comment )
Pred: content = <[>  <]> . join ( comment )
==================
NL:if _supported is None ,
Tgt:  if NAME is None :
Pred: if NAME is None :

Tgt:  if _supported is None :
Pred: if _supported is None :
==================
NL:call the function local , substitute the result for _active .
Tgt:  NAME = NAME ( )
Pred: NAME = NAME ( )

Tgt:  _active = local ( )
Pred: _active = local ( )
==================
NL:call the function do_translate with 2 arguments : message and string _STR:0_ , return the result .
Tgt:  return NAME ( NAME , STRING )
Pred: return NAME ( NAME , STRING )

Tgt:  return do_translate ( message , <[> _STR:0_ <]> )
Pred: return do_translate ( message , <[> _STR:0_ <]> )
==================
NL:define the method __dir__ with an argument self .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def __dir__ ( self ) :
Pred: def __dir__ ( self ) :
==================
NL:derive the class SafeText from six.text_type [ six . text_type ] and SafeData base classes .
Tgt:  class NAME ( NAME . NAME , NAME ) :
Pred: class NAME ( NAME . NAME , NAME ) :

Tgt:  class SafeText ( six . text_type , SafeData ) :
Pred: class SafeText ( six . text_type , SafeData ) :
==================
NL:call the function allow_lazy with 2 arguments : get_valid_filename and six.text_type [ six . text_type ] , substitute the result for get_valid_filename .
Tgt:  NAME = NAME ( NAME , NAME . NAME )
Pred: NAME = NAME ( NAME , NAME . NAME )

Tgt:  get_valid_filename = allow_lazy ( get_valid_filename , six . text_type )
Pred: get_valid_filename = allow_lazy ( get_valid_filename , six . text_type )
==================
NL:return obj .
Tgt:  return NAME
Pred: return NAME

Tgt:  return obj
Pred: return obj
==================
NL:replace every occurrence of _STR:0_ in s with _STR:1_ .
Tgt:  NAME = NAME . NAME ( STRING , STRING )
Pred: NAME = NAME . NAME ( STRING , STRING )

Tgt:  s = s . replace ( <[> _STR:0_ <]> , <[> _STR:1_ <]> )
Pred: s = s . replace ( <[> _STR:0_ <]> , <[> _STR:1_ <]> )
==================
NL:define the function get_language_from_request with 2 arguments : request and check_path set to boolean False .
Tgt:  def NAME ( NAME , NAME = False ) :
Pred: def NAME ( NAME , NAME = False ) :

Tgt:  def get_language_from_request ( request , check_path = False ) :
Pred: def get_language_from_request ( request , check_path = False ) :
==================
NL:if self.waiting_writers [ self . waiting_writers ] is not equal to integer 0 ,
Tgt:  if NAME . NAME != NUMBER :
Pred: if NAME . NAME != NUMBER :

Tgt:  if self . waiting_writers != 0 :
Pred: if self . waiting_writers != 0 :
==================
NL:open_tags is an empty list .
Tgt:  NAME = [ ]
Pred: NAME = [ ]

Tgt:  open_tags = [ ]
Pred: open_tags = [ ]
==================
NL:substitute definition for value under the role key of palette dictionary .
Tgt:  NAME [ NAME ] = NAME
Pred: NAME [ NAME ] = NAME

Tgt:  palette [ role ] = definition
Pred: palette [ role ] = definition
==================
NL:want_unicode is boolean True .
Tgt:  NAME = True
Pred: NAME = True

Tgt:  want_unicode = True
Pred: want_unicode = True
==================
NL:derive the class StreamingBuffer from the object base class .
Tgt:  class NAME ( object ) :
Pred: class NAME ( object ) :

Tgt:  class StreamingBuffer ( object ) :
Pred: class StreamingBuffer ( object ) :
==================
NL:define the method _add_installed_apps_translations with an argument self .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def _add_installed_apps_translations ( self ) :
Pred: def _add_installed_apps_translations ( self ) :
==================
NL:call the method pytz.timezone [ pytz . timezone ] with an argument timezone , substitute the result for _active.value [ _active . value ] .
Tgt:  NAME . NAME = NAME . NAME ( NAME )
Pred: NAME . NAME = NAME . NAME ( NAME )

Tgt:  _active . value = pytz . timezone ( timezone )
Pred: _active . value = pytz . timezone ( timezone )
==================
NL:replace every occurrence of raw string _STR:0_\\ ' , return the result . call the function allow_lazy with an argument unescape_string_literal , substitute the result for unescape_string_literal .
Tgt:  NAME = NAME ( NAME )
Pred: NAME = NAME ( NAME )

Tgt:  unescape_string_literal = allow_lazy ( unescape_string_literal )
Pred: unescape_string_literal = allow_lazy ( unescape_string_literal )
==================
NL:return replacement .
Tgt:  return NAME
Pred: return NAME

Tgt:  return replacement
Pred: return replacement
==================
NL:define the function get_git_changeset .
Tgt:  def NAME ( ) :
Pred: def NAME ( ) :

Tgt:  def get_git_changeset ( ) :
Pred: def get_git_changeset ( ) :
==================
NL:return ZERO .
Tgt:  return NAME
Pred: return NAME

Tgt:  return ZERO
Pred: return ZERO
==================
NL:substitute value under the number key of the rhs dictionary for number_value .
Tgt:  NAME = NAME [ NAME ]
Pred: NAME = NAME [ NAME ]

Tgt:  number_value = rhs [ number ]
Pred: number_value = rhs [ number ]
==================
NL:try ,
Tgt:  try :
Pred: try :

Tgt:  try :
Pred: try :
==================
NL:define the function blankout with 2 arguments : src and char .
Tgt:  def NAME ( NAME , NAME ) :
Pred: def NAME ( NAME , NAME ) :

Tgt:  def blankout ( src , char ) :
Pred: def blankout ( src , char ) :
==================
NL:derive the class LocalTimezone from the ReferenceLocalTimezone base class .
Tgt:  class NAME ( NAME ) :
Pred: class NAME ( NAME ) :

Tgt:  class LocalTimezone ( ReferenceLocalTimezone ) :
Pred: class LocalTimezone ( ReferenceLocalTimezone ) :
==================
NL:define the method __init__ with an argument self .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def __init__ ( self ) :
Pred: def __init__ ( self ) :
==================
NL:incomment is boolean True .
Tgt:  NAME = True
Pred: NAME = True

Tgt:  incomment = True
Pred: incomment = True
==================
NL:convert num to an integer , substitute the result for length .
Tgt:  NAME = int ( NAME )
Pred: NAME = int ( NAME )

Tgt:  length = int ( num )
Pred: length = int ( num )
==================
NL:call the function allow_lazy with 2 arguments : normalize_newlines and six.text_type [ six . text_type ] , substitute the result for normalize_newlines .
Tgt:  NAME = NAME ( NAME , NAME . NAME )
Pred: NAME = NAME ( NAME , NAME . NAME )

Tgt:  normalize_newlines = allow_lazy ( normalize_newlines , six . text_type )
Pred: normalize_newlines = allow_lazy ( normalize_newlines , six . text_type )
==================
NL:if lang_code is not None ,
Tgt:  if NAME is not None :
Pred: if NAME is not None :

Tgt:  if lang_code is not None :
Pred: if lang_code is not None :
==================
NL:get the value under the lang_code key of the LANG_INFO dictionary , return it .
Tgt:  return NAME [ NAME ]
Pred: return NAME [ NAME ]

Tgt:  return LANG_INFO [ lang_code ]
Pred: return LANG_INFO [ lang_code ]
==================
NL:call the function ugettext with an argument msg_with_ctxt , substitute the result for result .
Tgt:  NAME = NAME ( NAME )
Pred: NAME = NAME ( NAME )

Tgt:  result = ugettext ( msg_with_ctxt )
Pred: result = ugettext ( msg_with_ctxt )
==================
NL:strip message_context of _STR:0_ characters from both ends , substitute the result for message_context .
Tgt:  NAME = NAME . NAME ( STRING )
Pred: NAME = NAME . NAME ( STRING )

Tgt:  message_context = message_context . strip ( <[> _STR:0_ <]> )
Pred: message_context = message_context . strip ( <[> _STR:0_ <]> )
==================
NL:define the method __getattr__ with 2 arguments : self and real_name .
Tgt:  def NAME ( NAME , NAME ) :
Pred: def NAME ( NAME , NAME ) :

Tgt:  def __getattr__ ( self , real_name ) :
Pred: def __getattr__ ( self , real_name ) :
==================
NL:contextlib.contextmanager [ contextlib . contextmanager ] decorator ,
Tgt:  @ NAME . NAME
Pred: @ NAME . NAME

Tgt:  @ contextlib . contextmanager
Pred: @ contextlib . contextmanager
==================
NL:filemsg is an empty string .
Tgt:  NAME = STRING
Pred: NAME = STRING

Tgt:  filemsg = <[>  <]>
Pred: filemsg = <[>  <]>
==================
NL:call the function ungettext with 3 arguments : singular , plural and number , substitute the result for result .
Tgt:  NAME = NAME ( NAME , NAME , NAME )
Pred: NAME = NAME ( NAME , NAME , NAME )

Tgt:  result = ungettext ( singular , plural , number )
Pred: result = ungettext ( singular , plural , number )
==================
NL:call the function lazy with 2 arguments : _string_concat and six.text_type [ six . text_type ] , substitute the result for string_concat .
Tgt:  NAME = NAME ( NAME , NAME . NAME )
Pred: NAME = NAME ( NAME , NAME . NAME )

Tgt:  string_concat = lazy ( _string_concat , six . text_type )
Pred: string_concat = lazy ( _string_concat , six . text_type )
==================
NL:if not ,
Tgt:  else :
Pred: else :

Tgt:  else :
Pred: else :
==================
NL:return a string _STR:0_ .
Tgt:  return STRING
Pred: return STRING

Tgt:  return <[> _STR:0_ <]>
Pred: return <[> _STR:0_ <]>
==================
NL:yield line .
Tgt:  yield NAME
Pred: yield NAME

Tgt:  yield line
Pred: yield line
==================
NL:if settings.USE_TZ [ settings . USE_TZ ] is true ,
Tgt:  if NAME . NAME :
Pred: if NAME . NAME :

Tgt:  if settings . USE_TZ :
Pred: if settings . USE_TZ :
==================
NL:call the function get_git_changeset , store the result in git_changeset .
Tgt:  NAME = NAME ( )
Pred: NAME = NAME ( )

Tgt:  git_changeset = get_git_changeset ( )
Pred: git_changeset = get_git_changeset ( )
==================
NL:increment self.active_readers [ self . active_readers ] by t .
Tgt:  NAME . NAME += NAME
Pred: NAME . NAME += NAME

Tgt:  self . active_readers += t
Pred: self . active_readers += t
==================
NL:define the method writer_leaves with an argument self .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def writer_leaves ( self ) :
Pred: def writer_leaves ( self ) :
==================
NL:return None .
Tgt:  return None
Pred: return None

Tgt:  return None
Pred: return None
==================
NL:if inplural is true ,
Tgt:  if NAME :
Pred: if NAME :

Tgt:  if inplural :
Pred: if inplural :
==================
NL:if LookupError exception is caught ,
Tgt:  except NAME :
Pred: except NAME :

Tgt:  except LookupError :
Pred: except LookupError :
==================
NL:incomment is boolean False .
Tgt:  NAME = False
Pred: NAME = False

Tgt:  incomment = False
Pred: incomment = False
==================
NL:if end is None
Tgt:  if NAME is None :
Pred: if NAME is None :

Tgt:  if end is None :
Pred: if end is None :
==================
NL:return a string _STR:0_ , where ' % s ' is replaced with self.__language [ self . __language ] .
Tgt:  return STRING % NAME . NAME
Pred: return STRING % NAME . NAME

Tgt:  return <[> _STR:0_ <]> % self . __language
Pred: return <[> _STR:0_ <]> % self . __language
==================
NL:if priority is true ,
Tgt:  if NAME :
Pred: if NAME :

Tgt:  if priority :
Pred: if priority :
==================
NL:if not ,
Tgt:  else :
Pred: else :

Tgt:  else :
Pred: else :
==================
NL:call the method sys._getframe [ sys . _getframe ] with an argument 1 , substitute the result for frame .
Tgt:  NAME = NAME . NAME ( NUMBER )
Pred: NAME = NAME . NAME ( NUMBER )

Tgt:  frame = sys . _getframe ( 1 )
Pred: frame = sys . _getframe ( 1 )
==================
NL:call the function self._new_gnu_trans [ self . _new_gnu_trans ] with 2 arguments : localedir and use_null_fallback , substitute the result for translation .
Tgt:  NAME = NAME . NAME ( NAME , NAME )
Pred: NAME = NAME . NAME ( NAME , NAME )

Tgt:  translation = self . _new_gnu_trans ( localedir , use_null_fallback )
Pred: translation = self . _new_gnu_trans ( localedir , use_null_fallback )
==================
NL:substitute lineno for translators_comment_start .
Tgt:  NAME = NAME
Pred: NAME = NAME

Tgt:  translators_comment_start = lineno
Pred: translators_comment_start = lineno
==================
NL:_iterkeys is a string _STR:0_ .
Tgt:  NAME = STRING
Pred: NAME = STRING

Tgt:  _iterkeys = <[> _STR:0_ <]>
Pred: _iterkeys = <[> _STR:0_ <]>
==================
NL:if TypeError exception is caught ,
Tgt:  except NAME :
Pred: except NAME :

Tgt:  except TypeError :
Pred: except TypeError :
==================
NL:call the method unicodedata.combining [ unicodedata . combining ] with an argument char , if it evaluates to false ,
Tgt:  if not NAME . NAME ( NAME ) :
Pred: if not NAME . NAME ( NAME ) :

Tgt:  if not unicodedata . combining ( char ) :
Pred: if not unicodedata . combining ( char ) :
==================
NL:call the function force_text with an argument text , substitute the result for text .
Tgt:  NAME = NAME ( NAME )
Pred: NAME = NAME ( NAME )

Tgt:  text = force_text ( text )
Pred: text = force_text ( text )
==================
NL:_func_defaults is a string _STR:0_ .
Tgt:  NAME = STRING
Pred: NAME = STRING

Tgt:  _func_defaults = <[> _STR:0_ <]>
Pred: _func_defaults = <[> _STR:0_ <]>
==================
NL:decrement self.active_readers [ self . active_readers ] by integer 1 ,
Tgt:  NAME . NAME -= NUMBER
Pred: NAME . NAME -= NUMBER

Tgt:  self . active_readers -= 1
Pred: self . active_readers -= 1
==================
NL:if ImportError exception is caught ,
Tgt:  except NAME :
Pred: except NAME :

Tgt:  except ImportError :
Pred: except ImportError :
==================
NL:return settings.LANGUAGE_CODE [ settings . LANGUAGE_CODE ] .
Tgt:  return NAME . NAME
Pred: return NAME . NAME

Tgt:  return settings . LANGUAGE_CODE
Pred: return settings . LANGUAGE_CODE
==================
NL:call the method operator.attrgetter [ operator . attrgetter ] with an argument _meth_self , substitute the result for get_method_self .
Tgt:  NAME = NAME . NAME ( NAME )
Pred: NAME = NAME . NAME ( NAME )

Tgt:  get_method_self = operator . attrgetter ( _meth_self )
Pred: get_method_self = operator . attrgetter ( _meth_self )
==================
NL:otherwise if rhs is an instance of SafeBytes ,
Tgt:  elif isinstance ( NAME , NAME ) :
Pred: elif isinstance ( NAME , NAME ) :

Tgt:  elif isinstance ( rhs , SafeBytes ) :
Pred: elif isinstance ( rhs , SafeBytes ) :
==================
NL:want_unicode is boolean True .
Tgt:  NAME = True
Pred: NAME = True

Tgt:  want_unicode = True
Pred: want_unicode = True
==================
NL:derive the class TranslatorCommentWarning from the SyntaxWarning base class .
Tgt:  class NAME ( NAME ) :
Pred: class NAME ( NAME ) :

Tgt:  class TranslatorCommentWarning ( SyntaxWarning ) :
Pred: class TranslatorCommentWarning ( SyntaxWarning ) :
==================
NL:if not ,
Tgt:  else :
Pred: else :

Tgt:  else :
Pred: else :
==================
NL:from django.utils.timezone [ django . utils . timezone ] import is_aware and utc into default name space .
Tgt:  from NAME . NAME . NAME import NAME , NAME
Pred: from NAME . NAME . NAME import NAME , NAME

Tgt:  from django . utils . timezone import is_aware , utc
Pred: from django . utils . timezone import is_aware , utc
==================
NL:define the function reset_cache with an argument unpacked dictionary kwargs .
Tgt:  def NAME ( ** NAME ) :
Pred: def NAME ( ** NAME ) :

Tgt:  def reset_cache ( ** kwargs ) :
Pred: def reset_cache ( ** kwargs ) :
==================
NL:_assertRaisesRegex is a strnig _STR:0_ .
Tgt:  NAME = STRING
Pred: NAME = STRING

Tgt:  _assertRaisesRegex = <[> _STR:0_ <]>
Pred: _assertRaisesRegex = <[> _STR:0_ <]>
==================
NL:define the function parse_color_setting with an argument config_string .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def parse_color_setting ( config_string ) :
Pred: def parse_color_setting ( config_string ) :
==================
NL:break from the loop execution
Tgt:  NAME
Pred: NAME

Tgt:  break
Pred: break
==================
NL:if p is greater or equal to integer 0 ,
Tgt:  if NAME >= NUMBER :
Pred: if NAME >= NUMBER :

Tgt:  if p >= 0 :
Pred: if p >= 0 :
==================
NL:call the function unicodedata.combining [ unicodedata . combining ] with an argument char , if it evaluates to true ,
Tgt:  if NAME . NAME ( NAME ) :
Pred: if NAME . NAME ( NAME ) :

Tgt:  if unicodedata . combining ( char ) :
Pred: if unicodedata . combining ( char ) :
==================
NL:call the method check_for_language.cache_clear [ check_for_language . cache_clear ] .
Tgt:  NAME . NAME ( )
Pred: NAME . NAME ( )

Tgt:  check_for_language . cache_clear ( )
Pred: check_for_language . cache_clear ( )
==================
NL:define the function to_locale with an argument language .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def to_locale ( language ) :
Pred: def to_locale ( language ) :
==================
NL:_iterkeys is a string _STR:0_ .
Tgt:  NAME = STRING
Pred: NAME = STRING

Tgt:  _iterkeys = <[> _STR:0_ <]>
Pred: _iterkeys = <[> _STR:0_ <]>
==================
NL:call the function plural_re.match [ plural_re . match ] with an argument t.contents [ t . contents ] , substitute the result for pluralmatch .
Tgt:  NAME = NAME . NAME ( NAME . NAME )
Pred: NAME = NAME . NAME ( NAME . NAME )

Tgt:  pluralmatch = plural_re . match ( t . contents )
Pred: pluralmatch = plural_re . match ( t . contents )
==================
NL:if not ,
Tgt:  else :
Pred: else :

Tgt:  else :
Pred: else :
==================
NL:define the function ngettext with 3 arguments : singular , plural and number .
Tgt:  def NAME ( NAME , NAME , NAME ) :
Pred: def NAME ( NAME , NAME , NAME ) :

Tgt:  def ngettext ( singular , plural , number ) :
Pred: def ngettext ( singular , plural , number ) :
==================
NL:define the function unescape_entities with an argument text .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def unescape_entities ( text ) :
Pred: def unescape_entities ( text ) :
==================
NL:return changeset .
Tgt:  return NAME
Pred: return NAME

Tgt:  return changeset
Pred: return changeset
==================
NL:and unpacked dictionary kwargs , return the result . define the function assertRaisesRegex with 3 arguments : self , unpacked list args and unpacked dictionary kwargs .
Tgt:  def NAME ( NAME , * NAME , ** NAME ) :
Pred: def NAME ( NAME , * NAME , ** NAME ) :

Tgt:  def assertRaisesRegex ( self , * args , ** kwargs ) :
Pred: def assertRaisesRegex ( self , * args , ** kwargs ) :
==================
NL:if not ,
Tgt:  else :
Pred: else :

Tgt:  else :
Pred: else :
==================
NL:_STR:0_ , where ' % s ' is replaced with number . if not ,
Tgt:  else :
Pred: else :

Tgt:  else :
Pred: else :
==================
NL:return an empty list .
Tgt:  return [ ]
Pred: return [ ]

Tgt:  return [ ]
Pred: return [ ]
==================
NL:format with it a string _STR:0_ , write it to out . comment_lineno_cache is None ,
Tgt:  NAME = None
Pred: NAME = None

Tgt:  comment_lineno_cache = None
Pred: comment_lineno_cache = None
==================
NL:substitute chr for unichr .
Tgt:  unichr = chr
Pred: NAME = NAME

Tgt:  unichr = chr
Pred: unichr = chr
==================
NL:derive class _MovedItems from the _LazyModule base class .
Tgt:  class NAME ( NAME ) :
Pred: class NAME ( NAME ) :

Tgt:  class _MovedItems ( _LazyModule ) :
Pred: class _MovedItems ( _LazyModule ) :
==================
NL:if self.negated [ self . negated ] ,
Tgt:  if NAME . NAME :
Pred: if NAME . NAME :

Tgt:  if self . negated :
Pred: if self . negated :
==================
NL:call the method _isdst with an argument dt from the base class of the class LocalTimezone , return the result .
Tgt:  return super ( NAME , NAME ) . NAME ( NAME )
Pred: return super ( NAME , NAME ) . NAME ( NAME )

Tgt:  return super ( LocalTimezone , self ) . _isdst ( dt )
Pred: return super ( LocalTimezone , self ) . _isdst ( dt )
==================
NL:if not ,
Tgt:  else :
Pred: else :

Tgt:  else :
Pred: else :
==================
NL:call the function re.compile [ re . compile ] with an argument raw string _STR:0_ , substitute it for dot_re .
Tgt:  NAME = re . compile ( STRING )
Pred: NAME = re . compile ( STRING )

Tgt:  dot_re = re . compile ( <[> _STR:0_ <]> )
Pred: dot_re = re . compile ( <[> _STR:0_ <]> )
==================
NL:define the function _string_concat with an argument unpacked list strings .
Tgt:  def NAME ( * NAME ) :
Pred: def NAME ( * NAME ) :

Tgt:  def _string_concat ( * strings ) :
Pred: def _string_concat ( * strings ) :
==================
NL:if timezone is None ,
Tgt:  if NAME is None :
Pred: if NAME is None :

Tgt:  if timezone is None :
Pred: if timezone is None :
==================
NL:substitute memoryview for memoryview .
Tgt:  memoryview = memoryview
Pred: NAME = NAME

Tgt:  memoryview = memoryview
Pred: memoryview = memoryview
==================
NL:define the function check_for_language with an argument lang_code .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def check_for_language ( lang_code ) :
Pred: def check_for_language ( lang_code ) :
==================
NL:break from the loop execution ,
Tgt:  NAME
Pred: NAME

Tgt:  break
Pred: break
==================
NL:do nothing .
Tgt:  NAME
Pred: NAME

Tgt:  pass
Pred: pass
==================
NL:call the function block_re.match [ block_re . match ] with an argument t.contents [ t . contents ] , substitute the result for bmatch .
Tgt:  NAME = NAME . NAME ( NAME . NAME )
Pred: NAME = NAME . NAME ( NAME . NAME )

Tgt:  bmatch = block_re . match ( t . contents )
Pred: bmatch = block_re . match ( t . contents )
==================
NL:define the method utcoffset with 2 arguments self and dt .
Tgt:  def NAME ( NAME , NAME ) :
Pred: def NAME ( NAME , NAME ) :

Tgt:  def utcoffset ( self , dt ) :
Pred: def utcoffset ( self , dt ) :
==================
NL:assign the result to the value under the string _STR:0_ appended to __name__ key of the sys.modules [ sys . modules ] dictionary , and to the value under the string _STR:1_ appended to __name__ key of the sys.modules [ sys . modules ] dictionary . derive class Module_six_moves_urllib_request from the _LazyModule base class .
Tgt:  class NAME ( NAME ) :
Pred: class NAME ( NAME ) :

Tgt:  class Module_six_moves_urllib_request ( _LazyModule ) :
Pred: class Module_six_moves_urllib_request ( _LazyModule ) :
==================
NL:define the method _resolve with an argument self .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def _resolve ( self ) :
Pred: def _resolve ( self ) :
==================
NL:if kwargs is true ,
Tgt:  if NAME :
Pred: if NAME :

Tgt:  if kwargs :
Pred: if kwargs :
==================
NL:import module datetime .
Tgt:  import NAME
Pred: import NAME

Tgt:  import datetime
Pred: import datetime
==================
NL:substitute deactivate for self.deactivate [ self . deactivate ] .
Tgt:  NAME . NAME = NAME
Pred: NAME . NAME = NAME

Tgt:  self . deactivate = deactivate
Pred: self . deactivate = deactivate
==================
NL:do nothing .
Tgt:  NAME
Pred: NAME

Tgt:  pass
Pred: pass
==================
NL:_supported is None .
Tgt:  NAME = None
Pred: NAME = None

Tgt:  _supported = None
Pred: _supported = None
==================
NL:from django.utils.six.moves [ django . utils . six . moves ] import html_entities into default name space .
Tgt:  from NAME . NAME . NAME . NAME import NAME
Pred: from NAME . NAME . NAME . NAME import NAME

Tgt:  from django . utils . six . moves import html_entities
Pred: from django . utils . six . moves import html_entities
==================
NL:to_locale called with an argument lang_code , if the result is not None , return boolean True .
Tgt:  return True
Pred: return True

Tgt:  return True
Pred: return True
==================
NL:for every code in tuple with 2 elements : lang_code and generic_lang_code ,
Tgt:  for NAME in ( NAME , NAME ) :
Pred: for NAME in ( NAME , NAME ) :

Tgt:  for code in ( lang_code , generic_lang_code ) :
Pred: for code in ( lang_code , generic_lang_code ) :
==================
NL:define the function with_metaclass with 2 arguments meta and unpacked list bases .
Tgt:  def NAME ( NAME , * NAME ) :
Pred: def NAME ( NAME , * NAME ) :

Tgt:  def with_metaclass ( meta , * bases ) :
Pred: def with_metaclass ( meta , * bases ) :
==================
NL:if offset is smaller than integer 0 , sign is _STR:0_ , otherwise sign is _STR:1_ .
Tgt:  NAME = STRING if NAME < NUMBER else STRING
Pred: NAME = STRING if NAME < NUMBER else STRING

Tgt:  sign = <[> _STR:0_ <]> if offset < 0 else <[> _STR:1_ <]>
Pred: sign = <[> _STR:0_ <]> if offset < 0 else <[> _STR:1_ <]>
==================
NL:try ,
Tgt:  try :
Pred: try :

Tgt:  try :
Pred: try :
==================
NL:define the function compress_string with an argument s .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def compress_string ( s ) :
Pred: def compress_string ( s ) :
==================
NL:return message .
Tgt:  return NAME
Pred: return NAME

Tgt:  return message
Pred: return message
==================
NL:from xml.sax.saxutils [ xml . sax . saxutils ] import XMLGenerator into default name space .
Tgt:  from NAME . NAME . NAME import NAME
Pred: from NAME . NAME . NAME import NAME

Tgt:  from xml . sax . saxutils import XMLGenerator
Pred: from xml . sax . saxutils import XMLGenerator
==================
NL:buffer_types is a tuple with 2 elements bytearray and memoryview .
Tgt:  NAME = ( bytearray , memoryview )
Pred: NAME = ( NAME , NAME )

Tgt:  buffer_types = ( bytearray , memoryview )
Pred: buffer_types = ( bytearray , memoryview )
==================
NL:define the method __html__ with an argument self .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def __html__ ( self ) :
Pred: def __html__ ( self ) :
==================
NL:return the length of self.children [ self . children ] .
Tgt:  return len ( NAME . NAME )
Pred: return len ( NAME . NAME )

Tgt:  return len ( self . children )
Pred: return len ( self . children )
==================
NL:contextlib.contextmanager [ contextlib . contextmanager ] decorator ,
Tgt:  @ NAME . NAME
Pred: @ NAME . NAME

Tgt:  @ contextlib . contextmanager
Pred: @ contextlib . contextmanager
==================
NL:define the function get_language .
Tgt:  def NAME ( ) :
Pred: def NAME ( ) :

Tgt:  def get_language ( ) :
Pred: def get_language ( ) :
==================
NL:from django.conf [ django . conf ] import settings into default name space .
Tgt:  from NAME . NAME import NAME
Pred: from NAME . NAME import NAME

Tgt:  from django . conf import settings
Pred: from django . conf import settings
==================
NL:from threading import local into default name space .
Tgt:  from NAME import NAME
Pred: from NAME import NAME

Tgt:  from threading import local
Pred: from threading import local
==================
NL:if string _STR:0_ is not contained in opts ,
Tgt:  if STRING not in NAME :
Pred: if STRING not in NAME :

Tgt:  if <[> _STR:0_ <]> not in opts :
Pred: if <[> _STR:0_ <]> not in opts :
==================
NL:define the method __init__ with an argument self .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def __init__ ( self ) :
Pred: def __init__ ( self ) :
==================
NL:from django.utils.functional [ django . utils . functional ] import allow_lazy and SimpleLazyObject into default name space .
Tgt:  from NAME . NAME . NAME import NAME , NAME
Pred: from NAME . NAME . NAME import NAME , NAME

Tgt:  from django . utils . functional import allow_lazy , SimpleLazyObject
Pred: from django . utils . functional import allow_lazy , SimpleLazyObject
==================
NL:substitute the result for language_code_re . call the function re.compile [ re . compile ] with an argument raw string _STR:0_ , substitute the result for language_code_prefix_re .
Tgt:  NAME = re . compile ( STRING )
Pred: NAME = re . compile ( STRING )

Tgt:  language_code_prefix_re = re . compile ( <[> _STR:0_ <]> )
Pred: language_code_prefix_re = re . compile ( <[> _STR:0_ <]> )
==================
NL:and fileobj set to buf . read data from buf file stream , yield the result .
Tgt:  yield NAME . NAME ( )
Pred: yield NAME . NAME ( )

Tgt:  yield buf . read ( )
Pred: yield buf . read ( )
==================
NL:call the method _time.localtime [ _time . localtime ] with an argument stamp , substitute the result for tt .
Tgt:  NAME = NAME . NAME ( NAME )
Pred: NAME = NAME . NAME ( NAME )

Tgt:  tt = _time . localtime ( stamp )
Pred: tt = _time . localtime ( stamp )
==================
NL:substitute first element of s for quote .
Tgt:  NAME = NAME [ NUMBER ]
Pred: NAME = NAME [ NUMBER ]

Tgt:  quote = s [ 0 ]
Pred: quote = s [ 0 ]
==================
NL:define the method __repr__ with an argument self .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def __repr__ ( self ) :
Pred: def __repr__ ( self ) :
==================
NL:return boolean False .
Tgt:  return False
Pred: return False

Tgt:  return False
Pred: return False
==================
NL:re.U [ re . U ] and re.S [ re . S ] , substitute the result for re_chars . call the function re.compile [ re . compile ] with an argument raw string _STR:0_ , substitute the result for re_newlines .
Tgt:  NAME = re . compile ( STRING )
Pred: NAME = re . compile ( STRING )

Tgt:  re_newlines = re . compile ( <[> _STR:0_ <]> )
Pred: re_newlines = re . compile ( <[> _STR:0_ <]> )
==================
NL:define the method ugettext with an argument message .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def ugettext ( message ) :
Pred: def ugettext ( message ) :
==================
NL:append value under the key v of background dictionary to code_list .
Tgt:  NAME . NAME ( NAME [ NAME ] )
Pred: NAME . NAME ( NAME [ NAME ] )

Tgt:  code_list . append ( background [ v ] )
Pred: code_list . append ( background [ v ] )
==================
NL:format string _STR:0_ , with fmatch , write it to out .
Tgt:  NAME . NAME ( STRING % NAME )
Pred: NAME . NAME ( STRING % NAME )

Tgt:  out . write ( <[> _STR:0_ <]> % fmatch )
Pred: out . write ( <[> _STR:0_ <]> % fmatch )
==================
NL:substitute timezone for self.timezone [ self . timezone ] .
Tgt:  NAME . NAME = NAME
Pred: NAME . NAME = NAME

Tgt:  self . timezone = timezone
Pred: self . timezone = timezone
==================
NL:skip this loop iteration .
Tgt:  NAME
Pred: NAME

Tgt:  continue
Pred: continue
==================
NL:if version is None ,
Tgt:  if NAME is None :
Pred: if NAME is None :

Tgt:  if version is None :
Pred: if version is None :
==================
NL:break from the loop execution .
Tgt:  NAME
Pred: NAME

Tgt:  break
Pred: break
==================
NL:call the method zbuf.getvalue [ zbuf . getvalue ] , return the result .
Tgt:  return NAME . NAME ( )
Pred: return NAME . NAME ( )

Tgt:  return zbuf . getvalue ( )
Pred: return zbuf . getvalue ( )
==================
NL:call the function translation with an argument settings.LANGUAGE_CODE [ settings . LANGUAGE_CODE ] , substitute the result for _default .
Tgt:  NAME = NAME ( NAME . NAME )
Pred: NAME = NAME ( NAME . NAME )

Tgt:  _default = translation ( settings . LANGUAGE_CODE )
Pred: _default = translation ( settings . LANGUAGE_CODE )
==================
NL:define the function phone2numeric with an argument phone .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def phone2numeric ( phone ) :
Pred: def phone2numeric ( phone ) :
==================
NL:if not ,
Tgt:  else :
Pred: else :

Tgt:  else :
Pred: else :
==================
NL:if OverflowError exception is caught ,
Tgt:  except NAME :
Pred: except NAME :

Tgt:  except OverflowError :
Pred: except OverflowError :
==================
NL:define the method __init__ with 3 arguments : self , language and deactivate set to boolean False .
Tgt:  def NAME ( NAME , NAME , NAME = False ) :
Pred: def NAME ( NAME , NAME , NAME = False ) :

Tgt:  def __init__ ( self , language , deactivate = False ) :
Pred: def __init__ ( self , language , deactivate = False ) :
==================
NL:from django.utils.encoding [ django . utils . encoding ] import force_unicode .
Tgt:  from NAME . NAME . NAME import NAME
Pred: from NAME . NAME . NAME import NAME

Tgt:  from django . utils . encoding import force_unicode
Pred: from django . utils . encoding import force_unicode
==================
NL:convert num to an integer , substitute it for length .
Tgt:  NAME = int ( NAME )
Pred: NAME = int ( NAME )

Tgt:  length = int ( num )
Pred: length = int ( num )
==================
NL:call the function mark_safe with an argument message , return the result .
Tgt:  return NAME ( NAME )
Pred: return NAME ( NAME )

Tgt:  return mark_safe ( message )
Pred: return mark_safe ( message )
==================
NL:define the method _proxy_method with 3 arguments self , unpacked list args and unpacked dictionary kwargs .
Tgt:  def NAME ( NAME , * NAME , ** NAME ) :
Pred: def NAME ( NAME , * NAME , ** NAME ) :

Tgt:  def _proxy_method ( self , * args , ** kwargs ) :
Pred: def _proxy_method ( self , * args , ** kwargs ) :
==================
NL:use global variable _default .
Tgt:  global NAME
Pred: global NAME

Tgt:  global _default
Pred: global _default
==================
NL:return data .
Tgt:  return NAME
Pred: return NAME

Tgt:  return data
Pred: return data
==================
NL:return the value under the is_dst key of the _time.tzname [ _time . tzname ] dictionary .
Tgt:  return NAME . NAME [ NAME ]
Pred: return NAME . NAME [ NAME ]

Tgt:  return _time . tzname [ is_dst ]
Pred: return _time . tzname [ is_dst ]
==================
NL:if t is not None ,
Tgt:  if NAME is not None :
Pred: if NAME is not None :

Tgt:  if t is not None :
Pred: if t is not None :
==================
NL:call the function to_language with an argument language , substitute it for self.__to_language [ self . __to_language ] .
Tgt:  NAME . NAME = NAME ( NAME )
Pred: NAME . NAME = NAME ( NAME )

Tgt:  self . __to_language = to_language ( language )
Pred: self . __to_language = to_language ( language )
==================
NL:_assertRegex is a strnig _STR:0_ .
Tgt:  NAME = STRING
Pred: NAME = STRING

Tgt:  _assertRegex = <[> _STR:0_ <]>
Pred: _assertRegex = <[> _STR:0_ <]>
==================
NL:if not ,
Tgt:  else :
Pred: else :

Tgt:  else :
Pred: else :
==================
NL:define the method _init_translation_catalog with an argument self .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def _init_translation_catalog ( self ) :
Pred: def _init_translation_catalog ( self ) :
==================
NL:if other is contained in self.children [ self . children ] , return boolean True , otherwise return boolean False .
Tgt:  return NAME in NAME . NAME
Pred: return NAME in NAME . NAME

Tgt:  return other in self . children
Pred: return other in self . children
==================
NL:_assertCountEqual is a strnig _STR:0_ .
Tgt:  NAME = STRING
Pred: NAME = STRING

Tgt:  _assertCountEqual = <[> _STR:0_ <]>
Pred: _assertCountEqual = <[> _STR:0_ <]>
==================
NL:return settings.LANGUAGE_CODE [ settings . LANGUAGE_CODE ] .
Tgt:  return NAME . NAME
Pred: return NAME . NAME

Tgt:  return settings . LANGUAGE_CODE
Pred: return settings . LANGUAGE_CODE
==================
NL:derive the class SafeData from object base class .
Tgt:  class NAME ( object ) :
Pred: class NAME ( object ) :

Tgt:  class SafeData ( object ) :
Pred: class SafeData ( object ) :
==================
NL:if first element of sys.version_info [ sys . version_info ] equals integer 3 , PY3 is boolean True , otherwise it is boolean False .
Tgt:  NAME = NAME . NAME [ NUMBER ] == NUMBER
Pred: NAME = NAME . NAME [ NUMBER ] == NUMBER

Tgt:  PY3 = sys . version_info [ 0 ] == 3
Pred: PY3 = sys . version_info [ 0 ] == 3
==================
NL:return data .
Tgt:  return NAME
Pred: return NAME

Tgt:  return data
Pred: return data
==================
NL:if not ,
Tgt:  else :
Pred: else :

Tgt:  else :
Pred: else :
==================
NL:call the method __init__ with an argument name form the base class of the class _LazyModule .
Tgt:  super ( NAME , NAME ) . NAME ( NAME )
Pred: super ( NAME , NAME ) . NAME ( NAME )

Tgt:  super ( _LazyModule , self ) . __init__ ( name )
Pred: super ( _LazyModule , self ) . __init__ ( name )
==================
NL:want_unicode is boolean True .
Tgt:  NAME = True
Pred: NAME = True

Tgt:  want_unicode = True
Pred: want_unicode = True
==================
NL:call the function six.reraise [ six . reraise ] with 3 arguments : exc_type , exc_value and third element of the result of the method sys.exc_info [ sys . exc_info ] .
Tgt:  NAME . NAME ( NAME , NAME , NAME . NAME ( ) [ NUMBER ] )
Pred: NAME . NAME ( NAME , NAME , NAME . NAME ( ) [ NUMBER ] )

Tgt:  six . reraise ( exc_type , exc_value , sys . exc_info ( ) [ 2 ] )
Pred: six . reraise ( exc_type , exc_value , sys . exc_info ( ) [ 2 ] )
==================
NL:_assertRegex is a strnig _STR:0_ .
Tgt:  NAME = STRING
Pred: NAME = STRING

Tgt:  _assertRegex = <[> _STR:0_ <]>
Pred: _assertRegex = <[> _STR:0_ <]>
==================
NL:_supported is an instance of OrderedDict class , created with an argument settings.LANGUAGES [ settings . LANGUAGES ] .
Tgt:  NAME = NAME ( NAME . NAME )
Pred: NAME = NAME ( NAME . NAME )

Tgt:  _supported = OrderedDict ( settings . LANGUAGES )
Pred: _supported = OrderedDict ( settings . LANGUAGES )
==================
NL:extend self.children [ self . children ] list with data.children [ data . children ] .
Tgt:  NAME . NAME . NAME ( NAME . NAME )
Pred: NAME . NAME . NAME ( NAME . NAME )

Tgt:  self . children . extend ( data . children )
Pred: self . children . extend ( data . children )
==================
NL:if CONTEXT_SEPARATOR is contained in result ,
Tgt:  if NAME in NAME :
Pred: if NAME in NAME :

Tgt:  if CONTEXT_SEPARATOR in result :
Pred: if CONTEXT_SEPARATOR in result :
==================
NL:substitute SafeText for SafeString .
Tgt:  NAME = NAME
Pred: NAME = NAME

Tgt:  SafeString = SafeText
Pred: SafeString = SafeText
==================
NL:define the method __init__ with 2 arguments : self and timezone .
Tgt:  def NAME ( NAME , NAME ) :
Pred: def NAME ( NAME , NAME ) :

Tgt:  def __init__ ( self , timezone ) :
Pred: def __init__ ( self , timezone ) :
==================
NL:return string _STR:0_ , formated with self.__class__.__name__ [ self . __class__ . __name__ ] and self .
Tgt:  return STRING % ( NAME . NAME . NAME , NAME )
Pred: return STRING % ( NAME . NAME . NAME , NAME )

Tgt:  return <[> _STR:0_ <]> % ( self . __class__ . __name__ , self )
Pred: return <[> _STR:0_ <]> % ( self . __class__ . __name__ , self )
==================
NL:if t is not None ,
Tgt:  if NAME is not None :
Pred: if NAME is not None :

Tgt:  if t is not None :
Pred: if t is not None :
==================
NL:and placed into 2 character spaces , and _STR:0_ is replaced with reminder of the division of absolute offset by integer 60 , and placed into 2 character spaces . define the method __repr__ with an argument self .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def __repr__ ( self ) :
Pred: def __repr__ ( self ) :
==================
NL:call the function lazy with 2 arguments : pgettext and six.text_type [ six . text_type ] , substitute pgettext_lazy .
Tgt:  NAME = NAME ( NAME , NAME . NAME )
Pred: NAME = NAME ( NAME , NAME . NAME )

Tgt:  pgettext_lazy = lazy ( pgettext , six . text_type )
Pred: pgettext_lazy = lazy ( pgettext , six . text_type )
==================
NL:return plural .
Tgt:  return NAME
Pred: return NAME

Tgt:  return plural
Pred: return plural
==================
NL:call the function get_supported_language_variant with an argument settings.LANGUAGE_CODE [ settings . LANGUAGE_CODE ] , return the result .
Tgt:  return NAME ( NAME . NAME )
Pred: return NAME ( NAME . NAME )

Tgt:  return get_supported_language_variant ( settings . LANGUAGE_CODE )
Pred: return get_supported_language_variant ( settings . LANGUAGE_CODE )
==================
NL:if rhs is an instance of SafeData .
Tgt:  if isinstance ( NAME , NAME ) :
Pred: if isinstance ( NAME , NAME ) :

Tgt:  if isinstance ( rhs , SafeData ) :
Pred: if isinstance ( rhs , SafeData ) :
==================
NL:comment is an empty list .
Tgt:  NAME = [ ]
Pred: NAME = [ ]

Tgt:  comment = [ ]
Pred: comment = [ ]
==================
NL:define the method dst with 2 arguments self and dt .
Tgt:  def NAME ( NAME , NAME ) :
Pred: def NAME ( NAME , NAME ) :

Tgt:  def dst ( self , dt ) :
Pred: def dst ( self , dt ) :
==================
NL:if first is true ,
Tgt:  if NAME :
Pred: if NAME :

Tgt:  if first :
Pred: if first :
==================
NL:if not ,
Tgt:  else :
Pred: else :

Tgt:  else :
Pred: else :
==================
NL:if html is true ,
Tgt:  if NAME :
Pred: if NAME :

Tgt:  if html :
Pred: if html :
==================
NL:return an instance of SafeBytes , created with an argument t .
Tgt:  return NAME ( NAME )
Pred: return NAME ( NAME )

Tgt:  return SafeBytes ( t )
Pred: return SafeBytes ( t )
==================
NL:define the method tzname with 2 arguments : self and dt .
Tgt:  def NAME ( NAME , NAME ) :
Pred: def NAME ( NAME , NAME ) :

Tgt:  def tzname ( self , dt ) :
Pred: def tzname ( self , dt ) :
==================
NL:return wrapper .
Tgt:  return NAME
Pred: return NAME

Tgt:  return wrapper
Pred: return wrapper
==================
NL:otherwise if t.contents [ t . contents ] equals a string _STR:0_ ,
Tgt:  elif NAME . NAME == STRING :
Pred: elif NAME . NAME == STRING :

Tgt:  elif t . contents == <[> _STR:0_ <]> :
Pred: elif t . contents == <[> _STR:0_ <]> :
==================
NL:from django.conf [ django . conf ] import settings .
Tgt:  from NAME . NAME import NAME
Pred: from NAME . NAME import NAME

Tgt:  from django . conf import settings
Pred: from django . conf import settings
==================
NL:delete attr .
Tgt:  del NAME
Pred: del NAME

Tgt:  del attr
Pred: del attr
==================
NL:do nothing .
Tgt:  NAME
Pred: NAME

Tgt:  pass
Pred: pass
==================
NL:define the method words with 4 arguments : self , num , truncate set to None , html set to boolean False .
Tgt:  def NAME ( NAME , NAME , NAME = None , NAME = False ) :
Pred: def NAME ( NAME , NAME , NAME = None , NAME = False ) :

Tgt:  def words ( self , num , truncate = None , html = False ) :
Pred: def words ( self , num , truncate = None , html = False ) :
==================
NL:define the function ugettext with an argument message .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def ugettext ( message ) :
Pred: def ugettext ( message ) :
==================
NL:convert text to an integer , substitute it for c .
Tgt:  NAME = int ( NAME )
Pred: NAME = int ( NAME )

Tgt:  c = int ( text )
Pred: c = int ( text )
==================
NL:define the function normalize_newlines with an argument text .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def normalize_newlines ( text ) :
Pred: def normalize_newlines ( text ) :
==================
NL:convert language to lowercase and return it .
Tgt:  return NAME . NAME ( )
Pred: return NAME . NAME ( )

Tgt:  return language . lower ( )
Pred: return language . lower ( )
==================
NL:try ,
Tgt:  try :
Pred: try :

Tgt:  try :
Pred: try :
==================
NL:return ZERO .
Tgt:  return NAME
Pred: return NAME

Tgt:  return ZERO
Pred: return ZERO
==================
NL:yield line .
Tgt:  yield NAME
Pred: yield NAME

Tgt:  yield line
Pred: yield line
==================
NL:return t .
Tgt:  return NAME
Pred: return NAME

Tgt:  return t
Pred: return t
==================
NL:append value under the key v of foreground dictionary to code_list .
Tgt:  NAME . NAME ( NAME [ NAME ] )
Pred: NAME . NAME ( NAME [ NAME ] )

Tgt:  code_list . append ( foreground [ v ] )
Pred: code_list . append ( foreground [ v ] )
==================
NL:define the method __init__ with 4 arguments : self , name , old and new set to None .
Tgt:  def NAME ( NAME , NAME , NAME , NAME = None ) :
Pred: def NAME ( NAME , NAME , NAME , NAME = None ) :

Tgt:  def __init__ ( self , name , old , new = None ) :
Pred: def __init__ ( self , name , old , new = None ) :
==================
NL:substitute string _STR:0_ for space .
Tgt:  NAME = STRING
Pred: NAME = STRING

Tgt:  space = <[> _STR:0_ <]>
Pred: space = <[> _STR:0_ <]>
==================
NL:try ,
Tgt:  try :
Pred: try :

Tgt:  try :
Pred: try :
==================
NL:return nothing .
Tgt:  NAME
Pred: NAME

Tgt:  return
Pred: return
==================
NL:if string _STR:0_ is contained in truncate ,
Tgt:  if STRING in NAME :
Pred: if STRING in NAME :

Tgt:  if <[> _STR:0_ <]> in truncate :
Pred: if <[> _STR:0_ <]> in truncate :
==================
NL:replace every occurrence of _STR:0_ in s with _STR:1_ .
Tgt:  NAME = NAME . NAME ( STRING , STRING )
Pred: NAME = NAME . NAME ( STRING , STRING )

Tgt:  s = s . replace ( <[> _STR:0_ <]> , <[> _STR:1_ <]> )
Pred: s = s . replace ( <[> _STR:0_ <]> , <[> _STR:1_ <]> )
==================
NL:define the method __init__ with 2 arguments : self and name .
Tgt:  def NAME ( NAME , NAME ) :
Pred: def NAME ( NAME , NAME ) :

Tgt:  def __init__ ( self , name ) :
Pred: def __init__ ( self , name ) :
==================
NL:if new_attr is None ,
Tgt:  if NAME is None :
Pred: if NAME is None :

Tgt:  if new_attr is None :
Pred: if new_attr is None :
==================
NL:_itervalues is a string _STR:0_ .
Tgt:  NAME = STRING
Pred: NAME = STRING

Tgt:  _itervalues = <[> _STR:0_ <]>
Pred: _itervalues = <[> _STR:0_ <]>
==================
NL:use global variable _default .
Tgt:  global NAME
Pred: global NAME

Tgt:  global _default
Pred: global _default
==================
NL:if not ,
Tgt:  else :
Pred: else :

Tgt:  else :
Pred: else :
==================
NL:from django.utils [ django . utils ] import six into default name space .
Tgt:  from NAME . NAME import NAME
Pred: from NAME . NAME import NAME

Tgt:  from django . utils import six
Pred: from django . utils import six
==================
NL:define the function do_translate with 2 arguments : message and translation_function .
Tgt:  def NAME ( NAME , NAME ) :
Pred: def NAME ( NAME , NAME ) :

Tgt:  def do_translate ( message , translation_function ) :
Pred: def do_translate ( message , translation_function ) :
==================
NL:from django.utils.encoding [ django . utils . encoding ] import force_text into default name space .
Tgt:  from NAME . NAME . NAME import NAME
Pred: from NAME . NAME . NAME import NAME

Tgt:  from django . utils . encoding import force_text
Pred: from django . utils . encoding import force_text
==================
NL:define the function get_current_timezone .
Tgt:  def NAME ( ) :
Pred: def NAME ( ) :

Tgt:  def get_current_timezone ( ) :
Pred: def get_current_timezone ( ) :
==================
NL:otherwise if _STR:0_ is contained in part ,
Tgt:  elif STRING in NAME :
Pred: elif STRING in NAME :

Tgt:  elif <[> _STR:0_ <]> in part :
Pred: elif <[> _STR:0_ <]> in part :
==================
NL:filemsg is a string _STR:0_ , where ' % s ' is replaced with origin .
Tgt:  NAME = STRING % NAME
Pred: NAME = STRING % NAME

Tgt:  filemsg = <[> _STR:0_ <]> % origin
Pred: filemsg = <[> _STR:0_ <]> % origin
==================
NL:if not ,
Tgt:  else :
Pred: else :

Tgt:  else :
Pred: else :
==================
NL:define the function gettext with an argument message .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def gettext ( message ) :
Pred: def gettext ( message ) :
==================
NL:if new_mod is None ,
Tgt:  if NAME is None :
Pred: if NAME is None :

Tgt:  if new_mod is None :
Pred: if new_mod is None :
==================
NL:if not ,
Tgt:  else :
Pred: else :

Tgt:  else :
Pred: else :
==================
NL:delete _active.value [ _active . value ] .
Tgt:  del NAME . NAME
Pred: del NAME . NAME

Tgt:  del _active . value
Pred: del _active . value
==================
NL:otherwise if bmatch is true ,
Tgt:  elif NAME :
Pred: elif NAME :

Tgt:  elif bmatch :
Pred: elif bmatch :
==================
NL:call the method bit.group [ bit . group ] with an argument integer 0 , yield the result .
Tgt:  yield NAME . NAME ( NUMBER )
Pred: yield NAME . NAME ( NUMBER )

Tgt:  yield bit . group ( 0 )
Pred: yield bit . group ( 0 )
==================
NL:if _globs_ is None ,
Tgt:  if NAME is None :
Pred: if NAME is None :

Tgt:  if _globs_ is None :
Pred: if _globs_ is None :
==================
NL:define the method utcoffset with 2 arguments self and dt .
Tgt:  def NAME ( NAME , NAME ) :
Pred: def NAME ( NAME , NAME ) :

Tgt:  def utcoffset ( self , dt ) :
Pred: def utcoffset ( self , dt ) :
==================
NL:define the method __add__ with 2 arguments self and rhs .
Tgt:  def NAME ( NAME , NAME ) :
Pred: def NAME ( NAME , NAME ) :

Tgt:  def __add__ ( self , rhs ) :
Pred: def __add__ ( self , rhs ) :
==================
NL:define the method __new__ with 4 arguments : cls , name , this_bases and d .
Tgt:  def NAME ( NAME , NAME , NAME , NAME ) :
Pred: def NAME ( NAME , NAME , NAME , NAME ) :

Tgt:  def __new__ ( cls , name , this_bases , d ) :
Pred: def __new__ ( cls , name , this_bases , d ) :
==================
NL:define the function compress_sequence with an argument sequence .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def compress_sequence ( sequence ) :
Pred: def compress_sequence ( sequence ) :
==================
NL:return self.__offset [ self . __offset ] .
Tgt:  return NAME . NAME
Pred: return NAME . NAME

Tgt:  return self . __offset
Pred: return self . __offset
==================
NL:define the function ngettext with 3 arguments : singular , plural and number .
Tgt:  def NAME ( NAME , NAME , NAME ) :
Pred: def NAME ( NAME , NAME , NAME ) :

Tgt:  def ngettext ( singular , plural , number ) :
Pred: def ngettext ( singular , plural , number ) :
==================
NL:call the function re.compile [ re . compile ] with an argument raw string _STR:0_ , substitute the result for re_camel_case .
Tgt:  NAME = re . compile ( STRING )
Pred: NAME = re . compile ( STRING )

Tgt:  re_camel_case = re . compile ( <[> _STR:0_ <]> )
Pred: re_camel_case = re . compile ( <[> _STR:0_ <]> )
==================
NL:otherwise if closing_tag is true ,
Tgt:  elif NAME :
Pred: elif NAME :

Tgt:  elif closing_tag :
Pred: elif closing_tag :
==================
NL:get _assertRegex attribute of the self object , call the result with 2 arguments : unpacked list args ,
Tgt:  return getattr ( NAME , NAME ) ( * NAME , ** NAME )
Pred: return getattr ( NAME , NAME ) ( * NAME , ** NAME )

Tgt:  return getattr ( self , _assertRegex ) ( * args , ** kwargs )
Pred: return getattr ( self , _assertRegex ) ( * args , ** kwargs )
==================
NL:call the method self.endElement [ self . endElement ] with an argument name .
Tgt:  NAME . NAME ( NAME )
Pred: NAME . NAME ( NAME )

Tgt:  self . endElement ( name )
Pred: self . endElement ( name )
==================
NL:raise an KeyError with an argument _STR:0_ , where ' % s ' is replaced with lang_code .
Tgt:  raise NAME ( STRING % NAME )
Pred: raise NAME ( STRING % NAME )

Tgt:  raise KeyError ( <[> _STR:0_ <]> % lang_code )
Pred: raise KeyError ( <[> _STR:0_ <]> % lang_code )
==================
NL:remove kwargs dictionary element under the _STR:0_ key , substitute it for method .
Tgt:  NAME = NAME . NAME ( STRING )
Pred: NAME = NAME . NAME ( STRING )

Tgt:  method = kwargs . pop ( <[> _STR:0_ <]> )
Pred: method = kwargs . pop ( <[> _STR:0_ <]> )
==================
NL:call the function _trans.to_locale [ _trans . to_locale ] with an argument language , return the result .
Tgt:  return NAME . NAME ( NAME )
Pred: return NAME . NAME ( NAME )

Tgt:  return _trans . to_locale ( language )
Pred: return _trans . to_locale ( language )
==================
NL:call the function is_aware with an argument value , if it evaluates to true ,
Tgt:  if NAME ( NAME ) :
Pred: if NAME ( NAME ) :

Tgt:  if is_aware ( value ) :
Pred: if is_aware ( value ) :
==================
NL:if elt is an instance of Group class ,
Tgt:  if isinstance ( NAME , NAME ) :
Pred: if isinstance ( NAME , NAME ) :

Tgt:  if isinstance ( elt , Group ) :
Pred: if isinstance ( elt , Group ) :
==================
NL:derive the class UTC from the tzinfo base class .
Tgt:  class NAME ( NAME ) :
Pred: class NAME ( NAME ) :

Tgt:  class UTC ( tzinfo ) :
Pred: class UTC ( tzinfo ) :
==================
NL:substitute number for value under the _STR:0_ key of the kwargs dictionary .
Tgt:  NAME [ STRING ] = NAME
Pred: NAME [ STRING ] = NAME

Tgt:  kwargs [ <[> _STR:0_ <]> ] = number
Pred: kwargs [ <[> _STR:0_ <]> ] = number
==================
NL:define the function wrapper with an argument cls .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def wrapper ( cls ) :
Pred: def wrapper ( cls ) :
==================
NL:define the method __nonzero__ with an argument self .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def __nonzero__ ( self ) :
Pred: def __nonzero__ ( self ) :
==================
NL:increment i-th element of result by piece .
Tgt:  NAME [ NAME ] += NAME
Pred: NAME [ NAME ] += NAME

Tgt:  result [ i ] += piece
Pred: result [ i ] += piece
==================
NL:from django.utils.deprecation [ django . utils . deprecation ] import RemovedInDjango19Warning into default name space .
Tgt:  from NAME . NAME . NAME import NAME
Pred: from NAME . NAME . NAME import NAME

Tgt:  from django . utils . deprecation import RemovedInDjango19Warning
Pred: from django . utils . deprecation import RemovedInDjango19Warning
==================
NL:call the method value.astimezone [ value . astimezone ] with an argument timezone , substitute the result for value .
Tgt:  NAME = NAME . NAME ( NAME )
Pred: NAME = NAME . NAME ( NAME )

Tgt:  value = value . astimezone ( timezone )
Pred: value = value . astimezone ( timezone )
==================
NL:call the get_complete_version function with version as argument , store the result in version .
Tgt:  NAME = NAME ( NAME )
Pred: NAME = NAME ( NAME )

Tgt:  version = get_complete_version ( version )
Pred: version = get_complete_version ( version )
==================
NL:if data is not an instance of basestring ,
Tgt:  if not isinstance ( NAME , basestring ) :
Pred: if not isinstance ( NAME , NAME ) :

Tgt:  if not isinstance ( data , basestring ) :
Pred: if not isinstance ( data , basestring ) :
==================
NL:call the function timedelta with an argument minutes set to offset , substitute the result for self.__offset [ self . __offset ] .
Tgt:  NAME . NAME = NAME ( NAME = NAME )
Pred: NAME . NAME = NAME ( NAME = NAME )

Tgt:  self . __offset = timedelta ( minutes = offset )
Pred: self . __offset = timedelta ( minutes = offset )
==================
NL:_iterlists is a string _STR:0_ .
Tgt:  NAME = STRING
Pred: NAME = STRING

Tgt:  _iterlists = <[> _STR:0_ <]>
Pred: _iterlists = <[> _STR:0_ <]>
==================
NL:if space equals integer 0 ,
Tgt:  if NAME == NUMBER :
Pred: if NAME == NUMBER :

Tgt:  if space == 0 :
Pred: if space == 0 :
==================
NL:derive the class Truncator form the SimpleLazyObject class .
Tgt:  class NAME ( NAME ) :
Pred: class NAME ( NAME ) :

Tgt:  class Truncator ( SimpleLazyObject ) :
Pred: class Truncator ( SimpleLazyObject ) :
==================
NL:substitute next for advance_iterator .
Tgt:  NAME = next
Pred: NAME = next

Tgt:  advance_iterator = next
Pred: advance_iterator = next
==================
NL:define the function _add_doc with 2 arguments : func and doc .
Tgt:  def NAME ( NAME , NAME ) :
Pred: def NAME ( NAME , NAME ) :

Tgt:  def _add_doc ( func , doc ) :
Pred: def _add_doc ( func , doc ) :
==================
NL:if not ,
Tgt:  else :
Pred: else :

Tgt:  else :
Pred: else :
==================
NL:define the function fix with an argument match .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def fix ( match ) :
Pred: def fix ( match ) :
==================
NL:substitute rhs for number_value .
Tgt:  NAME = NAME
Pred: NAME = NAME

Tgt:  number_value = rhs
Pred: number_value = rhs
==================
NL:return singular .
Tgt:  return NAME
Pred: return NAME

Tgt:  return singular
Pred: return singular
==================
NL:_STR:0_ , _STR:1_ , _STR:2_ , _STR:3_ , _STR:4_ , _STR:5_ , _STR:6_ , _STR:7_ , _STR:8_ , _STR:9_ and _STR:10_ . call the function timedelta with an argument integer 0 , substitute the result for ZERO .
Tgt:  NAME = NAME ( NUMBER )
Pred: NAME = NAME ( NUMBER )

Tgt:  ZERO = timedelta ( 0 )
Pred: ZERO = timedelta ( 0 )
==================
NL:if self_closing is true or tagname is contained in html4_singlets ,
Tgt:  if NAME or NAME in NAME :
Pred: if NAME or NAME in NAME :

Tgt:  if self_closing or tagname in html4_singlets :
Pred: if self_closing or tagname in html4_singlets :
==================
NL:if ValueError exception is caught ,
Tgt:  except NAME :
Pred: except NAME :

Tgt:  except ValueError :
Pred: except ValueError :
==================
NL:if six.PY2 [ six . PY2 ] is true ,
Tgt:  if NAME . NAME :
Pred: if NAME . NAME :

Tgt:  if six . PY2 :
Pred: if six . PY2 :
==================
NL:append t.contents [ t . contents ] to comment .
Tgt:  NAME . NAME ( NAME . NAME )
Pred: NAME . NAME ( NAME . NAME )

Tgt:  comment . append ( t . contents )
Pred: comment . append ( t . contents )
==================
NL:call the function timedelta with an argument minutes set to offset , substitute the result for self.__offset [ self . __offset ] .
Tgt:  NAME . NAME = NAME ( NAME = NAME )
Pred: NAME . NAME = NAME ( NAME = NAME )

Tgt:  self . __offset = timedelta ( minutes = offset )
Pred: self . __offset = timedelta ( minutes = offset )
==================
NL:translation._catalog [ translation . _catalog ] is an empty dictionary .
Tgt:  NAME . NAME = { }
Pred: NAME . NAME = { }

Tgt:  translation . _catalog = { }
Pred: translation . _catalog = { }
==================
NL:if message_context is true ,
Tgt:  if NAME :
Pred: if NAME :

Tgt:  if message_context :
Pred: if message_context :
==================
NL:return self.__offset [ self . __offset ] .
Tgt:  return NAME . NAME
Pred: return NAME . NAME

Tgt:  return self . __offset
Pred: return self . __offset
==================
NL:if elt is an instance of six.string_types [ six . string_types ] class ,
Tgt:  if isinstance ( NAME , NAME . NAME ) :
Pred: if isinstance ( NAME , NAME . NAME ) :

Tgt:  if isinstance ( elt , six . string_types ) :
Pred: if isinstance ( elt , six . string_types ) :
==================
NL:from __future__ import unicode_literals into default name space .
Tgt:  from NAME import NAME
Pred: from NAME import NAME

Tgt:  from __future__ import unicode_literals
Pred: from __future__ import unicode_literals
==================
NL:substitute memoryview for memoryview .
Tgt:  memoryview = memoryview
Pred: NAME = NAME

Tgt:  memoryview = memoryview
Pred: memoryview = memoryview
==================
NL:call the method self._new_gnu_trans [ self . _new_gnu_trans ] with an argument localedir , substitute the result for translation .
Tgt:  NAME = NAME . NAME ( NAME )
Pred: NAME = NAME . NAME ( NAME )

Tgt:  translation = self . _new_gnu_trans ( localedir )
Pred: translation = self . _new_gnu_trans ( localedir )
==================
NL:if not ,
Tgt:  else :
Pred: else :

Tgt:  else :
Pred: else :
==================
NL:return an instance of SafeBytes , created with an argument data .
Tgt:  return NAME ( NAME )
Pred: return NAME ( NAME )

Tgt:  return SafeBytes ( data )
Pred: return SafeBytes ( data )
==================
NL:split part by _STR:0_ character , substitute the result for role and instructions , respectively .
Tgt:  NAME , NAME = NAME . NAME ( STRING )
Pred: NAME , NAME = NAME . NAME ( STRING )

Tgt:  role , instructions = part . split ( <[> _STR:0_ <]> )
Pred: role , instructions = part . split ( <[> _STR:0_ <]> )
==================
NL:if k equals a string _STR:0_ ,
Tgt:  if NAME == STRING :
Pred: if NAME == STRING :

Tgt:  if k == <[> _STR:0_ <]> :
Pred: if k == <[> _STR:0_ <]> :
==================
NL:call the function lazy with 2 arguments : gettext and str , substitute gettext_lazy .
Tgt:  NAME = NAME ( NAME , str )
Pred: NAME = NAME ( NAME , str )

Tgt:  gettext_lazy = lazy ( gettext , str )
Pred: gettext_lazy = lazy ( gettext , str )
==================
NL:from django.test.signals [ django . test . signals ] import setting_changed into default name space .
Tgt:  from NAME . NAME . NAME import NAME
Pred: from NAME . NAME . NAME import NAME

Tgt:  from django . test . signals import setting_changed
Pred: from django . test . signals import setting_changed
==================
NL:call the method self._isdst [ self . _isdst ] with an argument dt , if it evaluates to true ,
Tgt:  if NAME . NAME ( NAME ) :
Pred: if NAME . NAME ( NAME ) :

Tgt:  if self . _isdst ( dt ) :
Pred: if self . _isdst ( dt ) :
==================
NL:if not ,
Tgt:  else :
Pred: else :

Tgt:  else :
Pred: else :
==================
NL:substitute chr for int2byte .
Tgt:  NAME = chr
Pred: NAME = NAME

Tgt:  int2byte = chr
Pred: int2byte = chr
==================
NL:if not ,
Tgt:  else :
Pred: else :

Tgt:  else :
Pred: else :
==================
NL:derive the class RWLock from the object base class .
Tgt:  class NAME ( object ) :
Pred: class NAME ( object ) :

Tgt:  class RWLock ( object ) :
Pred: class RWLock ( object ) :
==================
NL:if slots is not None ,
Tgt:  if NAME is not None :
Pred: if NAME is not None :

Tgt:  if slots is not None :
Pred: if slots is not None :
==================
NL:call the function _import_module with an argument self.mod [ self . mod ] , substitute the result for module .
Tgt:  NAME = NAME ( NAME . NAME )
Pred: NAME = NAME ( NAME . NAME )

Tgt:  module = _import_module ( self . mod )
Pred: module = _import_module ( self . mod )
==================
NL:RemovedInDjango19Warning and stacklevel as integer 2. try ,
Tgt:  try :
Pred: try :

Tgt:  try :
Pred: try :
==================
NL:define the function iterbytes with an argument buf .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def iterbytes ( buf ) :
Pred: def iterbytes ( buf ) :
==================
NL:import dummy_threading as threading .
Tgt:  import NAME as NAME
Pred: import NAME as NAME

Tgt:  import dummy_threading as threading
Pred: import dummy_threading as threading
==================
NL:call the method data.encode [ data . encode ] with 2 arguments : fp.encoding [ fp . encoding ] and errors , substitute the result for data .
Tgt:  NAME = NAME . NAME ( NAME . NAME , NAME )
Pred: NAME = NAME . NAME ( NAME . NAME , NAME )

Tgt:  data = data . encode ( fp . encoding , errors )
Pred: data = data . encode ( fp . encoding , errors )
==================
NL:substitute name for new_attr .
Tgt:  NAME = NAME
Pred: NAME = NAME

Tgt:  new_attr = name
Pred: new_attr = name
==================
NL:from django.utils.deprecation [ django . utils . deprecation ] import RemovedInDjango19Warning into default name space .
Tgt:  from NAME . NAME . NAME import NAME
Pred: from NAME . NAME . NAME import NAME

Tgt:  from django . utils . deprecation import RemovedInDjango19Warning
Pred: from django . utils . deprecation import RemovedInDjango19Warning
==================
NL:call the method match.group [ match . group ] with an argument integer 1 , substitute the result for text .
Tgt:  NAME = NAME . NAME ( NUMBER )
Pred: NAME = NAME . NAME ( NUMBER )

Tgt:  text = match . group ( 1 )
Pred: text = match . group ( 1 )
==================
NL:if not ,
Tgt:  else :
Pred: else :

Tgt:  else :
Pred: else :
==================
NL:if not ,
Tgt:  else :
Pred: else :

Tgt:  else :
Pred: else :
==================
NL:call the function do_ntranslate with 3 arguments : singular , plural , number and string _STR:0_ , return the result .
Tgt:  return NAME ( NAME , NAME , NAME , STRING )
Pred: return NAME ( NAME , NAME , NAME , STRING )

Tgt:  return do_ntranslate ( singular , plural , number , <[> _STR:0_ <]> )
Pred: return do_ntranslate ( singular , plural , number , <[> _STR:0_ <]> )
==================
NL:substitute doc for func.__doc__ [ func . __doc__ ] .
Tgt:  NAME . NAME = NAME
Pred: NAME . NAME = NAME

Tgt:  func . __doc__ = doc
Pred: func . __doc__ = doc
==================
NL:assign it to value under the string _STR:0_ appended to __name__ key of the sys.modules [ sys . modules ] dictionary , and to value under the string _STR:1_ appended to __name__ key of the sys.modules [ sys . modules ] dictionary . derive class Module_six_moves_urllib_robotparser from the _LazyModule base class .
Tgt:  class NAME ( NAME ) :
Pred: class NAME ( NAME ) :

Tgt:  class Module_six_moves_urllib_robotparser ( _LazyModule ) :
Pred: class Module_six_moves_urllib_robotparser ( _LazyModule ) :
==================
NL:singular is an empty list .
Tgt:  NAME = [ ]
Pred: NAME = [ ]

Tgt:  singular = [ ]
Pred: singular = [ ]
==================
NL:from unittest2 import everything .
Tgt:  from NAME import *
Pred: from NAME import *

Tgt:  from unittest2 import *
Pred: from unittest2 import *
==================
NL:break from the loop execution .
Tgt:  NAME
Pred: NAME

Tgt:  break
Pred: break
==================
NL:if _default is None ,
Tgt:  if NAME is None :
Pred: if NAME is None :

Tgt:  if _default is None :
Pred: if _default is None :
==================
NL:if KeyError exception is caught ,
Tgt:  except NAME :
Pred: except NAME :

Tgt:  except KeyError :
Pred: except KeyError :
==================
NL:call the method self._resolve [ self . _resolve ] , substitute the result for _module .
Tgt:  NAME = NAME . NAME ( )
Pred: NAME = NAME . NAME ( )

Tgt:  _module = self . _resolve ( )
Pred: _module = self . _resolve ( )
==================
NL:define the method dst with 2 arguments self and dt .
Tgt:  def NAME ( NAME , NAME ) :
Pred: def NAME ( NAME , NAME ) :

Tgt:  def dst ( self , dt ) :
Pred: def dst ( self , dt ) :
==================
NL:define the method negate with an argument self .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def negate ( self ) :
Pred: def negate ( self ) :
==================
NL:define the method _resolve with an argument self .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def _resolve ( self ) :
Pred: def _resolve ( self ) :
==================
NL:if not ,
Tgt:  else :
Pred: else :

Tgt:  else :
Pred: else :
==================
NL:if OverflowError or ValueError , renamed to exc , exceptions are caught ,
Tgt:  except ( NAME , NAME ) as NAME :
Pred: except ( NAME , NAME ) as NAME :

Tgt:  except ( OverflowError , ValueError ) as exc :
Pred: except ( OverflowError , ValueError ) as exc :
==================
NL:from django import VERSION as version into default name space .
Tgt:  from NAME import NAME as NAME
Pred: from NAME import NAME as NAME

Tgt:  from django import VERSION as version
Pred: from django import VERSION as version
==================
NL:filemsg is a string _STR:0_ , where ' % s ' is replaced with origin .
Tgt:  NAME = STRING % NAME
Pred: NAME = STRING % NAME

Tgt:  filemsg = <[> _STR:0_ <]> % origin
Pred: filemsg = <[> _STR:0_ <]> % origin
==================
NL:delete attr .
Tgt:  del NAME
Pred: del NAME

Tgt:  del attr
Pred: del attr
==================
NL:call the function activate with an argument self.language [ self . language ] .
Tgt:  NAME ( NAME . NAME )
Pred: NAME ( NAME . NAME )

Tgt:  activate ( self . language )
Pred: activate ( self . language )
==================
NL:define the method to_language with an argument self .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def to_language ( self ) :
Pred: def to_language ( self ) :
==================
NL:if old_attr is None ,
Tgt:  if NAME is None :
Pred: if NAME is None :

Tgt:  if old_attr is None :
Pred: if old_attr is None :
==================
NL:for every cmatch in cmatches ,
Tgt:  for NAME in NAME :
Pred: for NAME in NAME :

Tgt:  for cmatch in cmatches :
Pred: for cmatch in cmatches :
==================
NL:convert data to string , substitute it for data .
Tgt:  NAME = str ( NAME )
Pred: NAME = str ( NAME )

Tgt:  data = str ( data )
Pred: data = str ( data )
==================
NL:write item to zfile stream .
Tgt:  NAME . NAME ( NAME )
Pred: NAME . NAME ( NAME )

Tgt:  zfile . write ( item )
Pred: zfile . write ( item )
==================
NL:substitute new_args for result_args .
Tgt:  NAME = NAME
Pred: NAME = NAME

Tgt:  result_args = new_args
Pred: result_args = new_args
==================
NL:if truncate is None ,
Tgt:  if NAME is None :
Pred: if NAME is None :

Tgt:  if truncate is None :
Pred: if truncate is None :
==================
NL:import module unicodedata .
Tgt:  import NAME
Pred: import NAME

Tgt:  import unicodedata
Pred: import unicodedata
==================
NL:if text ends with truncate ,
Tgt:  if NAME . NAME ( NAME ) :
Pred: if NAME . NAME ( NAME ) :

Tgt:  if text . endswith ( truncate ) :
Pred: if text . endswith ( truncate ) :
==================
NL:call the method pytz.timezone [ pytz . timezone ] with an argument settings.TIME_ZONE [ settings . TIME_ZONE ] , substitute the result for _localtime .
Tgt:  NAME = NAME . NAME ( NAME . NAME )
Pred: NAME = NAME . NAME ( NAME . NAME )

Tgt:  _localtime = pytz . timezone ( settings . TIME_ZONE )
Pred: _localtime = pytz . timezone ( settings . TIME_ZONE )
==================
NL:covert to lowercase language elements from ( p+1 ) -th index to the end , append it to the previous result , return it . if not ,
Tgt:  else :
Pred: else :

Tgt:  else :
Pred: else :
==================
NL:define the function template_localtime with 2 arguments : value and use_tz set to None .
Tgt:  def NAME ( NAME , NAME = None ) :
Pred: def NAME ( NAME , NAME = None ) :

Tgt:  def template_localtime ( value , use_tz = None ) :
Pred: def template_localtime ( value , use_tz = None ) :
==================
NL:convert priority into a floating point integer , substitute it for priority .
Tgt:  NAME = float ( NAME )
Pred: NAME = float ( NAME )

Tgt:  priority = float ( priority )
Pred: priority = float ( priority )
==================
NL:call the method threading.Semaphore [ threading . Semaphore ] with an argument integer 0 , substitute the result for self.can_read [ self . can_read ] .
Tgt:  NAME . NAME = NAME . NAME ( NUMBER )
Pred: NAME . NAME = NAME . NAME ( NUMBER )

Tgt:  self . can_read = threading . Semaphore ( 0 )
Pred: self . can_read = threading . Semaphore ( 0 )
==================
NL:if translators_comment_start is not None and lineno is greater than or equal to translators_comment_start ,
Tgt:  if NAME is not None and NAME >= NAME :
Pred: if NAME is not None and NAME >= NAME :

Tgt:  if translators_comment_start is not None and lineno >= translators_comment_start :
Pred: if translators_comment_start is not None and lineno >= translators_comment_start :
==================
NL:define the method __exit__ with 4 arguments self , exc_type , exc_value and traceback .
Tgt:  def NAME ( NAME , NAME , NAME , NAME ) :
Pred: def NAME ( NAME , NAME , NAME , NAME ) :

Tgt:  def __exit__ ( self , exc_type , exc_value , traceback ) :
Pred: def __exit__ ( self , exc_type , exc_value , traceback ) :
==================
NL:call the function _import_module with an argument self.mod [ self . mod ] , return the result .
Tgt:  return NAME ( NAME . NAME )
Pred: return NAME ( NAME . NAME )

Tgt:  return _import_module ( self . mod )
Pred: return _import_module ( self . mod )
==================
NL:try ,
Tgt:  try :
Pred: try :

Tgt:  try :
Pred: try :
==================
NL:strip message_context of _STR:0_ characters from both ends , substitute the result for message_context .
Tgt:  NAME = NAME . NAME ( STRING )
Pred: NAME = NAME . NAME ( STRING )

Tgt:  message_context = message_context . strip ( <[> _STR:0_ <]> )
Pred: message_context = message_context . strip ( <[> _STR:0_ <]> )
==================
NL:substitute _urllib_parse_moved_attributes for Module_six_moves_urllib_parse._moved_attributes [ Module_six_moves_urllib_parse . _moved_attributes ] .
Tgt:  NAME . NAME = NAME
Pred: NAME . NAME = NAME

Tgt:  Module_six_moves_urllib_parse . _moved_attributes = _urllib_parse_moved_attributes
Pred: Module_six_moves_urllib_parse . _moved_attributes = _urllib_parse_moved_attributes
==================
NL:append data to self.children [ self . children ] .
Tgt:  NAME . NAME . NAME ( NAME )
Pred: NAME . NAME . NAME ( NAME )

Tgt:  self . children . append ( data )
Pred: self . children . append ( data )
==================
NL:delete X .
Tgt:  del NAME
Pred: del NAME

Tgt:  del X
Pred: del X
==================
NL:return palette .
Tgt:  return NAME
Pred: return NAME

Tgt:  return palette
Pred: return palette
==================
NL:call the method t.to_language [ t . to_language ] , return the result .
Tgt:  return NAME . NAME ( )
Pred: return NAME . NAME ( )

Tgt:  return t . to_language ( )
Pred: return t . to_language ( )
==================
NL:_STR:0_ , RemovedInDjango19Warning and stacklevel set to 2. derive the class FixedOffset from the tzinfo base class .
Tgt:  class NAME ( NAME ) :
Pred: class NAME ( NAME ) :

Tgt:  class FixedOffset ( tzinfo ) :
Pred: class FixedOffset ( tzinfo ) :
==================
NL:_assertCountEqual is a strnig _STR:0_ .
Tgt:  NAME = STRING
Pred: NAME = STRING

Tgt:  _assertCountEqual = <[> _STR:0_ <]>
Pred: _assertCountEqual = <[> _STR:0_ <]>
==================
NL:define the function _generator .
Tgt:  def NAME ( ) :
Pred: def NAME ( ) :

Tgt:  def _generator ( ) :
Pred: def _generator ( ) :
==================
NL:define the method __enter__ with an argument self .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def __enter__ ( self ) :
Pred: def __enter__ ( self ) :
==================
NL:if elt is an instance of NonCapture class ,
Tgt:  if isinstance ( NAME , NAME ) :
Pred: if isinstance ( NAME , NAME ) :

Tgt:  if isinstance ( elt , NonCapture ) :
Pred: if isinstance ( elt , NonCapture ) :
==================
NL:call the method operator.attrgetter [ operator . attrgetter ] with an argument _meth_func , substitute the result for get_method_function .
Tgt:  NAME = NAME . NAME ( NAME )
Pred: NAME = NAME . NAME ( NAME )

Tgt:  get_method_function = operator . attrgetter ( _meth_func )
Pred: get_method_function = operator . attrgetter ( _meth_func )
==================
NL:format string _STR:0_ with RESET , return the result .
Tgt:  return STRING % NAME
Pred: return STRING % NAME

Tgt:  return <[> _STR:0_ <]> % RESET
Pred: return <[> _STR:0_ <]> % RESET
==================
NL:if not ,
Tgt:  else :
Pred: else :

Tgt:  else :
Pred: else :
==================
NL:if tt.tm_isdst [ tt . tm_isdst ] is greater than intger 0 , return boolean True , otherwise return boolean False .
Tgt:  return NAME . NAME > NUMBER
Pred: return NAME . NAME > NUMBER

Tgt:  return tt . tm_isdst > 0
Pred: return tt . tm_isdst > 0
==================
NL:try ,
Tgt:  try :
Pred: try :

Tgt:  try :
Pred: try :
==================
NL:for every item in elt ,
Tgt:  for NAME in NAME :
Pred: for NAME in NAME :

Tgt:  for item in elt :
Pred: for item in elt :
==================
NL:use global variable _localtime .
Tgt:  global NAME
Pred: global NAME

Tgt:  global _localtime
Pred: global _localtime
==================
NL:substitute pos for end_text_pos .
Tgt:  NAME = NAME
Pred: NAME = NAME

Tgt:  end_text_pos = pos
Pred: end_text_pos = pos
==================
NL:increment self.waiting_readers [ self . waiting_readers ] by 1 .
Tgt:  NAME . NAME += NUMBER
Pred: NAME . NAME += NUMBER

Tgt:  self . waiting_readers += 1
Pred: self . waiting_readers += 1
==================
NL:for every part in plural ,
Tgt:  for NAME in NAME :
Pred: for NAME in NAME :

Tgt:  for part in plural :
Pred: for part in plural :
==================
NL:from django.apps [ django . apps ] import apps into default name space .
Tgt:  from NAME . NAME import NAME
Pred: from NAME . NAME import NAME

Tgt:  from django . apps import apps
Pred: from django . apps import apps
==================
NL:mark_safe function , return the result . call the function allow_lazy with 2 arguments : slugify and six.text_type [ six . text_type ] , substitute the result slugify .
Tgt:  NAME = NAME ( NAME , NAME . NAME )
Pred: NAME = NAME ( NAME , NAME . NAME )

Tgt:  slugify = allow_lazy ( slugify , six . text_type )
Pred: slugify = allow_lazy ( slugify , six . text_type )
==================
NL:define the method utcoffset with 2 arguments self and dt .
Tgt:  def NAME ( NAME , NAME ) :
Pred: def NAME ( NAME , NAME ) :

Tgt:  def utcoffset ( self , dt ) :
Pred: def utcoffset ( self , dt ) :
==================
NL:zip elements of result and result_args into a list of tuples , for every item and args in the result ,
Tgt:  for NAME , NAME in zip ( NAME , NAME ) :
Pred: for NAME , NAME in zip ( NAME , NAME ) :

Tgt:  for item , args in zip ( result , result_args ) :
Pred: for item , args in zip ( result , result_args ) :
==================
NL:if accept_lang equals _STR:0_ ,
Tgt:  if NAME == STRING :
Pred: if NAME == STRING :

Tgt:  if accept_lang == <[> _STR:0_ <]> :
Pred: if accept_lang == <[> _STR:0_ <]> :
==================
NL:if timezone has an attribute _STR:0_ ,
Tgt:  if hasattr ( NAME , STRING ) :
Pred: if hasattr ( NAME , STRING ) :

Tgt:  if hasattr ( timezone , <[> _STR:0_ <]> ) :
Pred: if hasattr ( timezone , <[> _STR:0_ <]> ) :
==================
NL:define the method __init__ with 4 arguments : self , children set to None , connector set to None and negated set to boolean False .
Tgt:  def NAME ( NAME , NAME = None , NAME = None , NAME = False ) :
Pred: def NAME ( NAME , NAME = None , NAME = None , NAME = False ) :

Tgt:  def __init__ ( self , children = None , connector = None , negated = False ) :
Pred: def __init__ ( self , children = None , connector = None , negated = False ) :
==================
NL:define the function get_language_from_request with 2 arguments : request and check_path set to boolean False .
Tgt:  def NAME ( NAME , NAME = False ) :
Pred: def NAME ( NAME , NAME = False ) :

Tgt:  def get_language_from_request ( request , check_path = False ) :
Pred: def get_language_from_request ( request , check_path = False ) :
==================
NL:call the method m.end [ m . end ] with an argument integer 0 , substitute the result for pos .
Tgt:  NAME = NAME . NAME ( NUMBER )
Pred: NAME = NAME . NAME ( NUMBER )

Tgt:  pos = m . end ( 0 )
Pred: pos = m . end ( 0 )
==================
NL:substitute the result for context_match . call the method context_match.group [ context_match . group ] with an argument integer 1 , substitute the result for message_context .
Tgt:  NAME = NAME . NAME ( NUMBER )
Pred: NAME = NAME . NAME ( NUMBER )

Tgt:  message_context = context_match . group ( 1 )
Pred: message_context = context_match . group ( 1 )
==================
NL:if not ,
Tgt:  else :
Pred: else :

Tgt:  else :
Pred: else :
==================
NL:define the function pgettext with 2 arguments : context and message .
Tgt:  def NAME ( NAME , NAME ) :
Pred: def NAME ( NAME , NAME ) :

Tgt:  def pgettext ( context , message ) :
Pred: def pgettext ( context , message ) :
==================
NL:call the method gettext_module.NullTranslations [ gettext_module . NullTranslations ] , substitute the result for _active.value [ _active . value ] .
Tgt:  NAME . NAME = NAME . NAME ( )
Pred: NAME . NAME = NAME . NAME ( )

Tgt:  _active . value = gettext_module . NullTranslations ( )
Pred: _active . value = gettext_module . NullTranslations ( )
==================
NL:if six.PY3 [ six . PY3 ] is true ,
Tgt:  if NAME . NAME :
Pred: if NAME . NAME :

Tgt:  if six . PY3 :
Pred: if six . PY3 :
==================
NL:return t .
Tgt:  return NAME
Pred: return NAME

Tgt:  return t
Pred: return t
==================
NL:if ValueError exception is caught ,
Tgt:  except NAME :
Pred: except NAME :

Tgt:  except ValueError :
Pred: except ValueError :
==================
NL:define the function to_locale with an argument language .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def to_locale ( language ) :
Pred: def to_locale ( language ) :
==================
NL:derive the class override from the object base class .
Tgt:  class NAME ( object ) :
Pred: class NAME ( object ) :

Tgt:  class override ( object ) :
Pred: class override ( object ) :
==================
NL:translation._info [ translation . _info ] is an empty dictionary .
Tgt:  NAME . NAME = { }
Pred: NAME . NAME = { }

Tgt:  translation . _info = { }
Pred: translation . _info = { }
==================
NL:if self.deactivate [ self . deactivate ] is true ,
Tgt:  if NAME . NAME :
Pred: if NAME . NAME :

Tgt:  if self . deactivate :
Pred: if self . deactivate :
==================
NL:for every supported_code in _supported ,
Tgt:  for NAME in NAME :
Pred: for NAME in NAME :

Tgt:  for supported_code in _supported :
Pred: for supported_code in _supported :
==================
NL:define the function npgettext with 4 arguments : context , singular , plural and number .
Tgt:  def NAME ( NAME , NAME , NAME , NAME ) :
Pred: def NAME ( NAME , NAME , NAME , NAME ) :

Tgt:  def npgettext ( context , singular , plural , number ) :
Pred: def npgettext ( context , singular , plural , number ) :
==================
NL:define the method tzname with 2 arguments : self and dt .
Tgt:  def NAME ( NAME , NAME ) :
Pred: def NAME ( NAME , NAME ) :

Tgt:  def tzname ( self , dt ) :
Pred: def tzname ( self , dt ) :
==================
NL:if inplural is true ,
Tgt:  if NAME :
Pred: if NAME :

Tgt:  if inplural :
Pred: if inplural :
==================
NL:define the function javascript_quote with 2 arguments : s and quote_double_quotes set to boolean False .
Tgt:  def NAME ( NAME , NAME = False ) :
Pred: def NAME ( NAME , NAME = False ) :

Tgt:  def javascript_quote ( s , quote_double_quotes = False ) :
Pred: def javascript_quote ( s , quote_double_quotes = False ) :
==================
NL:try ,
Tgt:  try :
Pred: try :

Tgt:  try :
Pred: try :
==================
NL:return an instance of SafeText , created with an argument t .
Tgt:  return NAME ( NAME )
Pred: return NAME ( NAME )

Tgt:  return SafeText ( t )
Pred: return SafeText ( t )
==================
NL:format translated with rhs , substitute the result for translated .
Tgt:  NAME = NAME % NAME
Pred: NAME = NAME % NAME

Tgt:  translated = translated % rhs
Pred: translated = translated % rhs
==================
NL:if not ,
Tgt:  else :
Pred: else :

Tgt:  else :
Pred: else :
==================
NL:return major .
Tgt:  return NAME
Pred: return NAME

Tgt:  return major
Pred: return major
==================
NL:end_text_pos is equal to integer 0 .
Tgt:  NAME = NUMBER
Pred: NAME = NUMBER

Tgt:  end_text_pos = 0
Pred: end_text_pos = 0
==================
NL:return data .
Tgt:  return NAME
Pred: return NAME

Tgt:  return data
Pred: return data
==================
NL:define the method utcoffset with 2 arguments : self and dt .
Tgt:  def NAME ( NAME , NAME ) :
Pred: def NAME ( NAME , NAME ) :

Tgt:  def utcoffset ( self , dt ) :
Pred: def utcoffset ( self , dt ) :
==================
NL:call the method self.reader_leaves [ self . reader_leaves ] .
Tgt:  NAME . NAME ( )
Pred: NAME . NAME ( )

Tgt:  self . reader_leaves ( )
Pred: self . reader_leaves ( )
==================
NL:called with with an argument lambda function which returns result of the force_text function called with an argument text . define the method add_truncation_text with 3 arguments : self , text and truncate set to None .
Tgt:  def NAME ( NAME , NAME , NAME = None ) :
Pred: def NAME ( NAME , NAME , NAME = None ) :

Tgt:  def add_truncation_text ( self , text , truncate = None ) :
Pred: def add_truncation_text ( self , text , truncate = None ) :
==================
NL:if character _STR:0_ is not contained in lang_code ,
Tgt:  if STRING not in NAME :
Pred: if STRING not in NAME :

Tgt:  if <[> _STR:0_ <]> not in lang_code :
Pred: if <[> _STR:0_ <]> not in lang_code :
==================
NL:if not ,
Tgt:  else :
Pred: else :

Tgt:  else :
Pred: else :
==================
NL:split lang_code by _STR:0_ , substitute the first element of the result for generic_lang_code .
Tgt:  NAME = NAME . NAME ( STRING ) [ NUMBER ]
Pred: NAME = NAME . NAME ( STRING ) [ NUMBER ]

Tgt:  generic_lang_code = lang_code . split ( <[> _STR:0_ <]> ) [ 0 ]
Pred: generic_lang_code = lang_code . split ( <[> _STR:0_ <]> ) [ 0 ]
==================
NL:define the method addQuickElement with 4 arguments : self , name , contents set to None and attrs set to None .
Tgt:  def NAME ( NAME , NAME , NAME = None , NAME = None ) :
Pred: def NAME ( NAME , NAME , NAME = None , NAME = None ) :

Tgt:  def addQuickElement ( self , name , contents = None , attrs = None ) :
Pred: def addQuickElement ( self , name , contents = None , attrs = None ) :
==================
NL:if length of words is greater than length ,
Tgt:  if len ( NAME ) > NAME :
Pred: if len ( NAME ) > NAME :

Tgt:  if len ( words ) > length :
Pred: if len ( words ) > length :
==================
NL:substitute EscapeText for EscapeUnicode .
Tgt:  NAME = NAME
Pred: NAME = NAME

Tgt:  EscapeUnicode = EscapeText
Pred: EscapeUnicode = EscapeText
==================
NL:if not ,
Tgt:  else :
Pred: else :

Tgt:  else :
Pred: else :
==================
NL:if string _STR:0_ is contained in result of the method t.split_contents [ t . split_contents ] , trimmed is boolean True , otherwise is boolean False .
Tgt:  NAME = STRING in NAME . NAME ( )
Pred: NAME = STRING in NAME . NAME ( )

Tgt:  trimmed = <[> _STR:0_ <]> in t . split_contents ( )
Pred: trimmed = <[> _STR:0_ <]> in t . split_contents ( )
==================
NL:import pytz .
Tgt:  import NAME
Pred: import NAME

Tgt:  import pytz
Pred: import pytz
==================
NL:if attr is an instance of MovedModule .
Tgt:  if isinstance ( NAME , NAME ) :
Pred: if isinstance ( NAME , NAME ) :

Tgt:  if isinstance ( attr , MovedModule ) :
Pred: if isinstance ( attr , MovedModule ) :
==================
NL:do nothing .
Tgt:  NAME
Pred: NAME

Tgt:  pass
Pred: pass
==================
NL:use global variable _translations .
Tgt:  global NAME
Pred: global NAME

Tgt:  global _translations
Pred: global _translations
==================
NL:if not ,
Tgt:  else :
Pred: else :

Tgt:  else :
Pred: else :
==================
NL:if number equals integer 1 ,
Tgt:  if NAME == NUMBER :
Pred: if NAME == NUMBER :

Tgt:  if number == 1 :
Pred: if number == 1 :
==================
NL:return self.__name [ self . __name ] .
Tgt:  return NAME . NAME
Pred: return NAME . NAME

Tgt:  return self . __name
Pred: return self . __name
==================
NL:decrement self.active_writers [ self . active_writers ] by integer 1 ,
Tgt:  NAME . NAME -= NUMBER
Pred: NAME . NAME -= NUMBER

Tgt:  self . active_writers -= 1
Pred: self . active_writers -= 1
==================
NL:define the function remove_move with an argument name .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def remove_move ( name ) :
Pred: def remove_move ( name ) :
==================
NL:call the method imatch.group [ imatch . group ] with an argument integer 1 , substitute the result for g .
Tgt:  NAME = NAME . NAME ( NUMBER )
Pred: NAME = NAME . NAME ( NUMBER )

Tgt:  g = imatch . group ( 1 )
Pred: g = imatch . group ( 1 )
==================
NL:call the method self.can_read.release [ self . can_read . release ] .
Tgt:  NAME . NAME . NAME ( )
Pred: NAME . NAME . NAME ( )

Tgt:  self . can_read . release ( )
Pred: self . can_read . release ( )
==================
NL:call the function unicodedata.normalize [ unicodedata . normalize ] with 2 arguments : string _STR:0_ and self._wrapped [ self . _wrapped ] , substitute the result for text .
Tgt:  NAME = NAME . NAME ( STRING , NAME . NAME )
Pred: NAME = NAME . NAME ( STRING , NAME . NAME )

Tgt:  text = unicodedata . normalize ( <[> _STR:0_ <]> , self . _wrapped )
Pred: text = unicodedata . normalize ( <[> _STR:0_ <]> , self . _wrapped )
==================
NL:if squash is false ,
Tgt:  if not NAME :
Pred: if not NAME :

Tgt:  if not squash :
Pred: if not squash :
==================
NL:from django.utils.encoding [ django . utils . encoding ] import force_text into default name space .
Tgt:  from NAME . NAME . NAME import NAME
Pred: from NAME . NAME . NAME import NAME

Tgt:  from django . utils . encoding import force_text
Pred: from django . utils . encoding import force_text
==================
NL:append a tuple with 2 entries lang and priority to result .
Tgt:  NAME . NAME ( ( NAME , NAME ) )
Pred: NAME . NAME ( ( NAME , NAME ) )

Tgt:  result . append ( ( lang , priority ) )
Pred: result . append ( ( lang , priority ) )
==================
NL:inplural is boolean False .
Tgt:  NAME = False
Pred: NAME = False

Tgt:  inplural = False
Pred: inplural = False
==================
NL:try ,
Tgt:  try :
Pred: try :

Tgt:  try :
Pred: try :
==================
NL:if self.language [ self . language ] is not None ,
Tgt:  if NAME . NAME is not None :
Pred: if NAME . NAME is not None :

Tgt:  if self . language is not None :
Pred: if self . language is not None :
==================
NL:if data is contained in self.children [ self . children ] ,
Tgt:  if NAME in NAME . NAME :
Pred: if NAME in NAME . NAME :

Tgt:  if data in self . children :
Pred: if data in self . children :
==================
NL:call the method self.tzname [ self . tzname ] with an argument dt , substitute the result for self._tzname [ self . _tzname ] .
Tgt:  NAME . NAME = NAME . NAME ( NAME )
Pred: NAME . NAME = NAME . NAME ( NAME )

Tgt:  self . _tzname = self . tzname ( dt )
Pred: self . _tzname = self . tzname ( dt )
==================
NL:derive class _LazyModule from the types.ModuleType [ types . ModuleType ] base class .
Tgt:  class NAME ( NAME . NAME ) :
Pred: class NAME ( NAME . NAME ) :

Tgt:  class _LazyModule ( types . ModuleType ) :
Pred: class _LazyModule ( types . ModuleType ) :
==================
NL:append contents to singular .
Tgt:  NAME . NAME ( NAME )
Pred: NAME . NAME ( NAME )

Tgt:  singular . append ( contents )
Pred: singular . append ( contents )
==================
NL:return result .
Tgt:  return NAME
Pred: return NAME

Tgt:  return result
Pred: return result
==================
NL:split t.contents [ t . contents ] by _STR:0_ symbol , substitute the result for parts ,
Tgt:  NAME = NAME . NAME . NAME ( STRING )
Pred: NAME = NAME . NAME . NAME ( STRING )

Tgt:  parts = t . contents . split ( <[> _STR:0_ <]> )
Pred: parts = t . contents . split ( <[> _STR:0_ <]> )
==================
NL:substitute length for truncate_len .
Tgt:  NAME = NAME
Pred: NAME = NAME

Tgt:  truncate_len = length
Pred: truncate_len = length
==================
NL:return _translations dictionary value , under the language key .
Tgt:  return NAME [ NAME ]
Pred: return NAME [ NAME ]

Tgt:  return _translations [ language ]
Pred: return _translations [ language ]
==================
NL:for every item in sequence ,
Tgt:  for NAME in NAME :
Pred: for NAME in NAME :

Tgt:  for item in sequence :
Pred: for item in sequence :
==================
NL:pytz is None .
Tgt:  NAME = None
Pred: NAME = None

Tgt:  pytz = None
Pred: pytz = None
==================
NL:call the function _trans.templatize [ _trans . templatize ] with 2 arguments : src and origin , return the result .
Tgt:  return NAME . NAME ( NAME , NAME )
Pred: return NAME . NAME ( NAME , NAME )

Tgt:  return _trans . templatize ( src , origin )
Pred: return _trans . templatize ( src , origin )
==================
NL:call the method time.localtime [ time . localtime ] with an argument stamp , substitute the result for tt .
Tgt:  NAME = NAME . NAME ( NAME )
Pred: NAME = NAME . NAME ( NAME )

Tgt:  tt = time . localtime ( stamp )
Pred: tt = time . localtime ( stamp )
==================
NL:from django.utils.encoding [ django . utils . encoding ] import force_text into default name space .
Tgt:  from NAME . NAME . NAME import NAME
Pred: from NAME . NAME . NAME import NAME

Tgt:  from django . utils . encoding import force_text
Pred: from django . utils . encoding import force_text
==================
NL:return unbound.im_func [ unbound . im_func ] .
Tgt:  return NAME . NAME
Pred: return NAME . NAME

Tgt:  return unbound . im_func
Pred: return unbound . im_func
==================
NL:for every p in parts without the first element ,
Tgt:  for NAME in NAME [ NUMBER : ] :
Pred: for NAME in NAME [ NUMBER : ] :

Tgt:  for p in parts [ 1 : ] :
Pred: for p in parts [ 1 : ] :
==================
NL:call the function force_text with an argument text , substitute the result for text .
Tgt:  NAME = NAME ( NAME )
Pred: NAME = NAME ( NAME )

Tgt:  text = force_text ( text )
Pred: text = force_text ( text )
==================
NL:define the function get_language_from_request with 2 arguments : request and check_path set to boolean False .
Tgt:  def NAME ( NAME , NAME = False ) :
Pred: def NAME ( NAME , NAME = False ) :

Tgt:  def get_language_from_request ( request , check_path = False ) :
Pred: def get_language_from_request ( request , check_path = False ) :
==================
NL:append val to self.vals [ self . vals ] .
Tgt:  NAME . NAME . NAME ( NAME )
Pred: NAME . NAME . NAME ( NAME )

Tgt:  self . vals . append ( val )
Pred: self . vals . append ( val )
==================
NL:_meth_self is a string _STR:0_ .
Tgt:  NAME = STRING
Pred: NAME = STRING

Tgt:  _meth_self = <[> _STR:0_ <]>
Pred: _meth_self = <[> _STR:0_ <]>
==================
NL:return an empty string .
Tgt:  return STRING
Pred: return STRING

Tgt:  return <[>  <]>
Pred: return <[>  <]>
==================
NL:substitute EscapeText for EscapeString .
Tgt:  NAME = NAME
Pred: NAME = NAME

Tgt:  EscapeString = EscapeText
Pred: EscapeString = EscapeText
==================
NL:call the function get_language , substitute the result for self.old_language [ self . old_language ] .
Tgt:  NAME . NAME = NAME ( )
Pred: NAME . NAME = NAME ( )

Tgt:  self . old_language = get_language ( )
Pred: self . old_language = get_language ( )
==================
NL:return boolean False .
Tgt:  return False
Pred: return False

Tgt:  return False
Pred: return False
==================
NL:return an empty string .
Tgt:  return STRING
Pred: return STRING

Tgt:  return <[>  <]>
Pred: return <[>  <]>
==================
NL:define the method dst with 2 arguments : self and dt .
Tgt:  def NAME ( NAME , NAME ) :
Pred: def NAME ( NAME , NAME ) :

Tgt:  def dst ( self , dt ) :
Pred: def dst ( self , dt ) :
==================
NL:if cmatch is true ,
Tgt:  if NAME :
Pred: if NAME :

Tgt:  if cmatch :
Pred: if cmatch :
==================
NL:filemsg is an empty string .
Tgt:  NAME = STRING
Pred: NAME = STRING

Tgt:  filemsg = <[>  <]>
Pred: filemsg = <[>  <]>
==================
NL:call the method threading.RLock [ threading . RLock ] , substitute the result for self.mutex [ self . mutex ] .
Tgt:  NAME . NAME = NAME . NAME ( )
Pred: NAME . NAME = NAME . NAME ( )

Tgt:  self . mutex = threading . RLock ( )
Pred: self . mutex = threading . RLock ( )
==================
NL:define the function slugify with an argument value .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def slugify ( value ) :
Pred: def slugify ( value ) :
==================
NL:substitute dt for self.__dt [ self . __dt ] .
Tgt:  NAME . NAME = NAME
Pred: NAME . NAME = NAME

Tgt:  self . __dt = dt
Pred: self . __dt = dt
==================
NL:derive the class metaclass form the meta base class .
Tgt:  class NAME ( NAME ) :
Pred: class NAME ( NAME ) :

Tgt:  class metaclass ( meta ) :
Pred: class metaclass ( meta ) :
==================
NL:self.waiting_readers [ self . waiting_readers ] is an integer 0 .
Tgt:  NAME . NAME = NUMBER
Pred: NAME . NAME = NUMBER

Tgt:  self . waiting_readers = 0
Pred: self . waiting_readers = 0
==================
NL:define the function ungettext with 3 arguments : singular , plural and number .
Tgt:  def NAME ( NAME , NAME , NAME ) :
Pred: def NAME ( NAME , NAME , NAME ) :

Tgt:  def ungettext ( singular , plural , number ) :
Pred: def ungettext ( singular , plural , number ) :
==================
NL:return code .
Tgt:  return NAME
Pred: return NAME

Tgt:  return code
Pred: return code
==================
NL:inplural is boolean False .
Tgt:  NAME = False
Pred: NAME = False

Tgt:  inplural = False
Pred: inplural = False
==================
NL:try ,
Tgt:  try :
Pred: try :

Tgt:  try :
Pred: try :
==================
NL:if config_string is false ,
Tgt:  if not NAME :
Pred: if not NAME :

Tgt:  if not config_string :
Pred: if not config_string :
==================
NL:substitute new_result for result .
Tgt:  NAME = NAME
Pred: NAME = NAME

Tgt:  result = new_result
Pred: result = new_result
==================
NL:if origin is true ,
Tgt:  if NAME :
Pred: if NAME :

Tgt:  if origin :
Pred: if origin :
==================
NL:for every attr in _urllib_parse_moved_attributes ,
Tgt:  for NAME in NAME :
Pred: for NAME in NAME :

Tgt:  for attr in _urllib_parse_moved_attributes :
Pred: for attr in _urllib_parse_moved_attributes :
==================
NL:get _assertRaisesRegex attribute of the self object , call the result with 2 arguments : unpacked list args ,
Tgt:  return getattr ( NAME , NAME ) ( * NAME , ** NAME )
Pred: return getattr ( NAME , NAME ) ( * NAME , ** NAME )

Tgt:  return getattr ( self , _assertRaisesRegex ) ( * args , ** kwargs )
Pred: return getattr ( self , _assertRaisesRegex ) ( * args , ** kwargs )
==================
NL:call the method timezone.localize [ timezone . localize ] with 2 arguments : value and is_dst as None , return the result .
Tgt:  return NAME . NAME ( NAME , NAME = None )
Pred: return NAME . NAME ( NAME , NAME = None )

Tgt:  return timezone . localize ( value , is_dst = None )
Pred: return timezone . localize ( value , is_dst = None )
==================
NL:get the type of the exc object , substitute it for exc_type .
Tgt:  NAME = type ( NAME )
Pred: NAME = type ( NAME )

Tgt:  exc_type = type ( exc )
Pred: exc_type = type ( exc )
==================
NL:substitute callable for callable .
Tgt:  callable = callable
Pred: callable = callable

Tgt:  callable = callable
Pred: callable = callable
==================
NL:call the function copy.deepcopy [ copy . deepcopy ] with 2 arguments : self.children [ self . children ] and memodict , substitute the result for obj.children [ obj . children ] .
Tgt:  NAME . NAME = NAME . NAME ( NAME . NAME , NAME )
Pred: NAME . NAME = NAME . NAME ( NAME . NAME , NAME )

Tgt:  obj . children = copy . deepcopy ( self . children , memodict )
Pred: obj . children = copy . deepcopy ( self . children , memodict )
==================
NL:if imatch is true ,
Tgt:  if NAME :
Pred: if NAME :

Tgt:  if imatch :
Pred: if imatch :
==================
NL:define the function ugettext with an argument message .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def ugettext ( message ) :
Pred: def ugettext ( message ) :
==================
NL:assign the result to the value under the string _STR:0_ appended to __name__ key of the sys.modules [ sys . modules ] dictionary , and to the value under the string _STR:1_ appended to __name__ key of the sys.modules [ sys . modules ] dictionary . derive class Module_six_moves_urllib_response from the _LazyModule base class .
Tgt:  class NAME ( NAME ) :
Pred: class NAME ( NAME ) :

Tgt:  class Module_six_moves_urllib_response ( _LazyModule ) :
Pred: class Module_six_moves_urllib_response ( _LazyModule ) :
==================
NL:default is a string _STR:0_ .
Tgt:  NAME = STRING
Pred: NAME = STRING

Tgt:  default = <[> _STR:0_ <]>
Pred: default = <[> _STR:0_ <]>
==================
NL:import module types .
Tgt:  import NAME
Pred: import NAME

Tgt:  import types
Pred: import types
==================
NL:if PY3 is true ,
Tgt:  if NAME :
Pred: if NAME :

Tgt:  if PY3 :
Pred: if PY3 :
==================
NL:from gzip import GzipFile into default name space .
Tgt:  from NAME import NAME
Pred: from NAME import NAME

Tgt:  from gzip import GzipFile
Pred: from gzip import GzipFile
==================
NL:use global variable _supported .
Tgt:  global NAME
Pred: global NAME

Tgt:  global _supported
Pred: global _supported
==================
NL:_func_closure is a string _STR:0_ .
Tgt:  NAME = STRING
Pred: NAME = STRING

Tgt:  _func_closure = <[> _STR:0_ <]>
Pred: _func_closure = <[> _STR:0_ <]>
==================
NL:from django.utils.translation [ django . utils . translation ] import trans_real as trans .
Tgt:  from NAME . NAME . NAME import NAME as NAME
Pred: from NAME . NAME . NAME import NAME as NAME

Tgt:  from django . utils . translation import trans_real as trans
Pred: from django . utils . translation import trans_real as trans
==================
NL:substitute gettext_noop for ugettext_noop .
Tgt:  NAME = NAME
Pred: NAME = NAME

Tgt:  ugettext_noop = gettext_noop
Pred: ugettext_noop = gettext_noop
==================
NL:call the method self._add_local_translations [ self . _add_local_translations ] .
Tgt:  NAME . NAME ( )
Pred: NAME . NAME ( )

Tgt:  self . _add_local_translations ( )
Pred: self . _add_local_translations ( )
==================
NL:if now is false ,
Tgt:  if not NAME :
Pred: if not NAME :

Tgt:  if not now :
Pred: if not now :
==================
NL:call the function func with unpacked dictionary kwargs as an argument , substitute the result for translated .
Tgt:  NAME = NAME ( ** NAME )
Pred: NAME = NAME ( ** NAME )

Tgt:  translated = func ( ** kwargs )
Pred: translated = func ( ** kwargs )
==================
NL:try ,
Tgt:  try :
Pred: try :

Tgt:  try :
Pred: try :
==================
NL:_iterlists is a string _STR:0_ .
Tgt:  NAME = STRING
Pred: NAME = STRING

Tgt:  _iterlists = <[> _STR:0_ <]>
Pred: _iterlists = <[> _STR:0_ <]>
==================
NL:call the function _trans.activate [ _trans . activate ] with an argument language , return the result .
Tgt:  return NAME . NAME ( NAME )
Pred: return NAME . NAME ( NAME )

Tgt:  return _trans . activate ( language )
Pred: return _trans . activate ( language )
==================
NL:from django.utils [ django . utils ] import six and lru_cache into default name space .
Tgt:  from NAME . NAME import NAME , NAME
Pred: from NAME . NAME import NAME , NAME

Tgt:  from django . utils import six , lru_cache
Pred: from django . utils import six , lru_cache
==================
NL:return self .
Tgt:  return NAME
Pred: return NAME

Tgt:  return self
Pred: return self
==================
NL:return it . define the function iteritems with 2 arguments : d and unpacked dictionary kw .
Tgt:  def NAME ( NAME , ** NAME ) :
Pred: def NAME ( NAME , ** NAME ) :

Tgt:  def iteritems ( d , ** kw ) :
Pred: def iteritems ( d , ** kw ) :
==================
NL:LIGHT_PALETTE is a string _STR:0_ .
Tgt:  NAME = STRING
Pred: NAME = STRING

Tgt:  LIGHT_PALETTE = <[> _STR:0_ <]>
Pred: LIGHT_PALETTE = <[> _STR:0_ <]>
==================
NL:define the method _text_chars with 5 arguments : self , length , truncate , text and truncate_len .
Tgt:  def NAME ( NAME , NAME , NAME , NAME , NAME ) :
Pred: def NAME ( NAME , NAME , NAME , NAME , NAME ) :

Tgt:  def _text_chars ( self , length , truncate , text , truncate_len ) :
Pred: def _text_chars ( self , length , truncate , text , truncate_len ) :
==================
NL:__version__ is a string _STR:0_ .
Tgt:  NAME = STRING
Pred: NAME = STRING

Tgt:  __version__ = <[> _STR:0_ <]>
Pred: __version__ = <[> _STR:0_ <]>
==================
NL:call the method get_supported_language_variant.cache_clear [ get_supported_language_variant . cache_clear ] .
Tgt:  NAME . NAME ( )
Pred: NAME . NAME ( )

Tgt:  get_supported_language_variant . cache_clear ( )
Pred: get_supported_language_variant . cache_clear ( )
==================
NL:plural is an empty list .
Tgt:  NAME = [ ]
Pred: NAME = [ ]

Tgt:  plural = [ ]
Pred: plural = [ ]
==================
NL:if errors is None ,
Tgt:  if NAME is None :
Pred: if NAME is None :

Tgt:  if errors is None :
Pred: if errors is None :
==================
NL:from __future__ import unicode_literals into default name space .
Tgt:  from NAME import NAME
Pred: from NAME import NAME

Tgt:  from __future__ import unicode_literals
Pred: from __future__ import unicode_literals
==================
NL:define the method __init__ with 2 arguments : self and name .
Tgt:  def NAME ( NAME , NAME ) :
Pred: def NAME ( NAME , NAME ) :

Tgt:  def __init__ ( self , name ) :
Pred: def __init__ ( self , name ) :
==================
NL:call the method translation._catalog.copy [ translation . _catalog . copy ] , substitute the result for self._catalog [ self . _catalog ] .
Tgt:  NAME . NAME = NAME . NAME . NAME ( )
Pred: NAME . NAME = NAME . NAME . NAME ( )

Tgt:  self . _catalog = translation . _catalog . copy ( )
Pred: self . _catalog = translation . _catalog . copy ( )
==================
NL:define the function now .
Tgt:  def NAME ( ) :
Pred: def NAME ( ) :

Tgt:  def now ( ) :
Pred: def now ( ) :
==================
NL:define the function make_naive with 2 arguments : value and timezone .
Tgt:  def NAME ( NAME , NAME ) :
Pred: def NAME ( NAME , NAME ) :

Tgt:  def make_naive ( value , timezone ) :
Pred: def make_naive ( value , timezone ) :
==================
NL:and number set to number , return the result . define the function npgettext_lazy with 4 arguments : context , singular , plural and number set to None .
Tgt:  def NAME ( NAME , NAME , NAME , NAME = None ) :
Pred: def NAME ( NAME , NAME , NAME , NAME = None ) :

Tgt:  def npgettext_lazy ( context , singular , plural , number = None ) :
Pred: def npgettext_lazy ( context , singular , plural , number = None ) :
==================
NL:increment current_len by integer 1 ,
Tgt:  NAME += NUMBER
Pred: NAME += NUMBER

Tgt:  current_len += 1
Pred: current_len += 1
==================
NL:if not ,
Tgt:  else :
Pred: else :

Tgt:  else :
Pred: else :
==================
NL:return _localtime .
Tgt:  return NAME
Pred: return NAME

Tgt:  return _localtime
Pred: return _localtime
==================
NL:get attr attribute from the _module object , substitute it for value .
Tgt:  NAME = getattr ( NAME , NAME )
Pred: NAME = getattr ( NAME , NAME )

Tgt:  value = getattr ( _module , attr )
Pred: value = getattr ( _module , attr )
==================
NL:inner_result and inner_args are empty lists .
Tgt:  NAME , NAME = [ ] , [ ]
Pred: NAME , NAME = [ ] , [ ]

Tgt:  inner_result , inner_args = [ ] , [ ]
Pred: inner_result , inner_args = [ ] , [ ]
==================
NL:derive the class override from the object base class .
Tgt:  class NAME ( object ) :
Pred: class NAME ( object ) :

Tgt:  class override ( object ) :
Pred: class override ( object ) :
==================
NL:message_context is None .
Tgt:  NAME = None
Pred: NAME = None

Tgt:  message_context = None
Pred: message_context = None
==================
NL:raise an TypeError exception with an argument string _STR:0_ .
Tgt:  raise NAME ( STRING )
Pred: raise NAME ( STRING )

Tgt:  raise TypeError ( <[> _STR:0_ <]> )
Pred: raise TypeError ( <[> _STR:0_ <]> )
==================
NL:return timezone.zone [ timezone . zone ] .
Tgt:  return NAME . NAME
Pred: return NAME . NAME

Tgt:  return timezone . zone
Pred: return timezone . zone
==================
NL:call the method self.can_read.acquire [ self . can_read . acquire ] .
Tgt:  NAME . NAME . NAME ( )
Pred: NAME . NAME . NAME ( )

Tgt:  self . can_read . acquire ( )
Pred: self . can_read . acquire ( )
==================
NL:define the method flush with an argument self .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def flush ( self ) :
Pred: def flush ( self ) :
==================
NL:try ,
Tgt:  try :
Pred: try :

Tgt:  try :
Pred: try :
==================
NL:for every slots_var in slots ,
Tgt:  for NAME in NAME :
Pred: for NAME in NAME :

Tgt:  for slots_var in slots :
Pred: for slots_var in slots :
==================
NL:return an instance of metaclass class , created with 3 arguments : string _STR:0_ , None and an empty dictionary .
Tgt:  return NAME ( STRING , None , { } )
Pred: return NAME ( STRING , None , { } )

Tgt:  return metaclass ( <[> _STR:0_ <]> , None , { } )
Pred: return metaclass ( <[> _STR:0_ <]> , None , { } )
==================
NL:substitute cls for obj.__class__ [ obj . __class__ ] .
Tgt:  NAME . NAME = NAME
Pred: NAME . NAME = NAME

Tgt:  obj . __class__ = cls
Pred: obj . __class__ = cls
==================
NL:cal the method self.startElement [ self . startElement ] with 2 arguments : name and attrs .
Tgt:  NAME . NAME ( NAME , NAME )
Pred: NAME . NAME ( NAME , NAME )

Tgt:  self . startElement ( name , attrs )
Pred: self . startElement ( name , attrs )
==================
NL:delete attr .
Tgt:  del NAME
Pred: del NAME

Tgt:  del attr
Pred: del attr
==================
NL:_default is None .
Tgt:  NAME = None
Pred: NAME = None

Tgt:  _default = None
Pred: _default = None
==================
NL:import module os .
Tgt:  import NAME
Pred: import NAME

Tgt:  import os
Pred: import os
==================
NL:derive class MovedModule from the _LazyDescr base class .
Tgt:  class NAME ( NAME ) :
Pred: class NAME ( NAME ) :

Tgt:  class MovedModule ( _LazyDescr ) :
Pred: class MovedModule ( _LazyDescr ) :
==================
NL:call the method deactivate .
Tgt:  NAME ( )
Pred: NAME ( )

Tgt:  deactivate ( )
Pred: deactivate ( )
==================
NL:decrement truncate_len by integer 1 .
Tgt:  NAME -= NUMBER
Pred: NAME -= NUMBER

Tgt:  truncate_len -= 1
Pred: truncate_len -= 1
==================
NL:try ,
Tgt:  try :
Pred: try :

Tgt:  try :
Pred: try :
==================
NL:call the method bmatch.group [ bmatch . group ] with an argument integer 1 , if it evaluates to true ,
Tgt:  if NAME . NAME ( NUMBER ) :
Pred: if NAME . NAME ( NUMBER ) :

Tgt:  if bmatch . group ( 1 ) :
Pred: if bmatch . group ( 1 ) :
==================
NL:if six.PY3 [ six . PY3 ] is true ,
Tgt:  if NAME . NAME :
Pred: if NAME . NAME :

Tgt:  if six . PY3 :
Pred: if six . PY3 :
==================
NL:define the function _replace_entity with an argument match .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def _replace_entity ( match ) :
Pred: def _replace_entity ( match ) :
==================
NL:from __future__ import absolute_import into default name space .
Tgt:  from NAME import NAME
Pred: from NAME import NAME

Tgt:  from __future__ import absolute_import
Pred: from __future__ import absolute_import
==================
NL:if arg is an instance of unicode ,
Tgt:  if isinstance ( NAME , unicode ) :
Pred: if isinstance ( NAME , NAME ) :

Tgt:  if isinstance ( arg , unicode ) :
Pred: if isinstance ( arg , unicode ) :
==================
NL:return obj .
Tgt:  return NAME
Pred: return NAME

Tgt:  return obj
Pred: return obj
==================
NL:if message is an instance of SafeData ,
Tgt:  if isinstance ( NAME , NAME ) :
Pred: if isinstance ( NAME , NAME ) :

Tgt:  if isinstance ( message , SafeData ) :
Pred: if isinstance ( message , SafeData ) :
==================
NL:call the nethod self._isdst [ self . _isdst ] with an argument dt , if it evaluates to true ,
Tgt:  if NAME . NAME ( NAME ) :
Pred: if NAME . NAME ( NAME ) :

Tgt:  if self . _isdst ( dt ) :
Pred: if self . _isdst ( dt ) :
==================
NL:import module datetime .
Tgt:  import NAME
Pred: import NAME

Tgt:  import datetime
Pred: import datetime
==================
NL:if m is false ,
Tgt:  if not NAME :
Pred: if not NAME :

Tgt:  if not m :
Pred: if not m :
==================
NL:_STR:0_ and RemovedInDjango19Warning . call the method tzinfo.__init__ [ tzinfo . __init__ ] with an argument self .
Tgt:  NAME . NAME ( NAME )
Pred: NAME . NAME ( NAME )

Tgt:  tzinfo . __init__ ( self )
Pred: tzinfo . __init__ ( self )
==================
NL:from django.utils.six [ django . utils . six ] import StringIO into default name space .
Tgt:  from NAME . NAME . NAME import NAME
Pred: from NAME . NAME . NAME import NAME

Tgt:  from django . utils . six import StringIO
Pred: from django . utils . six import StringIO
==================
NL:call the function re.compile [ re . compile ] with an argument raw string _STR:0_ , substitute the result for plural_re .
Tgt:  NAME = re . compile ( STRING )
Pred: NAME = re . compile ( STRING )

Tgt:  plural_re = re . compile ( <[> _STR:0_ <]> )
Pred: plural_re = re . compile ( <[> _STR:0_ <]> )
==================
NL:define the method reader with an argument self .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def reader ( self ) :
Pred: def reader ( self ) :
==================
NL:define the method tzname with 2 arguments self and dt .
Tgt:  def NAME ( NAME , NAME ) :
Pred: def NAME ( NAME , NAME ) :

Tgt:  def tzname ( self , dt ) :
Pred: def tzname ( self , dt ) :
==================
NL:_moved_attributes is an empty list .
Tgt:  NAME = [ ]
Pred: NAME = [ ]

Tgt:  _moved_attributes = [ ]
Pred: _moved_attributes = [ ]
==================
NL:call the function inline_re.match [ inline_re . match ] with an argument t.contents [ t . contents ] , substitute the result for imatch .
Tgt:  NAME = NAME . NAME ( NAME . NAME )
Pred: NAME = NAME . NAME ( NAME . NAME )

Tgt:  imatch = inline_re . match ( t . contents )
Pred: imatch = inline_re . match ( t . contents )
==================
NL:define the function deactivate .
Tgt:  def NAME ( ) :
Pred: def NAME ( ) :

Tgt:  def deactivate ( ) :
Pred: def deactivate ( ) :
==================
NL:call the method __init__ with an argument name form the base class of the class MovedAttribute .
Tgt:  super ( NAME , NAME ) . NAME ( NAME )
Pred: super ( NAME , NAME ) . NAME ( NAME )

Tgt:  super ( MovedAttribute , self ) . __init__ ( name )
Pred: super ( MovedAttribute , self ) . __init__ ( name )
==================
NL:define the function ngettext with 3 arguments : singular , plural and number .
Tgt:  def NAME ( NAME , NAME , NAME ) :
Pred: def NAME ( NAME , NAME , NAME ) :

Tgt:  def ngettext ( singular , plural , number ) :
Pred: def ngettext ( singular , plural , number ) :
==================
NL:call the function force_text with first element of list_ as an argument , return the result .
Tgt:  return NAME ( NAME [ NUMBER ] )
Pred: return NAME ( NAME [ NUMBER ] )

Tgt:  return force_text ( list_ [ 0 ] )
Pred: return force_text ( list_ [ 0 ] )
==================
NL:define the function get_language_info with an argument lang_code .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def get_language_info ( lang_code ) :
Pred: def get_language_info ( lang_code ) :
==================
NL:if p is greater or equal to integer 0 ,
Tgt:  if NAME >= NUMBER :
Pred: if NAME >= NUMBER :

Tgt:  if p >= 0 :
Pred: if p >= 0 :
==================
NL:derive class _LazyDescr from the object base class .
Tgt:  class NAME ( object ) :
Pred: class NAME ( object ) :

Tgt:  class _LazyDescr ( object ) :
Pred: class _LazyDescr ( object ) :
==================
NL:if not ,
Tgt:  else :
Pred: else :

Tgt:  else :
Pred: else :
==================
NL:call the method constant_re.match [ constant_re . match ] with first element of parts as an argument , substitute the result for cmatch .
Tgt:  NAME = NAME . NAME ( NAME [ NUMBER ] )
Pred: NAME = NAME . NAME ( NAME [ NUMBER ] )

Tgt:  cmatch = constant_re . match ( parts [ 0 ] )
Pred: cmatch = constant_re . match ( parts [ 0 ] )
==================
NL:try
Tgt:  try :
Pred: try :

Tgt:  try :
Pred: try :
==================
NL:if truncate_text is true ,
Tgt:  if NAME :
Pred: if NAME :

Tgt:  if truncate_text :
Pred: if truncate_text :
==================
NL:extend list inner_args with args .
Tgt:  NAME . NAME ( NAME )
Pred: NAME . NAME ( NAME )

Tgt:  inner_args . extend ( args )
Pred: inner_args . extend ( args )
==================
NL:return an instance of SafeText , created with an argument data .
Tgt:  return NAME ( NAME )
Pred: return NAME ( NAME )

Tgt:  return SafeText ( data )
Pred: return SafeText ( data )
==================
NL:from django.utils [ django . utils ] import six into default name space .
Tgt:  from NAME . NAME import NAME
Pred: from NAME . NAME import NAME

Tgt:  from django . utils import six
Pred: from django . utils import six
==================
NL:if t is not None
Tgt:  if NAME is not None :
Pred: if NAME is not None :

Tgt:  if t is not None :
Pred: if t is not None :
==================
NL:return s .
Tgt:  return NAME
Pred: return NAME

Tgt:  return s
Pred: return s
==================
NL:substitute ngettext for ungettext .
Tgt:  NAME = NAME
Pred: NAME = NAME

Tgt:  ungettext = ngettext
Pred: ungettext = ngettext
==================
NL:if html is true ,
Tgt:  if NAME :
Pred: if NAME :

Tgt:  if html :
Pred: if html :
==================
NL:define the method add with 4 arguments : self , data , conn_type and squash set to boolean True .
Tgt:  def NAME ( NAME , NAME , NAME , NAME = True ) :
Pred: def NAME ( NAME , NAME , NAME , NAME = True ) :

Tgt:  def add ( self , data , conn_type , squash = True ) :
Pred: def add ( self , data , conn_type , squash = True ) :
==================
NL:and generic_lang_code . call the function re.compile [ re . compile ] with an argument string _STR:0_ , substitute the result for trim_whitespace_re .
Tgt:  NAME = re . compile ( STRING )
Pred: NAME = re . compile ( STRING )

Tgt:  trim_whitespace_re = re . compile ( <[> _STR:0_ <]> )
Pred: trim_whitespace_re = re . compile ( <[> _STR:0_ <]> )
==================
NL:if _locs_ is None ,
Tgt:  if NAME is None :
Pred: if NAME is None :

Tgt:  if _locs_ is None :
Pred: if _locs_ is None :
==================
NL:substitute old_attr for new_attr .
Tgt:  NAME = NAME
Pred: NAME = NAME

Tgt:  new_attr = old_attr
Pred: new_attr = old_attr
==================
NL:define the function write with an argument data .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def write ( data ) :
Pred: def write ( data ) :
==================
NL:substitute buffer for memoryview .
Tgt:  memoryview = NAME
Pred: NAME = NAME

Tgt:  memoryview = buffer
Pred: memoryview = buffer
==================
NL:replace ' % s ' in string _STR:0_ with tag , append the result to out .
Tgt:  NAME += STRING % NAME
Pred: NAME += STRING % NAME

Tgt:  out += <[> _STR:0_ <]> % tag
Pred: out += <[> _STR:0_ <]> % tag
==================
NL:substitute type.__init__ [ type . __init__ ] for __init__ .
Tgt:  NAME = type . NAME
Pred: NAME = NAME . NAME

Tgt:  __init__ = type . __init__
Pred: __init__ = type . __init__
==================
NL:call the function _trans.deactivate_all [ _trans . deactivate_all ] , return the result .
Tgt:  return NAME . NAME ( )
Pred: return NAME . NAME ( )

Tgt:  return _trans . deactivate_all ( )
Pred: return _trans . deactivate_all ( )
==================
NL:return result and result_args .
Tgt:  return NAME , NAME
Pred: return NAME , NAME

Tgt:  return result , result_args
Pred: return result , result_args
==================
NL:if settings.USE_I18N [ settings . USE_I18N ] is true ,
Tgt:  if NAME . NAME :
Pred: if NAME . NAME :

Tgt:  if settings . USE_I18N :
Pred: if settings . USE_I18N :
==================
NL:define the function do_ntranslate with 4 arguments : singular , plural , number and translation_function .
Tgt:  def NAME ( NAME , NAME , NAME , NAME ) :
Pred: def NAME ( NAME , NAME , NAME , NAME ) :

Tgt:  def do_ntranslate ( singular , plural , number , translation_function ) :
Pred: def do_ntranslate ( singular , plural , number , translation_function ) :
==================
NL:convert language to lowercase , return it .
Tgt:  return NAME . NAME ( )
Pred: return NAME . NAME ( )

Tgt:  return language . lower ( )
Pred: return language . lower ( )
==================
NL:define the function get_text_list with 2 arguments : list_ and last_word set to result of the function ugettext_lazy called with an argument string _STR:0_ .
Tgt:  def NAME ( NAME , NAME = NAME ( STRING ) ) :
Pred: def NAME ( NAME , NAME = NAME ( STRING ) ) :

Tgt:  def get_text_list ( list_ , last_word = ugettext_lazy ( <[> _STR:0_ <]> ) ) :
Pred: def get_text_list ( list_ , last_word = ugettext_lazy ( <[> _STR:0_ <]> ) ) :
==================
NL:try ,
Tgt:  try :
Pred: try :

Tgt:  try :
Pred: try :
==================
NL:define the function _import_module with an argument name .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def _import_module ( name ) :
Pred: def _import_module ( name ) :
==================
NL:return the string . define the function make_style with 2 arguments : opts set to an empty tuple and unpacked dictionary kwargs .
Tgt:  def NAME ( NAME = ( ) , ** NAME ) :
Pred: def NAME ( NAME = ( ) , ** NAME ) :

Tgt:  def make_style ( opts = ( ) , ** kwargs ) :
Pred: def make_style ( opts = ( ) , ** kwargs ) :
==================
NL:try ,
Tgt:  try :
Pred: try :

Tgt:  try :
Pred: try :
==================
NL:plural set to plural and number set to number , return the result . define the function activate with an argument language .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def activate ( language ) :
Pred: def activate ( language ) :
==================
NL:self.active_readers [ self . active_readers ] is an integer 0 .
Tgt:  NAME . NAME = NUMBER
Pred: NAME . NAME = NUMBER

Tgt:  self . active_readers = 0
Pred: self . active_readers = 0
==================
NL:get the value under the part key of the PALETTES dictionary , update with it palette dictionary .
Tgt:  NAME . NAME ( NAME [ NAME ] )
Pred: NAME . NAME ( NAME [ NAME ] )

Tgt:  palette . update ( PALETTES [ part ] )
Pred: palette . update ( PALETTES [ part ] )
==================
NL:and fileobj set to zbuf . call the method zfile.write [ zfile . write ] with an argument s .
Tgt:  NAME . NAME ( NAME )
Pred: NAME . NAME ( NAME )

Tgt:  zfile . write ( s )
Pred: zfile . write ( s )
==================
NL:if not ,
Tgt:  else :
Pred: else :

Tgt:  else :
Pred: else :
==================
NL:return text .
Tgt:  return NAME
Pred: return NAME

Tgt:  return text
Pred: return text
==================
NL:define the method _new_gnu_trans with 3 arguments : self , localedir and use_null_fallback set to boolean True .
Tgt:  def NAME ( NAME , NAME , NAME = True ) :
Pred: def NAME ( NAME , NAME , NAME = True ) :

Tgt:  def _new_gnu_trans ( self , localedir , use_null_fallback = True ) :
Pred: def _new_gnu_trans ( self , localedir , use_null_fallback = True ) :
==================
NL:define the function int2byte with an argument i .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def int2byte ( i ) :
Pred: def int2byte ( i ) :
==================
NL:define the function _get_timezone_name with an argument timezone .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def _get_timezone_name ( timezone ) :
Pred: def _get_timezone_name ( timezone ) :
==================
NL:return self.STDOFFSET [ self . STDOFFSET ] .
Tgt:  return NAME . NAME
Pred: return NAME . NAME

Tgt:  return self . STDOFFSET
Pred: return self . STDOFFSET
==================
NL:call the method language_code_re.search [ language_code_re . search ] with an argument accept_lang , if it evaluates to false ,
Tgt:  if not NAME . NAME ( NAME ) :
Pred: if not NAME . NAME ( NAME ) :

Tgt:  if not language_code_re . search ( accept_lang ) :
Pred: if not language_code_re . search ( accept_lang ) :
==================
NL:decrement t by integer 1 ,
Tgt:  NAME -= NUMBER
Pred: NAME -= NUMBER

Tgt:  t -= 1
Pred: t -= 1
==================
NL:if number is an instance of int type .
Tgt:  if isinstance ( NAME , int ) :
Pred: if isinstance ( NAME , int ) :

Tgt:  if isinstance ( number , int ) :
Pred: if isinstance ( number , int ) :
==================
NL:otherwise if t.token_type [ t . token_type ] equals TOKEN_COMMENT ,
Tgt:  elif NAME . NAME == NAME :
Pred: elif NAME . NAME == NAME :

Tgt:  elif t . token_type == TOKEN_COMMENT :
Pred: elif t . token_type == TOKEN_COMMENT :
==================
NL:comment_lineno_cache is None .
Tgt:  NAME = None
Pred: NAME = None

Tgt:  comment_lineno_cache = None
Pred: comment_lineno_cache = None
==================
NL:return self.__name [ self . __name ] .
Tgt:  return NAME . NAME
Pred: return NAME . NAME

Tgt:  return self . __name
Pred: return self . __name
==================
NL:get the value under the _STR:0_ key of the orig_vars dictionary , substitute it for slots .
Tgt:  NAME = NAME . NAME ( STRING )
Pred: NAME = NAME . NAME ( STRING )

Tgt:  slots = orig_vars . get ( <[> _STR:0_ <]> )
Pred: slots = orig_vars . get ( <[> _STR:0_ <]> )
==================
NL:call te method operator.itemgetter [ operator . itemgetter ] with an argument integer 0 , substitute the result for byte2int .
Tgt:  NAME = NAME . NAME ( NUMBER )
Pred: NAME = NAME . NAME ( NUMBER )

Tgt:  byte2int = operator . itemgetter ( 0 )
Pred: byte2int = operator . itemgetter ( 0 )
==================
NL:delete attr .
Tgt:  del NAME
Pred: del NAME

Tgt:  del attr
Pred: del attr
==================
NL:derive class MovedAttribute from the _LazyDescr base class .
Tgt:  class NAME ( NAME ) :
Pred: class NAME ( NAME ) :

Tgt:  class MovedAttribute ( _LazyDescr ) :
Pred: class MovedAttribute ( _LazyDescr ) :
==================
NL:call the method self._new_instance [ self . _new_instance ] with 3 arguments : self.children [ self . children ] , self.connector [ self . connector ] and self.negated [ self . negated ] , substitute the result for obj .
Tgt:  NAME = NAME . NAME ( NAME . NAME , NAME . NAME , NAME . NAME )
Pred: NAME = NAME . NAME ( NAME . NAME , NAME . NAME , NAME . NAME )

Tgt:  obj = self . _new_instance ( self . children , self . connector , self . negated )
Pred: obj = self . _new_instance ( self . children , self . connector , self . negated )
==================
NL:call the timestamp.strftime [ timestamp . strftime ] with string _STR:0_ as an argument , substitute the result for changeset .
Tgt:  NAME = NAME . NAME ( STRING )
Pred: NAME = NAME . NAME ( STRING )

Tgt:  changeset = timestamp . strftime ( <[> _STR:0_ <]> )
Pred: changeset = timestamp . strftime ( <[> _STR:0_ <]> )
==================
NL:return boolean True , otherwise return boolean False . define the function is_naive with an argument value .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def is_naive ( value ) :
Pred: def is_naive ( value ) :
==================
NL:return an instance of metaclass class , created with 3 arguments : cls.__name__ [ cls . __name__ ] , cls.__bases__ [ cls . __bases__ ] and orig_vars .
Tgt:  return NAME ( NAME . NAME , NAME . NAME , NAME )
Pred: return NAME ( NAME . NAME , NAME . NAME , NAME )

Tgt:  return metaclass ( cls . __name__ , cls . __bases__ , orig_vars )
Pred: return metaclass ( cls . __name__ , cls . __bases__ , orig_vars )
==================
NL:define the method tzname with 2 arguments self and dt .
Tgt:  def NAME ( NAME , NAME ) :
Pred: def NAME ( NAME , NAME ) :

Tgt:  def tzname ( self , dt ) :
Pred: def tzname ( self , dt ) :
==================
NL:delete _active.value [ _active . value ] .
Tgt:  del NAME . NAME
Pred: del NAME . NAME

Tgt:  del _active . value
Pred: del _active . value
==================
NL:define the method writer with an argument self .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def writer ( self ) :
Pred: def writer ( self ) :
==================
NL:remove kwargs dictionary element under the _STR:0_ key , substitute it for method .
Tgt:  NAME = NAME . NAME ( STRING )
Pred: NAME = NAME . NAME ( STRING )

Tgt:  method = kwargs . pop ( <[> _STR:0_ <]> )
Pred: method = kwargs . pop ( <[> _STR:0_ <]> )
==================
NL:import module contextlib .
Tgt:  import NAME
Pred: import NAME

Tgt:  import contextlib
Pred: import contextlib
==================
NL:try ,
Tgt:  try :
Pred: try :

Tgt:  try :
Pred: try :
==================
NL:get the LANG_INFO dictionary value under the generic_lang_code key , return the result .
Tgt:  return NAME [ NAME ]
Pred: return NAME [ NAME ]

Tgt:  return LANG_INFO [ generic_lang_code ]
Pred: return LANG_INFO [ generic_lang_code ]
==================
NL:return None .
Tgt:  return None
Pred: return None

Tgt:  return None
Pred: return None
==================
NL:return unbound .
Tgt:  return NAME
Pred: return NAME

Tgt:  return unbound
Pred: return unbound
==================
NL:define the function wrap with 2 arguments text and width .
Tgt:  def NAME ( NAME , NAME ) :
Pred: def NAME ( NAME , NAME ) :

Tgt:  def wrap ( text , width ) :
Pred: def wrap ( text , width ) :
==================
NL:if not accept is an empty string . call the function parse_accept_lang_header with an argument accept , for every accept_lang and unused in the result ,
Tgt:  for NAME , NAME in NAME ( NAME ) :
Pred: for NAME , NAME in NAME ( NAME ) :

Tgt:  for accept_lang , unused in parse_accept_lang_header ( accept ) :
Pred: for accept_lang , unused in parse_accept_lang_header ( accept ) :
==================
NL:substitute _urllib_error_moved_attributes for Module_six_moves_urllib_error._moved_attributes [ Module_six_moves_urllib_error . _moved_attributes ] .
Tgt:  NAME . NAME = NAME
Pred: NAME . NAME = NAME

Tgt:  Module_six_moves_urllib_error . _moved_attributes = _urllib_error_moved_attributes
Pred: Module_six_moves_urllib_error . _moved_attributes = _urllib_error_moved_attributes
==================
NL:return an instance of SafeBytes , created with an argument s .
Tgt:  return NAME ( NAME )
Pred: return NAME ( NAME )

Tgt:  return SafeBytes ( s )
Pred: return SafeBytes ( s )
==================
NL:translators_comment_start is None .
Tgt:  NAME = None
Pred: NAME = None

Tgt:  translators_comment_start = None
Pred: translators_comment_start = None
==================
NL:if end is an instance of unicode ,
Tgt:  if isinstance ( NAME , unicode ) :
Pred: if isinstance ( NAME , NAME ) :

Tgt:  if isinstance ( end , unicode ) :
Pred: if isinstance ( end , unicode ) :
==================
NL:skip this loop iteration , s
Tgt:  NAME
Pred: NAME

Tgt:  continue
Pred: continue
==================
NL:if not ,
Tgt:  else :
Pred: else :

Tgt:  else :
Pred: else :
==================
NL:call the function _generator , join the result into a string , return the result .
Tgt:  return STRING . NAME ( NAME ( ) )
Pred: return STRING . NAME ( NAME ( ) )

Tgt:  return <[>  <]> . join ( _generator ( ) )
Pred: return <[>  <]> . join ( _generator ( ) )
==================
NL:otherwise if cmatches is true ,
Tgt:  elif NAME :
Pred: elif NAME :

Tgt:  elif cmatches :
Pred: elif cmatches :
==================
NL:call the function translation with an argument settings.LANGUAGE_CODE [ settings . LANGUAGE_CODE ] , substitute the result for default_translation .
Tgt:  NAME = NAME ( NAME . NAME )
Pred: NAME = NAME ( NAME . NAME )

Tgt:  default_translation = translation ( settings . LANGUAGE_CODE )
Pred: default_translation = translation ( settings . LANGUAGE_CODE )
==================
NL:define the function lazy_number with 4 arguments : func , resultclass , number set to None and unpacked dictionary kwargs .
Tgt:  def NAME ( NAME , NAME , NAME = None , ** NAME ) :
Pred: def NAME ( NAME , NAME , NAME = None , ** NAME ) :

Tgt:  def lazy_number ( func , resultclass , number = None , ** kwargs ) :
Pred: def lazy_number ( func , resultclass , number = None , ** kwargs ) :
==================
NL:define the method _text_words with 3 arguments : self , length and truncate .
Tgt:  def NAME ( NAME , NAME , NAME ) :
Pred: def NAME ( NAME , NAME , NAME ) :

Tgt:  def _text_words ( self , length , truncate ) :
Pred: def _text_words ( self , length , truncate ) :
==================
NL:if length of list_ equals integer 1 ,
Tgt:  if len ( NAME ) == NUMBER :
Pred: if len ( NAME ) == NUMBER :

Tgt:  if len ( list_ ) == 1 :
Pred: if len ( list_ ) == 1 :
==================
NL:from django.utils [ django . utils ] import six into default name space .
Tgt:  from NAME . NAME import NAME
Pred: from NAME . NAME import NAME

Tgt:  from django . utils import six
Pred: from django . utils import six
==================
NL:if not ,
Tgt:  else :
Pred: else :

Tgt:  else :
Pred: else :
==================
NL:_translations is an empty dictionary .
Tgt:  NAME = { }
Pred: NAME = { }

Tgt:  _translations = { }
Pred: _translations = { }
==================
NL:substitute callable for callable .
Tgt:  callable = callable
Pred: callable = callable

Tgt:  callable = callable
Pred: callable = callable
==================
NL:call the function force_str with an argument self._tzname [ self . _tzname ] , return the result .
Tgt:  return NAME ( NAME . NAME )
Pred: return NAME ( NAME . NAME )

Tgt:  return force_str ( self . _tzname )
Pred: return force_str ( self . _tzname )
==================
NL:if not ,
Tgt:  else :
Pred: else :

Tgt:  else :
Pred: else :
==================
NL:define the function b with an argument s .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def b ( s ) :
Pred: def b ( s ) :
==================
NL:if trim is true ,
Tgt:  if NAME :
Pred: if NAME :

Tgt:  if trim :
Pred: if trim :
==================
NL:define the method __mod__ with 2 arguments : self and rhs .
Tgt:  def NAME ( NAME , NAME ) :
Pred: def NAME ( NAME , NAME ) :

Tgt:  def __mod__ ( self , rhs ) :
Pred: def __mod__ ( self , rhs ) :
==================
NL:if message_context is true ,
Tgt:  if NAME :
Pred: if NAME :

Tgt:  if message_context :
Pred: if message_context :
==================
NL:define the function get_default_timezone .
Tgt:  def NAME ( ) :
Pred: def NAME ( ) :

Tgt:  def get_default_timezone ( ) :
Pred: def get_default_timezone ( ) :
==================
NL:for every i and arg in enumerated iterable args ,
Tgt:  for NAME , NAME in enumerate ( NAME ) :
Pred: for NAME , NAME in enumerate ( NAME ) :

Tgt:  for i , arg in enumerate ( args ) :
Pred: for i , arg in enumerate ( args ) :
==================
NL:if not ,
Tgt:  else :
Pred: else :

Tgt:  else :
Pred: else :
==================
NL:lineno_comment_map is an dictionary .
Tgt:  NAME = { }
Pred: NAME = { }

Tgt:  lineno_comment_map = { }
Pred: lineno_comment_map = { }
==================
NL:import module subprocess .
Tgt:  import NAME
Pred: import NAME

Tgt:  import subprocess
Pred: import subprocess
==================
NL:try ,
Tgt:  try :
Pred: try :

Tgt:  try :
Pred: try :
==================
NL:define the function ngettext_lazy with 3 arguments : singular , plural and number set to None .
Tgt:  def NAME ( NAME , NAME , NAME = None ) :
Pred: def NAME ( NAME , NAME , NAME = None ) :

Tgt:  def ngettext_lazy ( singular , plural , number = None ) :
Pred: def ngettext_lazy ( singular , plural , number = None ) :
==================
NL:define the function ungettext with 3 arguments : singular , plural and number .
Tgt:  def NAME ( NAME , NAME , NAME ) :
Pred: def NAME ( NAME , NAME , NAME ) :

Tgt:  def ungettext ( singular , plural , number ) :
Pred: def ungettext ( singular , plural , number ) :
==================
NL:result is a list containing an empty string .
Tgt:  NAME = [ STRING ]
Pred: NAME = [ STRING ]

Tgt:  result = [ <[>  <]> ]
Pred: result = [ <[>  <]> ]
==================
NL:return proxy .
Tgt:  return NAME
Pred: return NAME

Tgt:  return proxy
Pred: return proxy
==================
NL:call the get_complete_version with an argument version , store the result in version .
Tgt:  NAME = NAME ( NAME )
Pred: NAME = NAME ( NAME )

Tgt:  version = get_complete_version ( version )
Pred: version = get_complete_version ( version )
==================
NL:if LookupError exception is caught ,
Tgt:  except NAME :
Pred: except NAME :

Tgt:  except LookupError :
Pred: except LookupError :
==================
NL:if not ,
Tgt:  else :
Pred: else :

Tgt:  else :
Pred: else :
==================
NL:call the method cls.__dict__.copy [ cls . __dict__ . copy ] substitute the result for orig_vars .
Tgt:  NAME = NAME . NAME . NAME ( )
Pred: NAME = NAME . NAME . NAME ( )

Tgt:  orig_vars = cls . __dict__ . copy ( )
Pred: orig_vars = cls . __dict__ . copy ( )
==================
NL:define the function all_locale_paths .
Tgt:  def NAME ( ) :
Pred: def NAME ( ) :

Tgt:  def all_locale_paths ( ) :
Pred: def all_locale_paths ( ) :
==================
NL:define the function deactivate .
Tgt:  def NAME ( ) :
Pred: def NAME ( ) :

Tgt:  def deactivate ( ) :
Pred: def deactivate ( ) :
==================
NL:substitute newline character for newline .
Tgt:  NAME = STRING
Pred: NAME = STRING

Tgt:  newline = <[> \n <]>
Pred: newline = <[> \n <]>
==================
NL:intrans is boolean False .
Tgt:  NAME = False
Pred: NAME = False

Tgt:  intrans = False
Pred: intrans = False
==================
NL:raise an TypeError exception with an argument string _STR:0_ .
Tgt:  raise NAME ( STRING )
Pred: raise NAME ( STRING )

Tgt:  raise TypeError ( <[> _STR:0_ <]> )
Pred: raise TypeError ( <[> _STR:0_ <]> )
==================
NL:import module sys .
Tgt:  import NAME
Pred: import NAME

Tgt:  import sys
Pred: import sys
==================
NL:define the function b with an argument s .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def b ( s ) :
Pred: def b ( s ) :
==================
NL:for every i and char in enumerated text ,
Tgt:  for NAME , NAME in enumerate ( NAME ) :
Pred: for NAME , NAME in enumerate ( NAME ) :

Tgt:  for i , char in enumerate ( text ) :
Pred: for i , char in enumerate ( text ) :
*** good long arguments
==================
NL:call the function curry with 2 arguments : _proxy_method and method set to six.text_type.encode [ six . text_type . encode ] , substitute the result for encode .
Tgt:  NAME = NAME ( NAME , NAME = NAME . NAME . NAME )
Pred: NAME = NAME ( NAME , NAME = NAME . NAME . NAME )

Tgt:  encode = curry ( _proxy_method , method = six . text_type . encode )
Pred: encode = curry ( _proxy_method , method = six . text_type . encode )
==================
NL:replace every occurrence of _STR:0_ in s with _STR:1_ .
Tgt:  NAME = NAME . NAME ( STRING , STRING )
Pred: NAME = NAME . NAME ( STRING , STRING )

Tgt:  s = s . replace ( <[> _STR:0_ <]> , <[> _STR:1_ <]> )
Pred: s = s . replace ( <[> _STR:0_ <]> , <[> _STR:1_ <]> )
==================
NL:params is an empty list ,
Tgt:  NAME = [ ]
Pred: NAME = [ ]

Tgt:  params = [ ]
Pred: params = [ ]
==================
NL:message_context is None .
Tgt:  NAME = None
Pred: NAME = None

Tgt:  message_context = None
Pred: message_context = None
==================
NL:call the method translation._info.copy [ translation . _info . copy ] , substitute the result for self._info [ self . _info ] .
Tgt:  NAME . NAME = NAME . NAME . NAME ( )
Pred: NAME . NAME = NAME . NAME . NAME ( )

Tgt:  self . _info = translation . _info . copy ( )
Pred: self . _info = translation . _info . copy ( )
==================
NL:call the function get_supported_language_variant with an argument accept_lang , return the result .
Tgt:  return NAME ( NAME )
Pred: return NAME ( NAME )

Tgt:  return get_supported_language_variant ( accept_lang )
Pred: return get_supported_language_variant ( accept_lang )
==================
NL:from django.dispatch [ django . dispatch ] import receiver into default name space .
Tgt:  from NAME . NAME import NAME
Pred: from NAME . NAME import NAME

Tgt:  from django . dispatch import receiver
Pred: from django . dispatch import receiver
==================
NL:decorator function lru_cache.lru_cache [ lru_cache . lru_cache ] with an argument maxsize set to integer 1000 .
Tgt:  @ NAME . NAME ( NAME = NUMBER )
Pred: @ NAME . NAME ( NAME = NUMBER )

Tgt:  @ lru_cache . lru_cache ( maxsize = 1000 )
Pred: @ lru_cache . lru_cache ( maxsize = 1000 )
==================
NL:from django.utils.html [ django . utils . html ] import avoid_wrapping into default name space .
Tgt:  from NAME . NAME . NAME import NAME
Pred: from NAME . NAME . NAME import NAME

Tgt:  from django . utils . html import avoid_wrapping
Pred: from django . utils . html import avoid_wrapping
*** good copy
==================
NL:if lang_code is not contained in _supported and replacement is contained in _supported ,
Tgt:  if NAME not in NAME and NAME in NAME :
Pred: if NAME not in NAME and NAME in NAME :

Tgt:  if lang_code not in _supported and replacement in _supported :
Pred: if lang_code not in _supported and replacement in _supported :
==================
NL:define the method _isdst with 2 arguments : self and dt .
Tgt:  def NAME ( NAME , NAME ) :
Pred: def NAME ( NAME , NAME ) :

Tgt:  def _isdst ( self , dt ) :
Pred: def _isdst ( self , dt ) :
==================
NL:if part is contained in PALETTES ,
Tgt:  if NAME in NAME :
Pred: if NAME in NAME :

Tgt:  if part in PALETTES :
Pred: if part in PALETTES :
==================
NL:substitute sys.maxsize [ sys . maxsize ] for MAXSIZE .
Tgt:  NAME = NAME . NAME
Pred: NAME = NAME . NAME

Tgt:  MAXSIZE = sys . maxsize
Pred: MAXSIZE = sys . maxsize
==================
NL:append data to self.children [ self . children ] .
Tgt:  NAME . NAME . NAME ( NAME )
Pred: NAME . NAME . NAME ( NAME )

Tgt:  self . children . append ( data )
Pred: self . children . append ( data )
==================
NL:call the method tzinfo.__init__ [ tzinfo . __init__ ] with an argument self .
Tgt:  NAME . NAME ( NAME )
Pred: NAME . NAME ( NAME )

Tgt:  tzinfo . __init__ ( self )
Pred: tzinfo . __init__ ( self )
==================
NL:return value .
Tgt:  return NAME
Pred: return NAME

Tgt:  return value
Pred: return value
==================
NL:import module sys .
Tgt:  import NAME
Pred: import NAME

Tgt:  import sys
Pred: import sys
*** good long
==================
NL:define the method chars with 4 arguments : self , num , truncate set to None , html set to boolean False .
Tgt:  def NAME ( NAME , NAME , NAME = None , NAME = False ) :
Pred: def NAME ( NAME , NAME , NAME = None , NAME = False ) :

Tgt:  def chars ( self , num , truncate = None , html = False ) :
Pred: def chars ( self , num , truncate = None , html = False ) :
==================
NL:return data .
Tgt:  return NAME
Pred: return NAME

Tgt:  return data
Pred: return data
==================
NL:convert role to uppercase .
Tgt:  NAME = NAME . NAME ( )
Pred: NAME = NAME . NAME ( )

Tgt:  role = role . upper ( )
Pred: role = role . upper ( )
==================
NL:if data is an instance of bytes .
Tgt:  if isinstance ( NAME , NAME ) :
Pred: if isinstance ( NAME , NAME ) :

Tgt:  if isinstance ( data , bytes ) :
Pred: if isinstance ( data , bytes ) :
==================
NL:break the execution of the smallest enclosing loop .
Tgt:  NAME
Pred: NAME

Tgt:  break
Pred: break
==================
NL:message_context is None .
Tgt:  NAME = None
Pred: NAME = None

Tgt:  message_context = None
Pred: message_context = None
==================
NL:if first element of g equals a string _STR:0_ ,
Tgt:  if NAME [ NUMBER ] == STRING :
Pred: if NAME [ NUMBER ] == STRING :

Tgt:  if g [ 0 ] == <[> _STR:0_ <]> :
Pred: if g [ 0 ] == <[> _STR:0_ <]> :
==================
NL:if not ,
Tgt:  else :
Pred: else :

Tgt:  else :
Pred: else :
==================
NL:substitute name for new .
Tgt:  NAME = NAME
Pred: NAME = NAME

Tgt:  new = name
Pred: new = name
==================
NL:call the method self._text_words [ self . _text_words ] with 2 arguments length and truncate , return the result .
Tgt:  return NAME . NAME ( NAME , NAME )
Pred: return NAME . NAME ( NAME , NAME )

Tgt:  return self . _text_words ( length , truncate )
Pred: return self . _text_words ( length , truncate )
==================
NL:self.waiting_readers [ self . waiting_readers ] is integer 0 .
Tgt:  NAME . NAME = NUMBER
Pred: NAME . NAME = NUMBER

Tgt:  self . waiting_readers = 0
Pred: self . waiting_readers = 0
==================
NL:substitute the result for context_match . call the method context_match.group [ context_match . group ] with an argument integer 1 , substitute the result for message_context .
Tgt:  NAME = NAME . NAME ( NUMBER )
Pred: NAME = NAME . NAME ( NUMBER )

Tgt:  message_context = context_match . group ( 1 )
Pred: message_context = context_match . group ( 1 )
==================
NL:substitute name for old_attr .
Tgt:  NAME = NAME
Pred: NAME = NAME

Tgt:  old_attr = name
Pred: old_attr = name
==================
NL:if ImportError exception is caught ,
Tgt:  except NAME :
Pred: except NAME :

Tgt:  except ImportError :
Pred: except ImportError :
==================
NL:if strict is false ,
Tgt:  if not NAME :
Pred: if not NAME :

Tgt:  if not strict :
Pred: if not strict :
==================
NL:for every o in opts ,
Tgt:  for NAME in NAME :
Pred: for NAME in NAME :

Tgt:  for o in opts :
Pred: for o in opts :
==================
NL:if message is an instance of SafeData .
Tgt:  if isinstance ( NAME , NAME ) :
Pred: if isinstance ( NAME , NAME ) :

Tgt:  if isinstance ( message , SafeData ) :
Pred: if isinstance ( message , SafeData ) :
==================
NL:from django.utils._os [ django . utils . _os ] import upath into default name space .
Tgt:  from NAME . NAME . NAME import NAME
Pred: from NAME . NAME . NAME import NAME

Tgt:  from django . utils . _os import upath
Pred: from django . utils . _os import upath
==================
NL:of the _DJANGO_DEPRECATED_LOCALES dictionary , RemovedInDjango19Warning and stacklevel set to integer 2. call the function translation with an argument language , substitute the result for _active.value [ _active . value ] .
Tgt:  NAME . NAME = NAME ( NAME )
Pred: NAME . NAME = NAME ( NAME )

Tgt:  _active . value = translation ( language )
Pred: _active . value = translation ( language )
==================
NL:define the function gettext_noop with an argument message .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def gettext_noop ( message ) :
Pred: def gettext_noop ( message ) :
==================
NL:call the function force_text with an argument truncate , substitute the result for truncate .
Tgt:  NAME = NAME ( NAME )
Pred: NAME = NAME ( NAME )

Tgt:  truncate = force_text ( truncate )
Pred: truncate = force_text ( truncate )
==================
NL:substitute unicode for text_type .
Tgt:  NAME = unicode
Pred: NAME = NAME

Tgt:  text_type = unicode
Pred: text_type = unicode
==================
NL:return an empty list .
Tgt:  return [ ]
Pred: return [ ]

Tgt:  return [ ]
Pred: return [ ]
==================
NL:return None .
Tgt:  return None
Pred: return None

Tgt:  return None
Pred: return None
==================
NL:if tt.tm_isdst [ tt . tm_isdst ] is greater than integer 0 , return the result .
Tgt:  return NAME . NAME > NUMBER
Pred: return NAME . NAME > NUMBER

Tgt:  return tt . tm_isdst > 0
Pred: return tt . tm_isdst > 0
==================
NL:covert to uppercase language elements from ( p+1 ) -th index to the end , append it to the previous result , return it . if not ,
Tgt:  else :
Pred: else :

Tgt:  else :
Pred: else :
==================
NL:add integer 1 to it , substitute the result for space . if space equals integer 0 ,
Tgt:  if NAME == NUMBER :
Pred: if NAME == NUMBER :

Tgt:  if space == 0 :
Pred: if space == 0 :
==================
NL:from django.utils.deprecation [ django . utils . deprecation ] import RemovedInDjango19Warning into default name space .
Tgt:  from NAME . NAME . NAME import NAME
Pred: from NAME . NAME . NAME import NAME

Tgt:  from django . utils . deprecation import RemovedInDjango19Warning
Pred: from django . utils . deprecation import RemovedInDjango19Warning
==================
NL:call the function re.compile [ re . compile ] with an argument raw string _STR:0_ , substitute the result for one_percent_re .
Tgt:  NAME = re . compile ( STRING )
Pred: NAME = re . compile ( STRING )

Tgt:  one_percent_re = re . compile ( <[> _STR:0_ <]> )
Pred: one_percent_re = re . compile ( <[> _STR:0_ <]> )
==================
NL:define the function catalog .
Tgt:  def NAME ( ) :
Pred: def NAME ( ) :

Tgt:  def catalog ( ) :
Pred: def catalog ( ) :
==================
NL:convert self.children [ self . children ] into an boolean , return it .
Tgt:  return bool ( NAME . NAME )
Pred: return bool ( NAME . NAME )

Tgt:  return bool ( self . children )
Pred: return bool ( self . children )
==================
NL:if get_git_changeset has an attribute _STR:0_ ,
Tgt:  if hasattr ( NAME , STRING ) :
Pred: if hasattr ( NAME , STRING ) :

Tgt:  if hasattr ( get_git_changeset , <[> _STR:0_ <]> ) :
Pred: if hasattr ( get_git_changeset , <[> _STR:0_ <]> ) :
==================
NL:if not ,
Tgt:  else :
Pred: else :

Tgt:  else :
Pred: else :
==================
NL:singular is an empty list .
Tgt:  NAME = [ ]
Pred: NAME = [ ]

Tgt:  singular = [ ]
Pred: singular = [ ]
==================
NL:as arguments for the call to the unicode function , return the result . substitute unichr for unichr .
Tgt:  unichr = unichr
Pred: NAME = NAME

Tgt:  unichr = unichr
Pred: unichr = unichr
==================
NL:for every c in self.children [ self . children ] . define the method __repr__ with an argument self .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def __repr__ ( self ) :
Pred: def __repr__ ( self ) :
==================
NL:substitute gettext for ugettext .
Tgt:  NAME = NAME
Pred: NAME = NAME

Tgt:  ugettext = gettext
Pred: ugettext = gettext
==================
NL:return s .
Tgt:  return NAME
Pred: return NAME

Tgt:  return s
Pred: return s
==================
NL:return t .
Tgt:  return NAME
Pred: return NAME

Tgt:  return t
Pred: return t
==================
NL:attrs is a list with 2 elements : strings _STR:0_ and _STR:1_ .
Tgt:  NAME = [ STRING , STRING ]
Pred: NAME = [ STRING , STRING ]

Tgt:  attrs = [ <[> _STR:0_ <]> , <[> _STR:1_ <]> ]
Pred: attrs = [ <[> _STR:0_ <]> , <[> _STR:1_ <]> ]
==================
NL:call the method dot_re.sub [ dot_re . sub ] with 2 arguments : char and src , return the result .
Tgt:  return NAME . NAME ( NAME , NAME )
Pred: return NAME . NAME ( NAME , NAME )

Tgt:  return dot_re . sub ( char , src )
Pred: return dot_re . sub ( char , src )
==================
NL:if t.token_type [ t . token_type ] equals TOKEN_BLOCK ,
Tgt:  if NAME . NAME == NAME :
Pred: if NAME . NAME == NAME :

Tgt:  if t . token_type == TOKEN_BLOCK :
Pred: if t . token_type == TOKEN_BLOCK :
==================
NL:call the __init__ method with an argument name from the base class of the MovedModule class .
Tgt:  super ( NAME , NAME ) . NAME ( NAME )
Pred: super ( NAME , NAME ) . NAME ( NAME )

Tgt:  super ( MovedModule , self ) . __init__ ( name )
Pred: super ( MovedModule , self ) . __init__ ( name )
==================
NL:_func_closure is a string _STR:0_ .
Tgt:  NAME = STRING
Pred: NAME = STRING

Tgt:  _func_closure = <[> _STR:0_ <]>
Pred: _func_closure = <[> _STR:0_ <]>
==================
NL:call the function six.unichr [ six . unichr ] with value under the text key of the html_entities.name2codepoint [ html_entities . name2codepoint ] dictionary , return the result .
Tgt:  return NAME . unichr ( NAME . NAME [ NAME ] )
Pred: return NAME . NAME ( NAME . NAME [ NAME ] )

Tgt:  return six . unichr ( html_entities . name2codepoint [ text ] )
Pred: return six . unichr ( html_entities . name2codepoint [ text ] )
==================
NL:define the method dst with 2 arguments self and dt .
Tgt:  def NAME ( NAME , NAME ) :
Pred: def NAME ( NAME , NAME ) :

Tgt:  def dst ( self , dt ) :
Pred: def dst ( self , dt ) :
==================
NL:try ,
Tgt:  try :
Pred: try :

Tgt:  try :
Pred: try :
==================
NL:try ,
Tgt:  try :
Pred: try :

Tgt:  try :
Pred: try :
==================
NL:if self.__language [ self . __language ] equals settings.LANGUAGE_CODE [ settings . LANGUAGE_CODE ] ,
Tgt:  if NAME . NAME == NAME . NAME :
Pred: if NAME . NAME == NAME . NAME :

Tgt:  if self . __language == settings . LANGUAGE_CODE :
Pred: if self . __language == settings . LANGUAGE_CODE :
==================
NL:define the method __init__ with 2 arguments : self and text .
Tgt:  def NAME ( NAME , NAME ) :
Pred: def NAME ( NAME , NAME ) :

Tgt:  def __init__ ( self , text ) :
Pred: def __init__ ( self , text ) :
==================
NL:covert to lowercase locale elements from ( p+1 ) -th index to the end , append it to the previous result , return it . if not ,
Tgt:  else :
Pred: else :

Tgt:  else :
Pred: else :
==================
NL:raise an ValueError exception wit an argument string _STR:0_ , where _STR:1_ is replaced with s .
Tgt:  raise NAME ( STRING % NAME )
Pred: raise NAME ( STRING % NAME )

Tgt:  raise ValueError ( <[> _STR:0_ <]> % s )
Pred: raise ValueError ( <[> _STR:0_ <]> % s )
==================
NL:substitute offset for self.__offset [ self . __offset ] .
Tgt:  NAME . NAME = NAME
Pred: NAME . NAME = NAME

Tgt:  self . __offset = offset
Pred: self . __offset = offset
==================
NL:call the method threading.Semaphore [ threading . Semaphore ] with an argument integer 0 , substitute the result for self.can_write [ self . can_write ] .
Tgt:  NAME . NAME = NAME . NAME ( NUMBER )
Pred: NAME . NAME = NAME . NAME ( NUMBER )

Tgt:  self . can_write = threading . Semaphore ( 0 )
Pred: self . can_write = threading . Semaphore ( 0 )
==================
NL:define the function get_fixed_timezone with an argument offset .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def get_fixed_timezone ( offset ) :
Pred: def get_fixed_timezone ( offset ) :
==================
NL:return a string _STR:0_ .
Tgt:  return STRING
Pred: return STRING

Tgt:  return <[> _STR:0_ <]>
Pred: return <[> _STR:0_ <]>
==================
NL:if _default is None ,
Tgt:  if NAME is None :
Pred: if NAME is None :

Tgt:  if _default is None :
Pred: if _default is None :
==================
NL:_meth_func is a string _STR:0_ .
Tgt:  NAME = STRING
Pred: NAME = STRING

Tgt:  _meth_func = <[> _STR:0_ <]>
Pred: _meth_func = <[> _STR:0_ <]>
==================
NL:call the method self._resolve [ self . _resolve ] , substitute the result for result .
Tgt:  NAME = NAME . NAME ( )
Pred: NAME = NAME . NAME ( )

Tgt:  result = self . _resolve ( )
Pred: result = self . _resolve ( )
==================
NL:if truncate_len equals integer 0 .
Tgt:  if NAME == NUMBER :
Pred: if NAME == NUMBER :

Tgt:  if truncate_len == 0 :
Pred: if truncate_len == 0 :
==================
NL:define the method __add__ with 2 arguments self and rhs .
Tgt:  def NAME ( NAME , NAME ) :
Pred: def NAME ( NAME , NAME ) :

Tgt:  def __add__ ( self , rhs ) :
Pred: def __add__ ( self , rhs ) :
==================
NL:define the method __enter__ with an argument self .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def __enter__ ( self ) :
Pred: def __enter__ ( self ) :
==================
NL:define the function get_current_timezone_name .
Tgt:  def NAME ( ) :
Pred: def NAME ( ) :

Tgt:  def get_current_timezone_name ( ) :
Pred: def get_current_timezone_name ( ) :
==================
NL:otherwise if intrans is true ,
Tgt:  elif NAME :
Pred: elif NAME :

Tgt:  elif intrans :
Pred: elif intrans :
==================
NL:replace every occurrence of _STR:0_ in s with _STR:1_ .
Tgt:  NAME = NAME . NAME ( STRING , STRING )
Pred: NAME = NAME . NAME ( STRING , STRING )

Tgt:  s = s . replace ( <[> _STR:0_ <]> , <[> _STR:1_ <]> )
Pred: s = s . replace ( <[> _STR:0_ <]> , <[> _STR:1_ <]> )
==================
NL:define the method __get__ with 3 arguments : self , obj and tp .
Tgt:  def NAME ( NAME , NAME , NAME ) :
Pred: def NAME ( NAME , NAME , NAME ) :

Tgt:  def __get__ ( self , obj , tp ) :
Pred: def __get__ ( self , obj , tp ) :
==================
NL:define the function get_language_from_path with an argument path .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def get_language_from_path ( path ) :
Pred: def get_language_from_path ( path ) :
==================
NL:attrs is an empty dictionary .
Tgt:  NAME = { }
Pred: NAME = { }

Tgt:  attrs = { }
Pred: attrs = { }
==================
NL:flush zfile stream buffer .
Tgt:  NAME . NAME ( )
Pred: NAME . NAME ( )

Tgt:  zfile . flush ( )
Pred: zfile . flush ( )
==================
NL:define the function templatize with 2 arguments : src and origin set to None .
Tgt:  def NAME ( NAME , NAME = None ) :
Pred: def NAME ( NAME , NAME = None ) :

Tgt:  def templatize ( src , origin = None ) :
Pred: def templatize ( src , origin = None ) :
==================
NL:if ValueError exception is caught ,
Tgt:  except NAME :
Pred: except NAME :

Tgt:  except ValueError :
Pred: except ValueError :
==================
NL:call the function to_locale with an argument language , substitute it for self.__locale [ self . __locale ] .
Tgt:  NAME . NAME = NAME ( NAME )
Pred: NAME . NAME = NAME ( NAME )

Tgt:  self . __locale = to_locale ( language )
Pred: self . __locale = to_locale ( language )
==================
NL:define the function ungettext with 3 arguments : singular , plural and number .
Tgt:  def NAME ( NAME , NAME , NAME ) :
Pred: def NAME ( NAME , NAME , NAME ) :

Tgt:  def ungettext ( singular , plural , number ) :
Pred: def ungettext ( singular , plural , number ) :
==================
NL:buf is an instance of StreamingBuffer class .
Tgt:  NAME = NAME ( )
Pred: NAME = NAME ( )

Tgt:  buf = StreamingBuffer ( )
Pred: buf = StreamingBuffer ( )
==================
NL:return self .
Tgt:  return NAME
Pred: return NAME

Tgt:  return self
Pred: return self
==================
NL:define the function unescape_string_literal with an argument s .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def unescape_string_literal ( s ) :
Pred: def unescape_string_literal ( s ) :
==================
NL:define the function get_language_bidi .
Tgt:  def NAME ( ) :
Pred: def NAME ( ) :

Tgt:  def get_language_bidi ( ) :
Pred: def get_language_bidi ( ) :
==================
NL:substitute last element of colors for value under the _STR:0_ key of definition dictionary .
Tgt:  NAME [ STRING ] = NAME [ - NUMBER ]
Pred: NAME [ STRING ] = NAME [ - NUMBER ]

Tgt:  definition [ <[> _STR:0_ <]> ] = colors [ - 1 ]
Pred: definition [ <[> _STR:0_ <]> ] = colors [ - 1 ]
==================
NL:substitute _moved_attributes for _MovedItems._moved_attributes [ _MovedItems . _moved_attributes ] .
Tgt:  NAME . NAME = NAME
Pred: NAME . NAME = NAME

Tgt:  _MovedItems . _moved_attributes = _moved_attributes
Pred: _MovedItems . _moved_attributes = _moved_attributes
==================
NL:do nothing .
Tgt:  NAME
Pred: NAME

Tgt:  pass
Pred: pass
==================
NL:define the function gettext with an argument message .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def gettext ( message ) :
Pred: def gettext ( message ) :
==================
NL:derive the class EscapeBytes from bytes and EscapeData base classes .
Tgt:  class NAME ( NAME , NAME ) :
Pred: class NAME ( NAME , NAME ) :

Tgt:  class EscapeBytes ( bytes , EscapeData ) :
Pred: class EscapeBytes ( bytes , EscapeData ) :
==================
NL:if not ,
Tgt:  else :
Pred: else :

Tgt:  else :
Pred: else :
==================
NL:if not ,
Tgt:  else :
Pred: else :

Tgt:  else :
Pred: else :
==================
NL:return get_git_changeset.cache [ get_git_changeset . cache ] .
Tgt:  return NAME . NAME
Pred: return NAME . NAME

Tgt:  return get_git_changeset . cache
Pred: return get_git_changeset . cache
==================
NL:from django.utils.safestring [ django . utils . safestring ] import mark_safe into default name space .
Tgt:  from NAME . NAME . NAME import NAME
Pred: from NAME . NAME . NAME import NAME

Tgt:  from django . utils . safestring import mark_safe
Pred: from django . utils . safestring import mark_safe
==================
NL:derive the class SafeBytes from bytes and SafeData base classes .
Tgt:  class NAME ( NAME , NAME ) :
Pred: class NAME ( NAME , NAME ) :

Tgt:  class SafeBytes ( bytes , SafeData ) :
Pred: class SafeBytes ( bytes , SafeData ) :
==================
NL:derive the class EscapeData from object base class .
Tgt:  class NAME ( object ) :
Pred: class NAME ( object ) :

Tgt:  class EscapeData ( object ) :
Pred: class EscapeData ( object ) :
==================
NL:if _active has an attribute _STR:0_ ,
Tgt:  if hasattr ( NAME , STRING ) :
Pred: if hasattr ( NAME , STRING ) :

Tgt:  if hasattr ( _active , <[> _STR:0_ <]> ) :
Pred: if hasattr ( _active , <[> _STR:0_ <]> ) :
==================
NL:define the function translation with an argument language .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def translation ( language ) :
Pred: def translation ( language ) :
==================
NL:define the function mark_for_escaping with an argument s .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def mark_for_escaping ( s ) :
Pred: def mark_for_escaping ( s ) :
==================
NL:raise an AttributeError with an argument string _STR:0_ , formated with self.name [ self . name ] .
Tgt:  raise NAME ( STRING % NAME . NAME )
Pred: raise NAME ( STRING % NAME . NAME )

Tgt:  raise AttributeError ( <[> _STR:0_ <]> % self . name )
Pred: raise AttributeError ( <[> _STR:0_ <]> % self . name )
==================
NL:if contents is not None ,
Tgt:  if NAME is not None :
Pred: if NAME is not None :

Tgt:  if contents is not None :
Pred: if contents is not None :
==================
NL:define the method __len__ with an argument self .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def __len__ ( self ) :
Pred: def __len__ ( self ) :
==================
NL:from django.utils.translation [ django . utils . translation ] import TranslatorCommentWarning , trim_whitespace and LANGUAGE_SESSION_KEY into default name space .
Tgt:  from NAME . NAME . NAME import NAME , NAME , NAME
Pred: from NAME . NAME . NAME import NAME , NAME , NAME

Tgt:  from django . utils . translation import TranslatorCommentWarning , trim_whitespace , LANGUAGE_SESSION_KEY
Pred: from django . utils . translation import TranslatorCommentWarning , trim_whitespace , LANGUAGE_SESSION_KEY
==================
NL:derive the class EscapeText from six.text_type [ six . text_type ] and EscapeData base classes .
Tgt:  class NAME ( NAME . NAME , NAME ) :
Pred: class NAME ( NAME . NAME , NAME ) :

Tgt:  class EscapeText ( six . text_type , EscapeData ) :
Pred: class EscapeText ( six . text_type , EscapeData ) :
==================
NL:substitute name for self.name [ self . name ] .
Tgt:  NAME . NAME = NAME
Pred: NAME . NAME = NAME

Tgt:  self . name = name
Pred: self . name = name
==================
NL:call the method value.astimezone [ value . astimezone ] with an argument timezone , substitute the result for value .
Tgt:  NAME = NAME . NAME ( NAME )
Pred: NAME = NAME . NAME ( NAME )

Tgt:  value = value . astimezone ( timezone )
Pred: value = value . astimezone ( timezone )
==================
NL:s_len is integer 0 .
Tgt:  NAME = NUMBER
Pred: NAME = NUMBER

Tgt:  s_len = 0
Pred: s_len = 0
==================
NL:incomment is boolean False .
Tgt:  NAME = False
Pred: NAME = False

Tgt:  incomment = False
Pred: incomment = False
==================
NL:call the nethod self._isdst [ self . _isdst ] with an argument dt , if it evaluates to true ,
Tgt:  if NAME . NAME ( NAME ) :
Pred: if NAME . NAME ( NAME ) :

Tgt:  if self . _isdst ( dt ) :
Pred: if self . _isdst ( dt ) :
==================
NL:call the function language_code_prefix_re.match [ language_code_prefix_re . match ] with an argument path , substitute it for regex_match .
Tgt:  NAME = NAME . NAME ( NAME )
Pred: NAME = NAME . NAME ( NAME )

Tgt:  regex_match = language_code_prefix_re . match ( path )
Pred: regex_match = language_code_prefix_re . match ( path )
==================
NL:get the value under the lang_code key of the _BROWSERS_DEPRECATED_LOCALES dictionary , substitute it for replacement .
Tgt:  NAME = NAME . NAME ( NAME )
Pred: NAME = NAME . NAME ( NAME )

Tgt:  replacement = _BROWSERS_DEPRECATED_LOCALES . get ( lang_code )
Pred: replacement = _BROWSERS_DEPRECATED_LOCALES . get ( lang_code )
==================
NL:define the function callable with an argument obj .
Tgt:  def callable ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def callable ( obj ) :
Pred: def callable ( obj ) :
==================
NL:call the function allow_lazy with 2 arguments : wrap and six.text_type [ six . text_type ] , substitute the result for wrap .
Tgt:  NAME = NAME ( NAME , NAME . NAME )
Pred: NAME = NAME ( NAME , NAME . NAME )

Tgt:  wrap = allow_lazy ( wrap , six . text_type )
Pred: wrap = allow_lazy ( wrap , six . text_type )
==================
NL:define the method __init__ with 3 arguments : self , offset set to None , name set to None .
Tgt:  def NAME ( NAME , NAME = None , NAME = None ) :
Pred: def NAME ( NAME , NAME = None , NAME = None ) :

Tgt:  def __init__ ( self , offset = None , name = None ) :
Pred: def __init__ ( self , offset = None , name = None ) :
==================
NL:derive the class ReferenceLocalTimezone from the tzinfo base class .
Tgt:  class NAME ( NAME ) :
Pred: class NAME ( NAME ) :

Tgt:  class ReferenceLocalTimezone ( tzinfo ) :
Pred: class ReferenceLocalTimezone ( tzinfo ) :
==================
NL:if request has an attribute _STR:0_ ,
Tgt:  if hasattr ( NAME , STRING ) :
Pred: if hasattr ( NAME , STRING ) :

Tgt:  if hasattr ( request , <[> _STR:0_ <]> ) :
Pred: if hasattr ( request , <[> _STR:0_ <]> ) :
==================
NL:substitute space for sep .
Tgt:  NAME = NAME
Pred: NAME = NAME

Tgt:  sep = space
Pred: sep = space
==================
NL:if not ,
Tgt:  else :
Pred: else :

Tgt:  else :
Pred: else :
==================
NL:define the method _add_fallback with an argument self .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def _add_fallback ( self ) :
Pred: def _add_fallback ( self ) :
==================
NL:errors is a string _STR:0_ .
Tgt:  NAME = STRING
Pred: NAME = STRING

Tgt:  errors = <[> _STR:0_ <]>
Pred: errors = <[> _STR:0_ <]>
==================
NL:result is an empty list .
Tgt:  NAME = [ ]
Pred: NAME = [ ]

Tgt:  result = [ ]
Pred: result = [ ]
==================
NL:call the method self.merge [ self . merge ] with an argument translation .
Tgt:  NAME . NAME ( NAME )
Pred: NAME . NAME ( NAME )

Tgt:  self . merge ( translation )
Pred: self . merge ( translation )
==================
NL:define the function camel_case_to_spaces with an argument value .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def camel_case_to_spaces ( value ) :
Pred: def camel_case_to_spaces ( value ) :
==================
NL:if not ,
Tgt:  else :
Pred: else :

Tgt:  else :
Pred: else :
==================
NL:if AttributeError exception is caught ,
Tgt:  except NAME :
Pred: except NAME :

Tgt:  except AttributeError :
Pred: except AttributeError :
==================
NL:return boolean True , otherwise return boolean False . define the function make_aware with 2 arguments : value and timezone .
Tgt:  def NAME ( NAME , NAME ) :
Pred: def NAME ( NAME , NAME ) :

Tgt:  def make_aware ( value , timezone ) :
Pred: def make_aware ( value , timezone ) :
==================
NL:if want_unicode is true ,
Tgt:  if NAME :
Pred: if NAME :

Tgt:  if want_unicode :
Pred: if want_unicode :
==================
NL:if six.PY3 [ six . PY3 ] is true ,
Tgt:  if NAME . NAME :
Pred: if NAME . NAME :

Tgt:  if six . PY3 :
Pred: if six . PY3 :
==================
NL:if language is contained in _DJANGO_DEPRECATED_LOCALES ,
Tgt:  if NAME in NAME :
Pred: if NAME in NAME :

Tgt:  if language in _DJANGO_DEPRECATED_LOCALES :
Pred: if language in _DJANGO_DEPRECATED_LOCALES :
==================
NL:call the function allow_lazy with an argument phone2numeric , substitute the result for phone2numeric .
Tgt:  NAME = NAME ( NAME )
Pred: NAME = NAME ( NAME )

Tgt:  phone2numeric = allow_lazy ( phone2numeric )
Pred: phone2numeric = allow_lazy ( phone2numeric )
==================
NL:substitute language for self.__language [ self . __language ] .
Tgt:  NAME . NAME = NAME
Pred: NAME . NAME = NAME

Tgt:  self . __language = language
Pred: self . __language = language
==================
NL:substitute the result for exc_value . substitute exc for exc_value.__cause__ [ exc_value . __cause__ ] .
Tgt:  NAME . NAME = NAME
Pred: NAME . NAME = NAME

Tgt:  exc_value . __cause__ = exc
Pred: exc_value . __cause__ = exc
==================
NL:if p is greater or equal to integer 0 ,
Tgt:  if NAME >= NUMBER :
Pred: if NAME >= NUMBER :

Tgt:  if p >= 0 :
Pred: if p >= 0 :
==================
NL:call the method self.writer_leaves [ self . writer_leaves ] .
Tgt:  NAME . NAME ( )
Pred: NAME . NAME ( )

Tgt:  self . writer_leaves ( )
Pred: self . writer_leaves ( )
==================
NL:substitute new_mod for self.mod [ self . mod ] .
Tgt:  NAME . NAME = NAME
Pred: NAME . NAME = NAME

Tgt:  self . mod = new_mod
Pred: self . mod = new_mod
==================
NL:and unpacked dictionary kwargs , return the result . define the function assertRegex with 3 arguments : self , unpacked list args and unpacked dictionary kwargs .
Tgt:  def NAME ( NAME , * NAME , ** NAME ) :
Pred: def NAME ( NAME , * NAME , ** NAME ) :

Tgt:  def assertRegex ( self , * args , ** kwargs ) :
Pred: def assertRegex ( self , * args , ** kwargs ) :
==================
NL:import module gettext as gettext_module .
Tgt:  import NAME as NAME
Pred: import NAME as NAME

Tgt:  import gettext as gettext_module
Pred: import gettext as gettext_module
==================
NL:if current_len equals truncate_len ,
Tgt:  if NAME == NAME :
Pred: if NAME == NAME :

Tgt:  if current_len == truncate_len :
Pred: if current_len == truncate_len :
==================
NL:if PY3 is true ,
Tgt:  if NAME :
Pred: if NAME :

Tgt:  if PY3 :
Pred: if PY3 :
==================
NL:from django.conf [ django . conf ] import settings into default name space .
Tgt:  from NAME . NAME import NAME
Pred: from NAME . NAME import NAME

Tgt:  from django . conf import settings
Pred: from django . conf import settings
==================
NL:called with an argument lang_code is true , return lang_code .
Tgt:  return NAME
Pred: return NAME

Tgt:  return lang_code
Pred: return lang_code
==================
NL:call the function _trans.get_language_from_request [ _trans . get_language_from_request ] with 2 arguments : request and check_path , return the result .
Tgt:  return NAME . NAME ( NAME , NAME )
Pred: return NAME . NAME ( NAME , NAME )

Tgt:  return _trans . get_language_from_request ( request , check_path )
Pred: return _trans . get_language_from_request ( request , check_path )
==================
NL:if AttributeError exception is caught ,
Tgt:  except NAME :
Pred: except NAME :

Tgt:  except AttributeError :
Pred: except AttributeError :
==================
NL:substitute io.StringIO [ io . StringIO ] for StringIO .
Tgt:  NAME = NAME . NAME
Pred: NAME = NAME . NAME

Tgt:  StringIO = io . StringIO
Pred: StringIO = io . StringIO
==================
NL:define the method __init__ with an argument self .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def __init__ ( self ) :
Pred: def __init__ ( self ) :
==================
NL:obj is an instance of Node class , created with 2 arguments : connector set to self.connector [ self . connector ] and negated set to self.negated [ self . negated ] .
Tgt:  NAME = NAME ( NAME = NAME . NAME , NAME = NAME . NAME )
Pred: NAME = NAME ( NAME = NAME . NAME , NAME = NAME . NAME )

Tgt:  obj = Node ( connector = self . connector , negated = self . negated )
Pred: obj = Node ( connector = self . connector , negated = self . negated )
==================
NL:return result .
Tgt:  return NAME
Pred: return NAME

Tgt:  return result
Pred: return result
==================
NL:substitute str for text_type .
Tgt:  NAME = str
Pred: NAME = str

Tgt:  text_type = str
Pred: text_type = str
==================
NL:if offset is an instance of timedelta class ,
Tgt:  if isinstance ( NAME , NAME ) :
Pred: if isinstance ( NAME , NAME ) :

Tgt:  if isinstance ( offset , timedelta ) :
Pred: if isinstance ( offset , timedelta ) :
==================
NL:increment self.active_writers [ self . active_writers ] by integer 1 ,
Tgt:  NAME . NAME += NUMBER
Pred: NAME . NAME += NUMBER

Tgt:  self . active_writers += 1
Pred: self . active_writers += 1
==================
NL:define the method reader_enters with an argument self .
Tgt:  def NAME ( NAME ) :
Pred: def NAME ( NAME ) :

Tgt:  def reader_enters ( self ) :
Pred: def reader_enters ( self ) :
